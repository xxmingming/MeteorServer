// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protocol.proto

#ifndef PROTOBUF_protocol_2eproto__INCLUDED
#define PROTOBUF_protocol_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_protocol_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[22];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsMeteorMsgImpl();
void InitDefaultsMeteorMsg();
void InitDefaultsRoomInfoImpl();
void InitDefaultsRoomInfo();
void InitDefaultsOnLeaveRoomRspImpl();
void InitDefaultsOnLeaveRoomRsp();
void InitDefaultsGetRoomRspImpl();
void InitDefaultsGetRoomRsp();
void InitDefaultsCreateRoomReqImpl();
void InitDefaultsCreateRoomReq();
void InitDefaultsCreateRoomRspImpl();
void InitDefaultsCreateRoomRsp();
void InitDefaultsJoinRoomReqImpl();
void InitDefaultsJoinRoomReq();
void InitDefaultsJoinRoomRspImpl();
void InitDefaultsJoinRoomRsp();
void InitDefaultsEnterLevelReqImpl();
void InitDefaultsEnterLevelReq();
void InitDefaultsEnterLevelRspImpl();
void InitDefaultsEnterLevelRsp();
void InitDefaultsOnEnterRoomRspImpl();
void InitDefaultsOnEnterRoomRsp();
void InitDefaultsOnEnterLevelRspImpl();
void InitDefaultsOnEnterLevelRsp();
void InitDefaultsVector2_Impl();
void InitDefaultsVector2_();
void InitDefaultsVector3_Impl();
void InitDefaultsVector3_();
void InitDefaultsQuaternion_Impl();
void InitDefaultsQuaternion_();
void InitDefaultsSceneInfoImpl();
void InitDefaultsSceneInfo();
void InitDefaultsSceneItem_Impl();
void InitDefaultsSceneItem_();
void InitDefaultsPlayer_Impl();
void InitDefaultsPlayer_();
void InitDefaultsInputReqImpl();
void InitDefaultsInputReq();
void InitDefaultsInput_Impl();
void InitDefaultsInput_();
void InitDefaultsKeyFrameImpl();
void InitDefaultsKeyFrame();
void InitDefaultsUserIdImpl();
void InitDefaultsUserId();
inline void InitDefaults() {
  InitDefaultsMeteorMsg();
  InitDefaultsRoomInfo();
  InitDefaultsOnLeaveRoomRsp();
  InitDefaultsGetRoomRsp();
  InitDefaultsCreateRoomReq();
  InitDefaultsCreateRoomRsp();
  InitDefaultsJoinRoomReq();
  InitDefaultsJoinRoomRsp();
  InitDefaultsEnterLevelReq();
  InitDefaultsEnterLevelRsp();
  InitDefaultsOnEnterRoomRsp();
  InitDefaultsOnEnterLevelRsp();
  InitDefaultsVector2_();
  InitDefaultsVector3_();
  InitDefaultsQuaternion_();
  InitDefaultsSceneInfo();
  InitDefaultsSceneItem_();
  InitDefaultsPlayer_();
  InitDefaultsInputReq();
  InitDefaultsInput_();
  InitDefaultsKeyFrame();
  InitDefaultsUserId();
}
}  // namespace protobuf_protocol_2eproto
class CreateRoomReq;
class CreateRoomReqDefaultTypeInternal;
extern CreateRoomReqDefaultTypeInternal _CreateRoomReq_default_instance_;
class CreateRoomRsp;
class CreateRoomRspDefaultTypeInternal;
extern CreateRoomRspDefaultTypeInternal _CreateRoomRsp_default_instance_;
class EnterLevelReq;
class EnterLevelReqDefaultTypeInternal;
extern EnterLevelReqDefaultTypeInternal _EnterLevelReq_default_instance_;
class EnterLevelRsp;
class EnterLevelRspDefaultTypeInternal;
extern EnterLevelRspDefaultTypeInternal _EnterLevelRsp_default_instance_;
class GetRoomRsp;
class GetRoomRspDefaultTypeInternal;
extern GetRoomRspDefaultTypeInternal _GetRoomRsp_default_instance_;
class InputReq;
class InputReqDefaultTypeInternal;
extern InputReqDefaultTypeInternal _InputReq_default_instance_;
class Input_;
class Input_DefaultTypeInternal;
extern Input_DefaultTypeInternal _Input__default_instance_;
class JoinRoomReq;
class JoinRoomReqDefaultTypeInternal;
extern JoinRoomReqDefaultTypeInternal _JoinRoomReq_default_instance_;
class JoinRoomRsp;
class JoinRoomRspDefaultTypeInternal;
extern JoinRoomRspDefaultTypeInternal _JoinRoomRsp_default_instance_;
class KeyFrame;
class KeyFrameDefaultTypeInternal;
extern KeyFrameDefaultTypeInternal _KeyFrame_default_instance_;
class MeteorMsg;
class MeteorMsgDefaultTypeInternal;
extern MeteorMsgDefaultTypeInternal _MeteorMsg_default_instance_;
class OnEnterLevelRsp;
class OnEnterLevelRspDefaultTypeInternal;
extern OnEnterLevelRspDefaultTypeInternal _OnEnterLevelRsp_default_instance_;
class OnEnterRoomRsp;
class OnEnterRoomRspDefaultTypeInternal;
extern OnEnterRoomRspDefaultTypeInternal _OnEnterRoomRsp_default_instance_;
class OnLeaveRoomRsp;
class OnLeaveRoomRspDefaultTypeInternal;
extern OnLeaveRoomRspDefaultTypeInternal _OnLeaveRoomRsp_default_instance_;
class Player_;
class Player_DefaultTypeInternal;
extern Player_DefaultTypeInternal _Player__default_instance_;
class Quaternion_;
class Quaternion_DefaultTypeInternal;
extern Quaternion_DefaultTypeInternal _Quaternion__default_instance_;
class RoomInfo;
class RoomInfoDefaultTypeInternal;
extern RoomInfoDefaultTypeInternal _RoomInfo_default_instance_;
class SceneInfo;
class SceneInfoDefaultTypeInternal;
extern SceneInfoDefaultTypeInternal _SceneInfo_default_instance_;
class SceneItem_;
class SceneItem_DefaultTypeInternal;
extern SceneItem_DefaultTypeInternal _SceneItem__default_instance_;
class UserId;
class UserIdDefaultTypeInternal;
extern UserIdDefaultTypeInternal _UserId_default_instance_;
class Vector2_;
class Vector2_DefaultTypeInternal;
extern Vector2_DefaultTypeInternal _Vector2__default_instance_;
class Vector3_;
class Vector3_DefaultTypeInternal;
extern Vector3_DefaultTypeInternal _Vector3__default_instance_;

enum MeteorMsg_MsgType {
  MeteorMsg_MsgType_GetRoomReq = 100,
  MeteorMsg_MsgType_GetRoomRsp = 101,
  MeteorMsg_MsgType_CreateRoomReq = 102,
  MeteorMsg_MsgType_CreateRoomRsp = 103,
  MeteorMsg_MsgType_JoinRoomReq = 104,
  MeteorMsg_MsgType_JoinRoomRsp = 105,
  MeteorMsg_MsgType_OnJoinRoomRsp = 106,
  MeteorMsg_MsgType_EnterLevelReq = 107,
  MeteorMsg_MsgType_EnterLevelRsp = 108,
  MeteorMsg_MsgType_OnEnterLevelRsp = 109,
  MeteorMsg_MsgType_LeaveRoomReq = 110,
  MeteorMsg_MsgType_OnLeaveRoomRsp = 111,
  MeteorMsg_MsgType_InputReq = 112,
  MeteorMsg_MsgType_SyncInput = 113,
  MeteorMsg_MsgType_KeyFrameReq = 114,
  MeteorMsg_MsgType_SyncKeyFrame = 115,
  MeteorMsg_MsgType_UserDeadSB2C = 116,
  MeteorMsg_MsgType_UserRebornReq = 117,
  MeteorMsg_MsgType_UserRebornSB2C = 118
};
bool MeteorMsg_MsgType_IsValid(int value);
const MeteorMsg_MsgType MeteorMsg_MsgType_MsgType_MIN = MeteorMsg_MsgType_GetRoomReq;
const MeteorMsg_MsgType MeteorMsg_MsgType_MsgType_MAX = MeteorMsg_MsgType_UserRebornSB2C;
const int MeteorMsg_MsgType_MsgType_ARRAYSIZE = MeteorMsg_MsgType_MsgType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MeteorMsg_MsgType_descriptor();
inline const ::std::string& MeteorMsg_MsgType_Name(MeteorMsg_MsgType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MeteorMsg_MsgType_descriptor(), value);
}
inline bool MeteorMsg_MsgType_Parse(
    const ::std::string& name, MeteorMsg_MsgType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MeteorMsg_MsgType>(
    MeteorMsg_MsgType_descriptor(), name, value);
}
enum RoomInfo_RoomPattern {
  RoomInfo_RoomPattern_Normal = 1,
  RoomInfo_RoomPattern_Replay = 2
};
bool RoomInfo_RoomPattern_IsValid(int value);
const RoomInfo_RoomPattern RoomInfo_RoomPattern_RoomPattern_MIN = RoomInfo_RoomPattern_Normal;
const RoomInfo_RoomPattern RoomInfo_RoomPattern_RoomPattern_MAX = RoomInfo_RoomPattern_Replay;
const int RoomInfo_RoomPattern_RoomPattern_ARRAYSIZE = RoomInfo_RoomPattern_RoomPattern_MAX + 1;

const ::google::protobuf::EnumDescriptor* RoomInfo_RoomPattern_descriptor();
inline const ::std::string& RoomInfo_RoomPattern_Name(RoomInfo_RoomPattern value) {
  return ::google::protobuf::internal::NameOfEnum(
    RoomInfo_RoomPattern_descriptor(), value);
}
inline bool RoomInfo_RoomPattern_Parse(
    const ::std::string& name, RoomInfo_RoomPattern* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoomInfo_RoomPattern>(
    RoomInfo_RoomPattern_descriptor(), name, value);
}
enum RoomInfo_RoomRule {
  RoomInfo_RoomRule_SinglePlayer = 1,
  RoomInfo_RoomRule_AllDead = 2,
  RoomInfo_RoomRule_LeaderMustDead = 3,
  RoomInfo_RoomRule_DefenceBase = 4,
  RoomInfo_RoomRule_Loot = 5
};
bool RoomInfo_RoomRule_IsValid(int value);
const RoomInfo_RoomRule RoomInfo_RoomRule_RoomRule_MIN = RoomInfo_RoomRule_SinglePlayer;
const RoomInfo_RoomRule RoomInfo_RoomRule_RoomRule_MAX = RoomInfo_RoomRule_Loot;
const int RoomInfo_RoomRule_RoomRule_ARRAYSIZE = RoomInfo_RoomRule_RoomRule_MAX + 1;

const ::google::protobuf::EnumDescriptor* RoomInfo_RoomRule_descriptor();
inline const ::std::string& RoomInfo_RoomRule_Name(RoomInfo_RoomRule value) {
  return ::google::protobuf::internal::NameOfEnum(
    RoomInfo_RoomRule_descriptor(), value);
}
inline bool RoomInfo_RoomRule_Parse(
    const ::std::string& name, RoomInfo_RoomRule* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoomInfo_RoomRule>(
    RoomInfo_RoomRule_descriptor(), name, value);
}
// ===================================================================

class MeteorMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MeteorMsg) */ {
 public:
  MeteorMsg();
  virtual ~MeteorMsg();

  MeteorMsg(const MeteorMsg& from);

  inline MeteorMsg& operator=(const MeteorMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MeteorMsg(MeteorMsg&& from) noexcept
    : MeteorMsg() {
    *this = ::std::move(from);
  }

  inline MeteorMsg& operator=(MeteorMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MeteorMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MeteorMsg* internal_default_instance() {
    return reinterpret_cast<const MeteorMsg*>(
               &_MeteorMsg_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(MeteorMsg* other);
  friend void swap(MeteorMsg& a, MeteorMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MeteorMsg* New() const PROTOBUF_FINAL { return New(NULL); }

  MeteorMsg* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MeteorMsg& from);
  void MergeFrom(const MeteorMsg& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MeteorMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef MeteorMsg_MsgType MsgType;
  static const MsgType GetRoomReq =
    MeteorMsg_MsgType_GetRoomReq;
  static const MsgType GetRoomRsp =
    MeteorMsg_MsgType_GetRoomRsp;
  static const MsgType CreateRoomReq =
    MeteorMsg_MsgType_CreateRoomReq;
  static const MsgType CreateRoomRsp =
    MeteorMsg_MsgType_CreateRoomRsp;
  static const MsgType JoinRoomReq =
    MeteorMsg_MsgType_JoinRoomReq;
  static const MsgType JoinRoomRsp =
    MeteorMsg_MsgType_JoinRoomRsp;
  static const MsgType OnJoinRoomRsp =
    MeteorMsg_MsgType_OnJoinRoomRsp;
  static const MsgType EnterLevelReq =
    MeteorMsg_MsgType_EnterLevelReq;
  static const MsgType EnterLevelRsp =
    MeteorMsg_MsgType_EnterLevelRsp;
  static const MsgType OnEnterLevelRsp =
    MeteorMsg_MsgType_OnEnterLevelRsp;
  static const MsgType LeaveRoomReq =
    MeteorMsg_MsgType_LeaveRoomReq;
  static const MsgType OnLeaveRoomRsp =
    MeteorMsg_MsgType_OnLeaveRoomRsp;
  static const MsgType InputReq =
    MeteorMsg_MsgType_InputReq;
  static const MsgType SyncInput =
    MeteorMsg_MsgType_SyncInput;
  static const MsgType KeyFrameReq =
    MeteorMsg_MsgType_KeyFrameReq;
  static const MsgType SyncKeyFrame =
    MeteorMsg_MsgType_SyncKeyFrame;
  static const MsgType UserDeadSB2C =
    MeteorMsg_MsgType_UserDeadSB2C;
  static const MsgType UserRebornReq =
    MeteorMsg_MsgType_UserRebornReq;
  static const MsgType UserRebornSB2C =
    MeteorMsg_MsgType_UserRebornSB2C;
  static inline bool MsgType_IsValid(int value) {
    return MeteorMsg_MsgType_IsValid(value);
  }
  static const MsgType MsgType_MIN =
    MeteorMsg_MsgType_MsgType_MIN;
  static const MsgType MsgType_MAX =
    MeteorMsg_MsgType_MsgType_MAX;
  static const int MsgType_ARRAYSIZE =
    MeteorMsg_MsgType_MsgType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MsgType_descriptor() {
    return MeteorMsg_MsgType_descriptor();
  }
  static inline const ::std::string& MsgType_Name(MsgType value) {
    return MeteorMsg_MsgType_Name(value);
  }
  static inline bool MsgType_Parse(const ::std::string& name,
      MsgType* value) {
    return MeteorMsg_MsgType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .MeteorMsg.MsgType cmd = 1;
  bool has_cmd() const;
  void clear_cmd();
  static const int kCmdFieldNumber = 1;
  ::MeteorMsg_MsgType cmd() const;
  void set_cmd(::MeteorMsg_MsgType value);

  // @@protoc_insertion_point(class_scope:MeteorMsg)
 private:
  void set_has_cmd();
  void clear_has_cmd();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int cmd_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsMeteorMsgImpl();
};
// -------------------------------------------------------------------

class RoomInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RoomInfo) */ {
 public:
  RoomInfo();
  virtual ~RoomInfo();

  RoomInfo(const RoomInfo& from);

  inline RoomInfo& operator=(const RoomInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoomInfo(RoomInfo&& from) noexcept
    : RoomInfo() {
    *this = ::std::move(from);
  }

  inline RoomInfo& operator=(RoomInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoomInfo* internal_default_instance() {
    return reinterpret_cast<const RoomInfo*>(
               &_RoomInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(RoomInfo* other);
  friend void swap(RoomInfo& a, RoomInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoomInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  RoomInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RoomInfo& from);
  void MergeFrom(const RoomInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RoomInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef RoomInfo_RoomPattern RoomPattern;
  static const RoomPattern Normal =
    RoomInfo_RoomPattern_Normal;
  static const RoomPattern Replay =
    RoomInfo_RoomPattern_Replay;
  static inline bool RoomPattern_IsValid(int value) {
    return RoomInfo_RoomPattern_IsValid(value);
  }
  static const RoomPattern RoomPattern_MIN =
    RoomInfo_RoomPattern_RoomPattern_MIN;
  static const RoomPattern RoomPattern_MAX =
    RoomInfo_RoomPattern_RoomPattern_MAX;
  static const int RoomPattern_ARRAYSIZE =
    RoomInfo_RoomPattern_RoomPattern_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RoomPattern_descriptor() {
    return RoomInfo_RoomPattern_descriptor();
  }
  static inline const ::std::string& RoomPattern_Name(RoomPattern value) {
    return RoomInfo_RoomPattern_Name(value);
  }
  static inline bool RoomPattern_Parse(const ::std::string& name,
      RoomPattern* value) {
    return RoomInfo_RoomPattern_Parse(name, value);
  }

  typedef RoomInfo_RoomRule RoomRule;
  static const RoomRule SinglePlayer =
    RoomInfo_RoomRule_SinglePlayer;
  static const RoomRule AllDead =
    RoomInfo_RoomRule_AllDead;
  static const RoomRule LeaderMustDead =
    RoomInfo_RoomRule_LeaderMustDead;
  static const RoomRule DefenceBase =
    RoomInfo_RoomRule_DefenceBase;
  static const RoomRule Loot =
    RoomInfo_RoomRule_Loot;
  static inline bool RoomRule_IsValid(int value) {
    return RoomInfo_RoomRule_IsValid(value);
  }
  static const RoomRule RoomRule_MIN =
    RoomInfo_RoomRule_RoomRule_MIN;
  static const RoomRule RoomRule_MAX =
    RoomInfo_RoomRule_RoomRule_MAX;
  static const int RoomRule_ARRAYSIZE =
    RoomInfo_RoomRule_RoomRule_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RoomRule_descriptor() {
    return RoomInfo_RoomRule_descriptor();
  }
  static inline const ::std::string& RoomRule_Name(RoomRule value) {
    return RoomInfo_RoomRule_Name(value);
  }
  static inline bool RoomRule_Parse(const ::std::string& name,
      RoomRule* value) {
    return RoomInfo_RoomRule_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string roomName = 2;
  bool has_roomname() const;
  void clear_roomname();
  static const int kRoomNameFieldNumber = 2;
  const ::std::string& roomname() const;
  void set_roomname(const ::std::string& value);
  #if LANG_CXX11
  void set_roomname(::std::string&& value);
  #endif
  void set_roomname(const char* value);
  void set_roomname(const char* value, size_t size);
  ::std::string* mutable_roomname();
  ::std::string* release_roomname();
  void set_allocated_roomname(::std::string* roomname);

  // required uint32 roomId = 1;
  bool has_roomid() const;
  void clear_roomid();
  static const int kRoomIdFieldNumber = 1;
  ::google::protobuf::uint32 roomid() const;
  void set_roomid(::google::protobuf::uint32 value);

  // required uint32 levelIdx = 4;
  bool has_levelidx() const;
  void clear_levelidx();
  static const int kLevelIdxFieldNumber = 4;
  ::google::protobuf::uint32 levelidx() const;
  void set_levelidx(::google::protobuf::uint32 value);

  // required uint32 Group1 = 5;
  bool has_group1() const;
  void clear_group1();
  static const int kGroup1FieldNumber = 5;
  ::google::protobuf::uint32 group1() const;
  void set_group1(::google::protobuf::uint32 value);

  // required uint32 Group2 = 6;
  bool has_group2() const;
  void clear_group2();
  static const int kGroup2FieldNumber = 6;
  ::google::protobuf::uint32 group2() const;
  void set_group2(::google::protobuf::uint32 value);

  // required uint32 playerCount = 7;
  bool has_playercount() const;
  void clear_playercount();
  static const int kPlayerCountFieldNumber = 7;
  ::google::protobuf::uint32 playercount() const;
  void set_playercount(::google::protobuf::uint32 value);

  // required uint32 maxPlayer = 8;
  bool has_maxplayer() const;
  void clear_maxplayer();
  static const int kMaxPlayerFieldNumber = 8;
  ::google::protobuf::uint32 maxplayer() const;
  void set_maxplayer(::google::protobuf::uint32 value);

  // required .RoomInfo.RoomRule rule = 3;
  bool has_rule() const;
  void clear_rule();
  static const int kRuleFieldNumber = 3;
  ::RoomInfo_RoomRule rule() const;
  void set_rule(::RoomInfo_RoomRule value);

  // @@protoc_insertion_point(class_scope:RoomInfo)
 private:
  void set_has_roomid();
  void clear_has_roomid();
  void set_has_roomname();
  void clear_has_roomname();
  void set_has_rule();
  void clear_has_rule();
  void set_has_levelidx();
  void clear_has_levelidx();
  void set_has_group1();
  void clear_has_group1();
  void set_has_group2();
  void clear_has_group2();
  void set_has_playercount();
  void clear_has_playercount();
  void set_has_maxplayer();
  void clear_has_maxplayer();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr roomname_;
  ::google::protobuf::uint32 roomid_;
  ::google::protobuf::uint32 levelidx_;
  ::google::protobuf::uint32 group1_;
  ::google::protobuf::uint32 group2_;
  ::google::protobuf::uint32 playercount_;
  ::google::protobuf::uint32 maxplayer_;
  int rule_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsRoomInfoImpl();
};
// -------------------------------------------------------------------

class OnLeaveRoomRsp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OnLeaveRoomRsp) */ {
 public:
  OnLeaveRoomRsp();
  virtual ~OnLeaveRoomRsp();

  OnLeaveRoomRsp(const OnLeaveRoomRsp& from);

  inline OnLeaveRoomRsp& operator=(const OnLeaveRoomRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OnLeaveRoomRsp(OnLeaveRoomRsp&& from) noexcept
    : OnLeaveRoomRsp() {
    *this = ::std::move(from);
  }

  inline OnLeaveRoomRsp& operator=(OnLeaveRoomRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OnLeaveRoomRsp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OnLeaveRoomRsp* internal_default_instance() {
    return reinterpret_cast<const OnLeaveRoomRsp*>(
               &_OnLeaveRoomRsp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(OnLeaveRoomRsp* other);
  friend void swap(OnLeaveRoomRsp& a, OnLeaveRoomRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OnLeaveRoomRsp* New() const PROTOBUF_FINAL { return New(NULL); }

  OnLeaveRoomRsp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OnLeaveRoomRsp& from);
  void MergeFrom(const OnLeaveRoomRsp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OnLeaveRoomRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 playerId = 2;
  bool has_playerid() const;
  void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  ::google::protobuf::uint32 playerid() const;
  void set_playerid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:OnLeaveRoomRsp)
 private:
  void set_has_playerid();
  void clear_has_playerid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 playerid_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsOnLeaveRoomRspImpl();
};
// -------------------------------------------------------------------

class GetRoomRsp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GetRoomRsp) */ {
 public:
  GetRoomRsp();
  virtual ~GetRoomRsp();

  GetRoomRsp(const GetRoomRsp& from);

  inline GetRoomRsp& operator=(const GetRoomRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetRoomRsp(GetRoomRsp&& from) noexcept
    : GetRoomRsp() {
    *this = ::std::move(from);
  }

  inline GetRoomRsp& operator=(GetRoomRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetRoomRsp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetRoomRsp* internal_default_instance() {
    return reinterpret_cast<const GetRoomRsp*>(
               &_GetRoomRsp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(GetRoomRsp* other);
  friend void swap(GetRoomRsp& a, GetRoomRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetRoomRsp* New() const PROTOBUF_FINAL { return New(NULL); }

  GetRoomRsp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetRoomRsp& from);
  void MergeFrom(const GetRoomRsp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetRoomRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .RoomInfo RoomInLobby = 2;
  int roominlobby_size() const;
  void clear_roominlobby();
  static const int kRoomInLobbyFieldNumber = 2;
  const ::RoomInfo& roominlobby(int index) const;
  ::RoomInfo* mutable_roominlobby(int index);
  ::RoomInfo* add_roominlobby();
  ::google::protobuf::RepeatedPtrField< ::RoomInfo >*
      mutable_roominlobby();
  const ::google::protobuf::RepeatedPtrField< ::RoomInfo >&
      roominlobby() const;

  // @@protoc_insertion_point(class_scope:GetRoomRsp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::RoomInfo > roominlobby_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsGetRoomRspImpl();
};
// -------------------------------------------------------------------

class CreateRoomReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CreateRoomReq) */ {
 public:
  CreateRoomReq();
  virtual ~CreateRoomReq();

  CreateRoomReq(const CreateRoomReq& from);

  inline CreateRoomReq& operator=(const CreateRoomReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateRoomReq(CreateRoomReq&& from) noexcept
    : CreateRoomReq() {
    *this = ::std::move(from);
  }

  inline CreateRoomReq& operator=(CreateRoomReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateRoomReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateRoomReq* internal_default_instance() {
    return reinterpret_cast<const CreateRoomReq*>(
               &_CreateRoomReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(CreateRoomReq* other);
  friend void swap(CreateRoomReq& a, CreateRoomReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateRoomReq* New() const PROTOBUF_FINAL { return New(NULL); }

  CreateRoomReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CreateRoomReq& from);
  void MergeFrom(const CreateRoomReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CreateRoomReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string roomName = 5;
  bool has_roomname() const;
  void clear_roomname();
  static const int kRoomNameFieldNumber = 5;
  const ::std::string& roomname() const;
  void set_roomname(const ::std::string& value);
  #if LANG_CXX11
  void set_roomname(::std::string&& value);
  #endif
  void set_roomname(const char* value);
  void set_roomname(const char* value, size_t size);
  ::std::string* mutable_roomname();
  ::std::string* release_roomname();
  void set_allocated_roomname(::std::string* roomname);

  // required uint32 maxPlayer = 2;
  bool has_maxplayer() const;
  void clear_maxplayer();
  static const int kMaxPlayerFieldNumber = 2;
  ::google::protobuf::uint32 maxplayer() const;
  void set_maxplayer(::google::protobuf::uint32 value);

  // required uint32 levelIdx = 3;
  bool has_levelidx() const;
  void clear_levelidx();
  static const int kLevelIdxFieldNumber = 3;
  ::google::protobuf::uint32 levelidx() const;
  void set_levelidx(::google::protobuf::uint32 value);

  // required uint32 rule = 4;
  bool has_rule() const;
  void clear_rule();
  static const int kRuleFieldNumber = 4;
  ::google::protobuf::uint32 rule() const;
  void set_rule(::google::protobuf::uint32 value);

  // required uint32 hpMax = 6;
  bool has_hpmax() const;
  void clear_hpmax();
  static const int kHpMaxFieldNumber = 6;
  ::google::protobuf::uint32 hpmax() const;
  void set_hpmax(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CreateRoomReq)
 private:
  void set_has_maxplayer();
  void clear_has_maxplayer();
  void set_has_levelidx();
  void clear_has_levelidx();
  void set_has_rule();
  void clear_has_rule();
  void set_has_roomname();
  void clear_has_roomname();
  void set_has_hpmax();
  void clear_has_hpmax();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr roomname_;
  ::google::protobuf::uint32 maxplayer_;
  ::google::protobuf::uint32 levelidx_;
  ::google::protobuf::uint32 rule_;
  ::google::protobuf::uint32 hpmax_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsCreateRoomReqImpl();
};
// -------------------------------------------------------------------

class CreateRoomRsp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CreateRoomRsp) */ {
 public:
  CreateRoomRsp();
  virtual ~CreateRoomRsp();

  CreateRoomRsp(const CreateRoomRsp& from);

  inline CreateRoomRsp& operator=(const CreateRoomRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateRoomRsp(CreateRoomRsp&& from) noexcept
    : CreateRoomRsp() {
    *this = ::std::move(from);
  }

  inline CreateRoomRsp& operator=(CreateRoomRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateRoomRsp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateRoomRsp* internal_default_instance() {
    return reinterpret_cast<const CreateRoomRsp*>(
               &_CreateRoomRsp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(CreateRoomRsp* other);
  friend void swap(CreateRoomRsp& a, CreateRoomRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateRoomRsp* New() const PROTOBUF_FINAL { return New(NULL); }

  CreateRoomRsp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CreateRoomRsp& from);
  void MergeFrom(const CreateRoomRsp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CreateRoomRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 result = 2;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 2;
  ::google::protobuf::uint32 result() const;
  void set_result(::google::protobuf::uint32 value);

  // required uint32 roomId = 3;
  bool has_roomid() const;
  void clear_roomid();
  static const int kRoomIdFieldNumber = 3;
  ::google::protobuf::uint32 roomid() const;
  void set_roomid(::google::protobuf::uint32 value);

  // required uint32 levelId = 4;
  bool has_levelid() const;
  void clear_levelid();
  static const int kLevelIdFieldNumber = 4;
  ::google::protobuf::uint32 levelid() const;
  void set_levelid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CreateRoomRsp)
 private:
  void set_has_result();
  void clear_has_result();
  void set_has_roomid();
  void clear_has_roomid();
  void set_has_levelid();
  void clear_has_levelid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 result_;
  ::google::protobuf::uint32 roomid_;
  ::google::protobuf::uint32 levelid_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsCreateRoomRspImpl();
};
// -------------------------------------------------------------------

class JoinRoomReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:JoinRoomReq) */ {
 public:
  JoinRoomReq();
  virtual ~JoinRoomReq();

  JoinRoomReq(const JoinRoomReq& from);

  inline JoinRoomReq& operator=(const JoinRoomReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JoinRoomReq(JoinRoomReq&& from) noexcept
    : JoinRoomReq() {
    *this = ::std::move(from);
  }

  inline JoinRoomReq& operator=(JoinRoomReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JoinRoomReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JoinRoomReq* internal_default_instance() {
    return reinterpret_cast<const JoinRoomReq*>(
               &_JoinRoomReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(JoinRoomReq* other);
  friend void swap(JoinRoomReq& a, JoinRoomReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JoinRoomReq* New() const PROTOBUF_FINAL { return New(NULL); }

  JoinRoomReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const JoinRoomReq& from);
  void MergeFrom(const JoinRoomReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(JoinRoomReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string userNick = 3;
  bool has_usernick() const;
  void clear_usernick();
  static const int kUserNickFieldNumber = 3;
  const ::std::string& usernick() const;
  void set_usernick(const ::std::string& value);
  #if LANG_CXX11
  void set_usernick(::std::string&& value);
  #endif
  void set_usernick(const char* value);
  void set_usernick(const char* value, size_t size);
  ::std::string* mutable_usernick();
  ::std::string* release_usernick();
  void set_allocated_usernick(::std::string* usernick);

  // required uint32 roomId = 2;
  bool has_roomid() const;
  void clear_roomid();
  static const int kRoomIdFieldNumber = 2;
  ::google::protobuf::uint32 roomid() const;
  void set_roomid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:JoinRoomReq)
 private:
  void set_has_roomid();
  void clear_has_roomid();
  void set_has_usernick();
  void clear_has_usernick();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr usernick_;
  ::google::protobuf::uint32 roomid_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsJoinRoomReqImpl();
};
// -------------------------------------------------------------------

class JoinRoomRsp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:JoinRoomRsp) */ {
 public:
  JoinRoomRsp();
  virtual ~JoinRoomRsp();

  JoinRoomRsp(const JoinRoomRsp& from);

  inline JoinRoomRsp& operator=(const JoinRoomRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JoinRoomRsp(JoinRoomRsp&& from) noexcept
    : JoinRoomRsp() {
    *this = ::std::move(from);
  }

  inline JoinRoomRsp& operator=(JoinRoomRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JoinRoomRsp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JoinRoomRsp* internal_default_instance() {
    return reinterpret_cast<const JoinRoomRsp*>(
               &_JoinRoomRsp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(JoinRoomRsp* other);
  friend void swap(JoinRoomRsp& a, JoinRoomRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JoinRoomRsp* New() const PROTOBUF_FINAL { return New(NULL); }

  JoinRoomRsp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const JoinRoomRsp& from);
  void MergeFrom(const JoinRoomRsp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(JoinRoomRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 result = 2;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 2;
  ::google::protobuf::uint32 result() const;
  void set_result(::google::protobuf::uint32 value);

  // required uint32 reason = 3;
  bool has_reason() const;
  void clear_reason();
  static const int kReasonFieldNumber = 3;
  ::google::protobuf::uint32 reason() const;
  void set_reason(::google::protobuf::uint32 value);

  // required uint32 levelIdx = 4;
  bool has_levelidx() const;
  void clear_levelidx();
  static const int kLevelIdxFieldNumber = 4;
  ::google::protobuf::uint32 levelidx() const;
  void set_levelidx(::google::protobuf::uint32 value);

  // required uint32 roomId = 5;
  bool has_roomid() const;
  void clear_roomid();
  static const int kRoomIdFieldNumber = 5;
  ::google::protobuf::uint32 roomid() const;
  void set_roomid(::google::protobuf::uint32 value);

  // required uint32 playerId = 6;
  bool has_playerid() const;
  void clear_playerid();
  static const int kPlayerIdFieldNumber = 6;
  ::google::protobuf::uint32 playerid() const;
  void set_playerid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:JoinRoomRsp)
 private:
  void set_has_result();
  void clear_has_result();
  void set_has_reason();
  void clear_has_reason();
  void set_has_levelidx();
  void clear_has_levelidx();
  void set_has_roomid();
  void clear_has_roomid();
  void set_has_playerid();
  void clear_has_playerid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 result_;
  ::google::protobuf::uint32 reason_;
  ::google::protobuf::uint32 levelidx_;
  ::google::protobuf::uint32 roomid_;
  ::google::protobuf::uint32 playerid_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsJoinRoomRspImpl();
};
// -------------------------------------------------------------------

class EnterLevelReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:EnterLevelReq) */ {
 public:
  EnterLevelReq();
  virtual ~EnterLevelReq();

  EnterLevelReq(const EnterLevelReq& from);

  inline EnterLevelReq& operator=(const EnterLevelReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EnterLevelReq(EnterLevelReq&& from) noexcept
    : EnterLevelReq() {
    *this = ::std::move(from);
  }

  inline EnterLevelReq& operator=(EnterLevelReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnterLevelReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EnterLevelReq* internal_default_instance() {
    return reinterpret_cast<const EnterLevelReq*>(
               &_EnterLevelReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(EnterLevelReq* other);
  friend void swap(EnterLevelReq& a, EnterLevelReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EnterLevelReq* New() const PROTOBUF_FINAL { return New(NULL); }

  EnterLevelReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EnterLevelReq& from);
  void MergeFrom(const EnterLevelReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EnterLevelReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 camp = 2;
  bool has_camp() const;
  void clear_camp();
  static const int kCampFieldNumber = 2;
  ::google::protobuf::uint32 camp() const;
  void set_camp(::google::protobuf::uint32 value);

  // required uint32 model = 3;
  bool has_model() const;
  void clear_model();
  static const int kModelFieldNumber = 3;
  ::google::protobuf::uint32 model() const;
  void set_model(::google::protobuf::uint32 value);

  // required uint32 weapon = 4;
  bool has_weapon() const;
  void clear_weapon();
  static const int kWeaponFieldNumber = 4;
  ::google::protobuf::uint32 weapon() const;
  void set_weapon(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:EnterLevelReq)
 private:
  void set_has_camp();
  void clear_has_camp();
  void set_has_model();
  void clear_has_model();
  void set_has_weapon();
  void clear_has_weapon();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 camp_;
  ::google::protobuf::uint32 model_;
  ::google::protobuf::uint32 weapon_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsEnterLevelReqImpl();
};
// -------------------------------------------------------------------

class EnterLevelRsp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:EnterLevelRsp) */ {
 public:
  EnterLevelRsp();
  virtual ~EnterLevelRsp();

  EnterLevelRsp(const EnterLevelRsp& from);

  inline EnterLevelRsp& operator=(const EnterLevelRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EnterLevelRsp(EnterLevelRsp&& from) noexcept
    : EnterLevelRsp() {
    *this = ::std::move(from);
  }

  inline EnterLevelRsp& operator=(EnterLevelRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnterLevelRsp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EnterLevelRsp* internal_default_instance() {
    return reinterpret_cast<const EnterLevelRsp*>(
               &_EnterLevelRsp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(EnterLevelRsp* other);
  friend void swap(EnterLevelRsp& a, EnterLevelRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EnterLevelRsp* New() const PROTOBUF_FINAL { return New(NULL); }

  EnterLevelRsp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EnterLevelRsp& from);
  void MergeFrom(const EnterLevelRsp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EnterLevelRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SceneInfo scene = 2;
  bool has_scene() const;
  void clear_scene();
  static const int kSceneFieldNumber = 2;
  const ::SceneInfo& scene() const;
  ::SceneInfo* release_scene();
  ::SceneInfo* mutable_scene();
  void set_allocated_scene(::SceneInfo* scene);

  // @@protoc_insertion_point(class_scope:EnterLevelRsp)
 private:
  void set_has_scene();
  void clear_has_scene();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::SceneInfo* scene_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsEnterLevelRspImpl();
};
// -------------------------------------------------------------------

class OnEnterRoomRsp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OnEnterRoomRsp) */ {
 public:
  OnEnterRoomRsp();
  virtual ~OnEnterRoomRsp();

  OnEnterRoomRsp(const OnEnterRoomRsp& from);

  inline OnEnterRoomRsp& operator=(const OnEnterRoomRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OnEnterRoomRsp(OnEnterRoomRsp&& from) noexcept
    : OnEnterRoomRsp() {
    *this = ::std::move(from);
  }

  inline OnEnterRoomRsp& operator=(OnEnterRoomRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OnEnterRoomRsp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OnEnterRoomRsp* internal_default_instance() {
    return reinterpret_cast<const OnEnterRoomRsp*>(
               &_OnEnterRoomRsp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(OnEnterRoomRsp* other);
  friend void swap(OnEnterRoomRsp& a, OnEnterRoomRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OnEnterRoomRsp* New() const PROTOBUF_FINAL { return New(NULL); }

  OnEnterRoomRsp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OnEnterRoomRsp& from);
  void MergeFrom(const OnEnterRoomRsp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OnEnterRoomRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string playerNick = 2;
  bool has_playernick() const;
  void clear_playernick();
  static const int kPlayerNickFieldNumber = 2;
  const ::std::string& playernick() const;
  void set_playernick(const ::std::string& value);
  #if LANG_CXX11
  void set_playernick(::std::string&& value);
  #endif
  void set_playernick(const char* value);
  void set_playernick(const char* value, size_t size);
  ::std::string* mutable_playernick();
  ::std::string* release_playernick();
  void set_allocated_playernick(::std::string* playernick);

  // @@protoc_insertion_point(class_scope:OnEnterRoomRsp)
 private:
  void set_has_playernick();
  void clear_has_playernick();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr playernick_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsOnEnterRoomRspImpl();
};
// -------------------------------------------------------------------

class OnEnterLevelRsp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OnEnterLevelRsp) */ {
 public:
  OnEnterLevelRsp();
  virtual ~OnEnterLevelRsp();

  OnEnterLevelRsp(const OnEnterLevelRsp& from);

  inline OnEnterLevelRsp& operator=(const OnEnterLevelRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OnEnterLevelRsp(OnEnterLevelRsp&& from) noexcept
    : OnEnterLevelRsp() {
    *this = ::std::move(from);
  }

  inline OnEnterLevelRsp& operator=(OnEnterLevelRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OnEnterLevelRsp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OnEnterLevelRsp* internal_default_instance() {
    return reinterpret_cast<const OnEnterLevelRsp*>(
               &_OnEnterLevelRsp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(OnEnterLevelRsp* other);
  friend void swap(OnEnterLevelRsp& a, OnEnterLevelRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OnEnterLevelRsp* New() const PROTOBUF_FINAL { return New(NULL); }

  OnEnterLevelRsp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OnEnterLevelRsp& from);
  void MergeFrom(const OnEnterLevelRsp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OnEnterLevelRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Player_ player = 2;
  bool has_player() const;
  void clear_player();
  static const int kPlayerFieldNumber = 2;
  const ::Player_& player() const;
  ::Player_* release_player();
  ::Player_* mutable_player();
  void set_allocated_player(::Player_* player);

  // @@protoc_insertion_point(class_scope:OnEnterLevelRsp)
 private:
  void set_has_player();
  void clear_has_player();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::Player_* player_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsOnEnterLevelRspImpl();
};
// -------------------------------------------------------------------

class Vector2_ : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Vector2_) */ {
 public:
  Vector2_();
  virtual ~Vector2_();

  Vector2_(const Vector2_& from);

  inline Vector2_& operator=(const Vector2_& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Vector2_(Vector2_&& from) noexcept
    : Vector2_() {
    *this = ::std::move(from);
  }

  inline Vector2_& operator=(Vector2_&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector2_& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vector2_* internal_default_instance() {
    return reinterpret_cast<const Vector2_*>(
               &_Vector2__default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(Vector2_* other);
  friend void swap(Vector2_& a, Vector2_& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Vector2_* New() const PROTOBUF_FINAL { return New(NULL); }

  Vector2_* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Vector2_& from);
  void MergeFrom(const Vector2_& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Vector2_* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  ::google::protobuf::int32 x() const;
  void set_x(::google::protobuf::int32 value);

  // required int32 y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  ::google::protobuf::int32 y() const;
  void set_y(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Vector2_)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsVector2_Impl();
};
// -------------------------------------------------------------------

class Vector3_ : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Vector3_) */ {
 public:
  Vector3_();
  virtual ~Vector3_();

  Vector3_(const Vector3_& from);

  inline Vector3_& operator=(const Vector3_& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Vector3_(Vector3_&& from) noexcept
    : Vector3_() {
    *this = ::std::move(from);
  }

  inline Vector3_& operator=(Vector3_&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector3_& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vector3_* internal_default_instance() {
    return reinterpret_cast<const Vector3_*>(
               &_Vector3__default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(Vector3_* other);
  friend void swap(Vector3_& a, Vector3_& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Vector3_* New() const PROTOBUF_FINAL { return New(NULL); }

  Vector3_* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Vector3_& from);
  void MergeFrom(const Vector3_& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Vector3_* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  ::google::protobuf::int32 x() const;
  void set_x(::google::protobuf::int32 value);

  // required int32 y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  ::google::protobuf::int32 y() const;
  void set_y(::google::protobuf::int32 value);

  // required int32 z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  ::google::protobuf::int32 z() const;
  void set_z(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Vector3_)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 z_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsVector3_Impl();
};
// -------------------------------------------------------------------

class Quaternion_ : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Quaternion_) */ {
 public:
  Quaternion_();
  virtual ~Quaternion_();

  Quaternion_(const Quaternion_& from);

  inline Quaternion_& operator=(const Quaternion_& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Quaternion_(Quaternion_&& from) noexcept
    : Quaternion_() {
    *this = ::std::move(from);
  }

  inline Quaternion_& operator=(Quaternion_&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Quaternion_& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Quaternion_* internal_default_instance() {
    return reinterpret_cast<const Quaternion_*>(
               &_Quaternion__default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(Quaternion_* other);
  friend void swap(Quaternion_& a, Quaternion_& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Quaternion_* New() const PROTOBUF_FINAL { return New(NULL); }

  Quaternion_* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Quaternion_& from);
  void MergeFrom(const Quaternion_& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Quaternion_* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  ::google::protobuf::int32 x() const;
  void set_x(::google::protobuf::int32 value);

  // required int32 y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  ::google::protobuf::int32 y() const;
  void set_y(::google::protobuf::int32 value);

  // required int32 z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  ::google::protobuf::int32 z() const;
  void set_z(::google::protobuf::int32 value);

  // required int32 w = 4;
  bool has_w() const;
  void clear_w();
  static const int kWFieldNumber = 4;
  ::google::protobuf::int32 w() const;
  void set_w(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Quaternion_)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();
  void set_has_w();
  void clear_has_w();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 z_;
  ::google::protobuf::int32 w_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsQuaternion_Impl();
};
// -------------------------------------------------------------------

class SceneInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SceneInfo) */ {
 public:
  SceneInfo();
  virtual ~SceneInfo();

  SceneInfo(const SceneInfo& from);

  inline SceneInfo& operator=(const SceneInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SceneInfo(SceneInfo&& from) noexcept
    : SceneInfo() {
    *this = ::std::move(from);
  }

  inline SceneInfo& operator=(SceneInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SceneInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SceneInfo* internal_default_instance() {
    return reinterpret_cast<const SceneInfo*>(
               &_SceneInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(SceneInfo* other);
  friend void swap(SceneInfo& a, SceneInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SceneInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  SceneInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SceneInfo& from);
  void MergeFrom(const SceneInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SceneInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .SceneItem_ items = 1;
  int items_size() const;
  void clear_items();
  static const int kItemsFieldNumber = 1;
  const ::SceneItem_& items(int index) const;
  ::SceneItem_* mutable_items(int index);
  ::SceneItem_* add_items();
  ::google::protobuf::RepeatedPtrField< ::SceneItem_ >*
      mutable_items();
  const ::google::protobuf::RepeatedPtrField< ::SceneItem_ >&
      items() const;

  // repeated .Player_ players = 2;
  int players_size() const;
  void clear_players();
  static const int kPlayersFieldNumber = 2;
  const ::Player_& players(int index) const;
  ::Player_* mutable_players(int index);
  ::Player_* add_players();
  ::google::protobuf::RepeatedPtrField< ::Player_ >*
      mutable_players();
  const ::google::protobuf::RepeatedPtrField< ::Player_ >&
      players() const;

  // @@protoc_insertion_point(class_scope:SceneInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::SceneItem_ > items_;
  ::google::protobuf::RepeatedPtrField< ::Player_ > players_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsSceneInfoImpl();
};
// -------------------------------------------------------------------

class SceneItem_ : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SceneItem_) */ {
 public:
  SceneItem_();
  virtual ~SceneItem_();

  SceneItem_(const SceneItem_& from);

  inline SceneItem_& operator=(const SceneItem_& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SceneItem_(SceneItem_&& from) noexcept
    : SceneItem_() {
    *this = ::std::move(from);
  }

  inline SceneItem_& operator=(SceneItem_&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SceneItem_& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SceneItem_* internal_default_instance() {
    return reinterpret_cast<const SceneItem_*>(
               &_SceneItem__default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(SceneItem_* other);
  friend void swap(SceneItem_& a, SceneItem_& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SceneItem_* New() const PROTOBUF_FINAL { return New(NULL); }

  SceneItem_* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SceneItem_& from);
  void MergeFrom(const SceneItem_& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SceneItem_* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string model = 1;
  bool has_model() const;
  void clear_model();
  static const int kModelFieldNumber = 1;
  const ::std::string& model() const;
  void set_model(const ::std::string& value);
  #if LANG_CXX11
  void set_model(::std::string&& value);
  #endif
  void set_model(const char* value);
  void set_model(const char* value, size_t size);
  ::std::string* mutable_model();
  ::std::string* release_model();
  void set_allocated_model(::std::string* model);

  // required .Vector3_ pos = 2;
  bool has_pos() const;
  void clear_pos();
  static const int kPosFieldNumber = 2;
  const ::Vector3_& pos() const;
  ::Vector3_* release_pos();
  ::Vector3_* mutable_pos();
  void set_allocated_pos(::Vector3_* pos);

  // required .Quaternion_ rotation = 3;
  bool has_rotation() const;
  void clear_rotation();
  static const int kRotationFieldNumber = 3;
  const ::Quaternion_& rotation() const;
  ::Quaternion_* release_rotation();
  ::Quaternion_* mutable_rotation();
  void set_allocated_rotation(::Quaternion_* rotation);

  // required int32 frame = 4;
  bool has_frame() const;
  void clear_frame();
  static const int kFrameFieldNumber = 4;
  ::google::protobuf::int32 frame() const;
  void set_frame(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SceneItem_)
 private:
  void set_has_model();
  void clear_has_model();
  void set_has_pos();
  void clear_has_pos();
  void set_has_rotation();
  void clear_has_rotation();
  void set_has_frame();
  void clear_has_frame();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr model_;
  ::Vector3_* pos_;
  ::Quaternion_* rotation_;
  ::google::protobuf::int32 frame_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsSceneItem_Impl();
};
// -------------------------------------------------------------------

class Player_ : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Player_) */ {
 public:
  Player_();
  virtual ~Player_();

  Player_(const Player_& from);

  inline Player_& operator=(const Player_& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Player_(Player_&& from) noexcept
    : Player_() {
    *this = ::std::move(from);
  }

  inline Player_& operator=(Player_&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Player_& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Player_* internal_default_instance() {
    return reinterpret_cast<const Player_*>(
               &_Player__default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(Player_* other);
  friend void swap(Player_& a, Player_& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Player_* New() const PROTOBUF_FINAL { return New(NULL); }

  Player_* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Player_& from);
  void MergeFrom(const Player_& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Player_* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required .Vector3_ pos = 7;
  bool has_pos() const;
  void clear_pos();
  static const int kPosFieldNumber = 7;
  const ::Vector3_& pos() const;
  ::Vector3_* release_pos();
  ::Vector3_* mutable_pos();
  void set_allocated_pos(::Vector3_* pos);

  // required .Quaternion_ rotation = 8;
  bool has_rotation() const;
  void clear_rotation();
  static const int kRotationFieldNumber = 8;
  const ::Quaternion_& rotation() const;
  ::Quaternion_* release_rotation();
  ::Quaternion_* mutable_rotation();
  void set_allocated_rotation(::Quaternion_* rotation);

  // required uint32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // required uint32 weapon1 = 3;
  bool has_weapon1() const;
  void clear_weapon1();
  static const int kWeapon1FieldNumber = 3;
  ::google::protobuf::uint32 weapon1() const;
  void set_weapon1(::google::protobuf::uint32 value);

  // required uint32 weapon2 = 4;
  bool has_weapon2() const;
  void clear_weapon2();
  static const int kWeapon2FieldNumber = 4;
  ::google::protobuf::uint32 weapon2() const;
  void set_weapon2(::google::protobuf::uint32 value);

  // required uint32 weapon = 5;
  bool has_weapon() const;
  void clear_weapon();
  static const int kWeaponFieldNumber = 5;
  ::google::protobuf::uint32 weapon() const;
  void set_weapon(::google::protobuf::uint32 value);

  // required uint32 weapon_pos = 6;
  bool has_weapon_pos() const;
  void clear_weapon_pos();
  static const int kWeaponPosFieldNumber = 6;
  ::google::protobuf::uint32 weapon_pos() const;
  void set_weapon_pos(::google::protobuf::uint32 value);

  // required int32 model = 9;
  bool has_model() const;
  void clear_model();
  static const int kModelFieldNumber = 9;
  ::google::protobuf::int32 model() const;
  void set_model(::google::protobuf::int32 value);

  // required int32 aniSource = 10;
  bool has_anisource() const;
  void clear_anisource();
  static const int kAniSourceFieldNumber = 10;
  ::google::protobuf::int32 anisource() const;
  void set_anisource(::google::protobuf::int32 value);

  // required int32 frame = 11;
  bool has_frame() const;
  void clear_frame();
  static const int kFrameFieldNumber = 11;
  ::google::protobuf::int32 frame() const;
  void set_frame(::google::protobuf::int32 value);

  // required int32 hpMax = 12;
  bool has_hpmax() const;
  void clear_hpmax();
  static const int kHpMaxFieldNumber = 12;
  ::google::protobuf::int32 hpmax() const;
  void set_hpmax(::google::protobuf::int32 value);

  // required int32 hp = 13;
  bool has_hp() const;
  void clear_hp();
  static const int kHpFieldNumber = 13;
  ::google::protobuf::int32 hp() const;
  void set_hp(::google::protobuf::int32 value);

  // required int32 angry = 14;
  bool has_angry() const;
  void clear_angry();
  static const int kAngryFieldNumber = 14;
  ::google::protobuf::int32 angry() const;
  void set_angry(::google::protobuf::int32 value);

  // required int32 Camp = 15;
  bool has_camp() const;
  void clear_camp();
  static const int kCampFieldNumber = 15;
  ::google::protobuf::int32 camp() const;
  void set_camp(::google::protobuf::int32 value);

  // required int32 SpawnPoint = 16;
  bool has_spawnpoint() const;
  void clear_spawnpoint();
  static const int kSpawnPointFieldNumber = 16;
  ::google::protobuf::int32 spawnpoint() const;
  void set_spawnpoint(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Player_)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_name();
  void clear_has_name();
  void set_has_weapon1();
  void clear_has_weapon1();
  void set_has_weapon2();
  void clear_has_weapon2();
  void set_has_weapon();
  void clear_has_weapon();
  void set_has_weapon_pos();
  void clear_has_weapon_pos();
  void set_has_pos();
  void clear_has_pos();
  void set_has_rotation();
  void clear_has_rotation();
  void set_has_model();
  void clear_has_model();
  void set_has_anisource();
  void clear_has_anisource();
  void set_has_frame();
  void clear_has_frame();
  void set_has_hpmax();
  void clear_has_hpmax();
  void set_has_hp();
  void clear_has_hp();
  void set_has_angry();
  void clear_has_angry();
  void set_has_camp();
  void clear_has_camp();
  void set_has_spawnpoint();
  void clear_has_spawnpoint();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::Vector3_* pos_;
  ::Quaternion_* rotation_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 weapon1_;
  ::google::protobuf::uint32 weapon2_;
  ::google::protobuf::uint32 weapon_;
  ::google::protobuf::uint32 weapon_pos_;
  ::google::protobuf::int32 model_;
  ::google::protobuf::int32 anisource_;
  ::google::protobuf::int32 frame_;
  ::google::protobuf::int32 hpmax_;
  ::google::protobuf::int32 hp_;
  ::google::protobuf::int32 angry_;
  ::google::protobuf::int32 camp_;
  ::google::protobuf::int32 spawnpoint_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsPlayer_Impl();
};
// -------------------------------------------------------------------

class InputReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:InputReq) */ {
 public:
  InputReq();
  virtual ~InputReq();

  InputReq(const InputReq& from);

  inline InputReq& operator=(const InputReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InputReq(InputReq&& from) noexcept
    : InputReq() {
    *this = ::std::move(from);
  }

  inline InputReq& operator=(InputReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InputReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InputReq* internal_default_instance() {
    return reinterpret_cast<const InputReq*>(
               &_InputReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(InputReq* other);
  friend void swap(InputReq& a, InputReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InputReq* New() const PROTOBUF_FINAL { return New(NULL); }

  InputReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const InputReq& from);
  void MergeFrom(const InputReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(InputReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Input_ input = 1;
  int input_size() const;
  void clear_input();
  static const int kInputFieldNumber = 1;
  const ::Input_& input(int index) const;
  ::Input_* mutable_input(int index);
  ::Input_* add_input();
  ::google::protobuf::RepeatedPtrField< ::Input_ >*
      mutable_input();
  const ::google::protobuf::RepeatedPtrField< ::Input_ >&
      input() const;

  // @@protoc_insertion_point(class_scope:InputReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Input_ > input_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsInputReqImpl();
};
// -------------------------------------------------------------------

class Input_ : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Input_) */ {
 public:
  Input_();
  virtual ~Input_();

  Input_(const Input_& from);

  inline Input_& operator=(const Input_& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Input_(Input_&& from) noexcept
    : Input_() {
    *this = ::std::move(from);
  }

  inline Input_& operator=(Input_&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Input_& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Input_* internal_default_instance() {
    return reinterpret_cast<const Input_*>(
               &_Input__default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(Input_* other);
  friend void swap(Input_& a, Input_& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Input_* New() const PROTOBUF_FINAL { return New(NULL); }

  Input_* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Input_& from);
  void MergeFrom(const Input_& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Input_* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes w = 4;
  bool has_w() const;
  void clear_w();
  static const int kWFieldNumber = 4;
  const ::std::string& w() const;
  void set_w(const ::std::string& value);
  #if LANG_CXX11
  void set_w(::std::string&& value);
  #endif
  void set_w(const char* value);
  void set_w(const void* value, size_t size);
  ::std::string* mutable_w();
  ::std::string* release_w();
  void set_allocated_w(::std::string* w);

  // required bytes s = 5;
  bool has_s() const;
  void clear_s();
  static const int kSFieldNumber = 5;
  const ::std::string& s() const;
  void set_s(const ::std::string& value);
  #if LANG_CXX11
  void set_s(::std::string&& value);
  #endif
  void set_s(const char* value);
  void set_s(const void* value, size_t size);
  ::std::string* mutable_s();
  ::std::string* release_s();
  void set_allocated_s(::std::string* s);

  // required bytes a = 6;
  bool has_a() const;
  void clear_a();
  static const int kAFieldNumber = 6;
  const ::std::string& a() const;
  void set_a(const ::std::string& value);
  #if LANG_CXX11
  void set_a(::std::string&& value);
  #endif
  void set_a(const char* value);
  void set_a(const void* value, size_t size);
  ::std::string* mutable_a();
  ::std::string* release_a();
  void set_allocated_a(::std::string* a);

  // required bytes d = 7;
  bool has_d() const;
  void clear_d();
  static const int kDFieldNumber = 7;
  const ::std::string& d() const;
  void set_d(const ::std::string& value);
  #if LANG_CXX11
  void set_d(::std::string&& value);
  #endif
  void set_d(const char* value);
  void set_d(const void* value, size_t size);
  ::std::string* mutable_d();
  ::std::string* release_d();
  void set_allocated_d(::std::string* d);

  // required bytes jump = 8;
  bool has_jump() const;
  void clear_jump();
  static const int kJumpFieldNumber = 8;
  const ::std::string& jump() const;
  void set_jump(const ::std::string& value);
  #if LANG_CXX11
  void set_jump(::std::string&& value);
  #endif
  void set_jump(const char* value);
  void set_jump(const void* value, size_t size);
  ::std::string* mutable_jump();
  ::std::string* release_jump();
  void set_allocated_jump(::std::string* jump);

  // required bytes break = 9;
  bool has_break_() const;
  void clear_break_();
  static const int kBreakFieldNumber = 9;
  const ::std::string& break_() const;
  void set_break_(const ::std::string& value);
  #if LANG_CXX11
  void set_break_(::std::string&& value);
  #endif
  void set_break_(const char* value);
  void set_break_(const void* value, size_t size);
  ::std::string* mutable_break_();
  ::std::string* release_break_();
  void set_allocated_break_(::std::string* break_);

  // required bytes attack = 10;
  bool has_attack() const;
  void clear_attack();
  static const int kAttackFieldNumber = 10;
  const ::std::string& attack() const;
  void set_attack(const ::std::string& value);
  #if LANG_CXX11
  void set_attack(::std::string&& value);
  #endif
  void set_attack(const char* value);
  void set_attack(const void* value, size_t size);
  ::std::string* mutable_attack();
  ::std::string* release_attack();
  void set_allocated_attack(::std::string* attack);

  // required bytes e = 11;
  bool has_e() const;
  void clear_e();
  static const int kEFieldNumber = 11;
  const ::std::string& e() const;
  void set_e(const ::std::string& value);
  #if LANG_CXX11
  void set_e(::std::string&& value);
  #endif
  void set_e(const char* value);
  void set_e(const void* value, size_t size);
  ::std::string* mutable_e();
  ::std::string* release_e();
  void set_allocated_e(::std::string* e);

  // required bytes r = 12;
  bool has_r() const;
  void clear_r();
  static const int kRFieldNumber = 12;
  const ::std::string& r() const;
  void set_r(const ::std::string& value);
  #if LANG_CXX11
  void set_r(::std::string&& value);
  #endif
  void set_r(const char* value);
  void set_r(const void* value, size_t size);
  ::std::string* mutable_r();
  ::std::string* release_r();
  void set_allocated_r(::std::string* r);

  // required bytes y = 13;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 13;
  const ::std::string& y() const;
  void set_y(const ::std::string& value);
  #if LANG_CXX11
  void set_y(::std::string&& value);
  #endif
  void set_y(const char* value);
  void set_y(const void* value, size_t size);
  ::std::string* mutable_y();
  ::std::string* release_y();
  void set_allocated_y(::std::string* y);

  // required bytes space = 14;
  bool has_space() const;
  void clear_space();
  static const int kSpaceFieldNumber = 14;
  const ::std::string& space() const;
  void set_space(const ::std::string& value);
  #if LANG_CXX11
  void set_space(::std::string&& value);
  #endif
  void set_space(const char* value);
  void set_space(const void* value, size_t size);
  ::std::string* mutable_space();
  ::std::string* release_space();
  void set_allocated_space(::std::string* space);

  // required bytes c = 15;
  bool has_c() const;
  void clear_c();
  static const int kCFieldNumber = 15;
  const ::std::string& c() const;
  void set_c(const ::std::string& value);
  #if LANG_CXX11
  void set_c(::std::string&& value);
  #endif
  void set_c(const char* value);
  void set_c(const void* value, size_t size);
  ::std::string* mutable_c();
  ::std::string* release_c();
  void set_allocated_c(::std::string* c);

  // required .Vector2_ JoyStick = 2;
  bool has_joystick() const;
  void clear_joystick();
  static const int kJoyStickFieldNumber = 2;
  const ::Vector2_& joystick() const;
  ::Vector2_* release_joystick();
  ::Vector2_* mutable_joystick();
  void set_allocated_joystick(::Vector2_* joystick);

  // required .Vector2_ MouseDelta = 3;
  bool has_mousedelta() const;
  void clear_mousedelta();
  static const int kMouseDeltaFieldNumber = 3;
  const ::Vector2_& mousedelta() const;
  ::Vector2_* release_mousedelta();
  ::Vector2_* mutable_mousedelta();
  void set_allocated_mousedelta(::Vector2_* mousedelta);

  // required uint32 playerId = 1;
  bool has_playerid() const;
  void clear_playerid();
  static const int kPlayerIdFieldNumber = 1;
  ::google::protobuf::uint32 playerid() const;
  void set_playerid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Input_)
 private:
  void set_has_playerid();
  void clear_has_playerid();
  void set_has_joystick();
  void clear_has_joystick();
  void set_has_mousedelta();
  void clear_has_mousedelta();
  void set_has_w();
  void clear_has_w();
  void set_has_s();
  void clear_has_s();
  void set_has_a();
  void clear_has_a();
  void set_has_d();
  void clear_has_d();
  void set_has_jump();
  void clear_has_jump();
  void set_has_break_();
  void clear_has_break_();
  void set_has_attack();
  void clear_has_attack();
  void set_has_e();
  void clear_has_e();
  void set_has_r();
  void clear_has_r();
  void set_has_y();
  void clear_has_y();
  void set_has_space();
  void clear_has_space();
  void set_has_c();
  void clear_has_c();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr w_;
  ::google::protobuf::internal::ArenaStringPtr s_;
  ::google::protobuf::internal::ArenaStringPtr a_;
  ::google::protobuf::internal::ArenaStringPtr d_;
  ::google::protobuf::internal::ArenaStringPtr jump_;
  ::google::protobuf::internal::ArenaStringPtr break__;
  ::google::protobuf::internal::ArenaStringPtr attack_;
  ::google::protobuf::internal::ArenaStringPtr e_;
  ::google::protobuf::internal::ArenaStringPtr r_;
  ::google::protobuf::internal::ArenaStringPtr y_;
  ::google::protobuf::internal::ArenaStringPtr space_;
  ::google::protobuf::internal::ArenaStringPtr c_;
  ::Vector2_* joystick_;
  ::Vector2_* mousedelta_;
  ::google::protobuf::uint32 playerid_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsInput_Impl();
};
// -------------------------------------------------------------------

class KeyFrame : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:KeyFrame) */ {
 public:
  KeyFrame();
  virtual ~KeyFrame();

  KeyFrame(const KeyFrame& from);

  inline KeyFrame& operator=(const KeyFrame& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KeyFrame(KeyFrame&& from) noexcept
    : KeyFrame() {
    *this = ::std::move(from);
  }

  inline KeyFrame& operator=(KeyFrame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyFrame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KeyFrame* internal_default_instance() {
    return reinterpret_cast<const KeyFrame*>(
               &_KeyFrame_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(KeyFrame* other);
  friend void swap(KeyFrame& a, KeyFrame& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KeyFrame* New() const PROTOBUF_FINAL { return New(NULL); }

  KeyFrame* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KeyFrame& from);
  void MergeFrom(const KeyFrame& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KeyFrame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Input_ Inputs = 2;
  int inputs_size() const;
  void clear_inputs();
  static const int kInputsFieldNumber = 2;
  const ::Input_& inputs(int index) const;
  ::Input_* mutable_inputs(int index);
  ::Input_* add_inputs();
  ::google::protobuf::RepeatedPtrField< ::Input_ >*
      mutable_inputs();
  const ::google::protobuf::RepeatedPtrField< ::Input_ >&
      inputs() const;

  // repeated .Player_ Players = 3;
  int players_size() const;
  void clear_players();
  static const int kPlayersFieldNumber = 3;
  const ::Player_& players(int index) const;
  ::Player_* mutable_players(int index);
  ::Player_* add_players();
  ::google::protobuf::RepeatedPtrField< ::Player_ >*
      mutable_players();
  const ::google::protobuf::RepeatedPtrField< ::Player_ >&
      players() const;

  // required uint32 frameIndex = 1;
  bool has_frameindex() const;
  void clear_frameindex();
  static const int kFrameIndexFieldNumber = 1;
  ::google::protobuf::uint32 frameindex() const;
  void set_frameindex(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:KeyFrame)
 private:
  void set_has_frameindex();
  void clear_has_frameindex();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Input_ > inputs_;
  ::google::protobuf::RepeatedPtrField< ::Player_ > players_;
  ::google::protobuf::uint32 frameindex_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsKeyFrameImpl();
};
// -------------------------------------------------------------------

class UserId : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:UserId) */ {
 public:
  UserId();
  virtual ~UserId();

  UserId(const UserId& from);

  inline UserId& operator=(const UserId& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserId(UserId&& from) noexcept
    : UserId() {
    *this = ::std::move(from);
  }

  inline UserId& operator=(UserId&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserId& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserId* internal_default_instance() {
    return reinterpret_cast<const UserId*>(
               &_UserId_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(UserId* other);
  friend void swap(UserId& a, UserId& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserId* New() const PROTOBUF_FINAL { return New(NULL); }

  UserId* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UserId& from);
  void MergeFrom(const UserId& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UserId* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 Player = 1;
  int player_size() const;
  void clear_player();
  static const int kPlayerFieldNumber = 1;
  ::google::protobuf::uint32 player(int index) const;
  void set_player(int index, ::google::protobuf::uint32 value);
  void add_player(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      player() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_player();

  // @@protoc_insertion_point(class_scope:UserId)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > player_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsUserIdImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MeteorMsg

// required .MeteorMsg.MsgType cmd = 1;
inline bool MeteorMsg::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MeteorMsg::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MeteorMsg::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MeteorMsg::clear_cmd() {
  cmd_ = 100;
  clear_has_cmd();
}
inline ::MeteorMsg_MsgType MeteorMsg::cmd() const {
  // @@protoc_insertion_point(field_get:MeteorMsg.cmd)
  return static_cast< ::MeteorMsg_MsgType >(cmd_);
}
inline void MeteorMsg::set_cmd(::MeteorMsg_MsgType value) {
  assert(::MeteorMsg_MsgType_IsValid(value));
  set_has_cmd();
  cmd_ = value;
  // @@protoc_insertion_point(field_set:MeteorMsg.cmd)
}

// -------------------------------------------------------------------

// RoomInfo

// required uint32 roomId = 1;
inline bool RoomInfo::has_roomid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoomInfo::set_has_roomid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoomInfo::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoomInfo::clear_roomid() {
  roomid_ = 0u;
  clear_has_roomid();
}
inline ::google::protobuf::uint32 RoomInfo::roomid() const {
  // @@protoc_insertion_point(field_get:RoomInfo.roomId)
  return roomid_;
}
inline void RoomInfo::set_roomid(::google::protobuf::uint32 value) {
  set_has_roomid();
  roomid_ = value;
  // @@protoc_insertion_point(field_set:RoomInfo.roomId)
}

// required string roomName = 2;
inline bool RoomInfo::has_roomname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomInfo::set_has_roomname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomInfo::clear_has_roomname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomInfo::clear_roomname() {
  roomname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_roomname();
}
inline const ::std::string& RoomInfo::roomname() const {
  // @@protoc_insertion_point(field_get:RoomInfo.roomName)
  return roomname_.GetNoArena();
}
inline void RoomInfo::set_roomname(const ::std::string& value) {
  set_has_roomname();
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RoomInfo.roomName)
}
#if LANG_CXX11
inline void RoomInfo::set_roomname(::std::string&& value) {
  set_has_roomname();
  roomname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:RoomInfo.roomName)
}
#endif
inline void RoomInfo::set_roomname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_roomname();
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RoomInfo.roomName)
}
inline void RoomInfo::set_roomname(const char* value, size_t size) {
  set_has_roomname();
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RoomInfo.roomName)
}
inline ::std::string* RoomInfo::mutable_roomname() {
  set_has_roomname();
  // @@protoc_insertion_point(field_mutable:RoomInfo.roomName)
  return roomname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RoomInfo::release_roomname() {
  // @@protoc_insertion_point(field_release:RoomInfo.roomName)
  clear_has_roomname();
  return roomname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoomInfo::set_allocated_roomname(::std::string* roomname) {
  if (roomname != NULL) {
    set_has_roomname();
  } else {
    clear_has_roomname();
  }
  roomname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), roomname);
  // @@protoc_insertion_point(field_set_allocated:RoomInfo.roomName)
}

// required .RoomInfo.RoomRule rule = 3;
inline bool RoomInfo::has_rule() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RoomInfo::set_has_rule() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RoomInfo::clear_has_rule() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RoomInfo::clear_rule() {
  rule_ = 1;
  clear_has_rule();
}
inline ::RoomInfo_RoomRule RoomInfo::rule() const {
  // @@protoc_insertion_point(field_get:RoomInfo.rule)
  return static_cast< ::RoomInfo_RoomRule >(rule_);
}
inline void RoomInfo::set_rule(::RoomInfo_RoomRule value) {
  assert(::RoomInfo_RoomRule_IsValid(value));
  set_has_rule();
  rule_ = value;
  // @@protoc_insertion_point(field_set:RoomInfo.rule)
}

// required uint32 levelIdx = 4;
inline bool RoomInfo::has_levelidx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoomInfo::set_has_levelidx() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoomInfo::clear_has_levelidx() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoomInfo::clear_levelidx() {
  levelidx_ = 0u;
  clear_has_levelidx();
}
inline ::google::protobuf::uint32 RoomInfo::levelidx() const {
  // @@protoc_insertion_point(field_get:RoomInfo.levelIdx)
  return levelidx_;
}
inline void RoomInfo::set_levelidx(::google::protobuf::uint32 value) {
  set_has_levelidx();
  levelidx_ = value;
  // @@protoc_insertion_point(field_set:RoomInfo.levelIdx)
}

// required uint32 Group1 = 5;
inline bool RoomInfo::has_group1() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RoomInfo::set_has_group1() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RoomInfo::clear_has_group1() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RoomInfo::clear_group1() {
  group1_ = 0u;
  clear_has_group1();
}
inline ::google::protobuf::uint32 RoomInfo::group1() const {
  // @@protoc_insertion_point(field_get:RoomInfo.Group1)
  return group1_;
}
inline void RoomInfo::set_group1(::google::protobuf::uint32 value) {
  set_has_group1();
  group1_ = value;
  // @@protoc_insertion_point(field_set:RoomInfo.Group1)
}

// required uint32 Group2 = 6;
inline bool RoomInfo::has_group2() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RoomInfo::set_has_group2() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RoomInfo::clear_has_group2() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RoomInfo::clear_group2() {
  group2_ = 0u;
  clear_has_group2();
}
inline ::google::protobuf::uint32 RoomInfo::group2() const {
  // @@protoc_insertion_point(field_get:RoomInfo.Group2)
  return group2_;
}
inline void RoomInfo::set_group2(::google::protobuf::uint32 value) {
  set_has_group2();
  group2_ = value;
  // @@protoc_insertion_point(field_set:RoomInfo.Group2)
}

// required uint32 playerCount = 7;
inline bool RoomInfo::has_playercount() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RoomInfo::set_has_playercount() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RoomInfo::clear_has_playercount() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RoomInfo::clear_playercount() {
  playercount_ = 0u;
  clear_has_playercount();
}
inline ::google::protobuf::uint32 RoomInfo::playercount() const {
  // @@protoc_insertion_point(field_get:RoomInfo.playerCount)
  return playercount_;
}
inline void RoomInfo::set_playercount(::google::protobuf::uint32 value) {
  set_has_playercount();
  playercount_ = value;
  // @@protoc_insertion_point(field_set:RoomInfo.playerCount)
}

// required uint32 maxPlayer = 8;
inline bool RoomInfo::has_maxplayer() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RoomInfo::set_has_maxplayer() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RoomInfo::clear_has_maxplayer() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RoomInfo::clear_maxplayer() {
  maxplayer_ = 0u;
  clear_has_maxplayer();
}
inline ::google::protobuf::uint32 RoomInfo::maxplayer() const {
  // @@protoc_insertion_point(field_get:RoomInfo.maxPlayer)
  return maxplayer_;
}
inline void RoomInfo::set_maxplayer(::google::protobuf::uint32 value) {
  set_has_maxplayer();
  maxplayer_ = value;
  // @@protoc_insertion_point(field_set:RoomInfo.maxPlayer)
}

// -------------------------------------------------------------------

// OnLeaveRoomRsp

// required uint32 playerId = 2;
inline bool OnLeaveRoomRsp::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OnLeaveRoomRsp::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OnLeaveRoomRsp::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OnLeaveRoomRsp::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 OnLeaveRoomRsp::playerid() const {
  // @@protoc_insertion_point(field_get:OnLeaveRoomRsp.playerId)
  return playerid_;
}
inline void OnLeaveRoomRsp::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
  // @@protoc_insertion_point(field_set:OnLeaveRoomRsp.playerId)
}

// -------------------------------------------------------------------

// GetRoomRsp

// repeated .RoomInfo RoomInLobby = 2;
inline int GetRoomRsp::roominlobby_size() const {
  return roominlobby_.size();
}
inline void GetRoomRsp::clear_roominlobby() {
  roominlobby_.Clear();
}
inline const ::RoomInfo& GetRoomRsp::roominlobby(int index) const {
  // @@protoc_insertion_point(field_get:GetRoomRsp.RoomInLobby)
  return roominlobby_.Get(index);
}
inline ::RoomInfo* GetRoomRsp::mutable_roominlobby(int index) {
  // @@protoc_insertion_point(field_mutable:GetRoomRsp.RoomInLobby)
  return roominlobby_.Mutable(index);
}
inline ::RoomInfo* GetRoomRsp::add_roominlobby() {
  // @@protoc_insertion_point(field_add:GetRoomRsp.RoomInLobby)
  return roominlobby_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::RoomInfo >*
GetRoomRsp::mutable_roominlobby() {
  // @@protoc_insertion_point(field_mutable_list:GetRoomRsp.RoomInLobby)
  return &roominlobby_;
}
inline const ::google::protobuf::RepeatedPtrField< ::RoomInfo >&
GetRoomRsp::roominlobby() const {
  // @@protoc_insertion_point(field_list:GetRoomRsp.RoomInLobby)
  return roominlobby_;
}

// -------------------------------------------------------------------

// CreateRoomReq

// required uint32 maxPlayer = 2;
inline bool CreateRoomReq::has_maxplayer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateRoomReq::set_has_maxplayer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateRoomReq::clear_has_maxplayer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateRoomReq::clear_maxplayer() {
  maxplayer_ = 0u;
  clear_has_maxplayer();
}
inline ::google::protobuf::uint32 CreateRoomReq::maxplayer() const {
  // @@protoc_insertion_point(field_get:CreateRoomReq.maxPlayer)
  return maxplayer_;
}
inline void CreateRoomReq::set_maxplayer(::google::protobuf::uint32 value) {
  set_has_maxplayer();
  maxplayer_ = value;
  // @@protoc_insertion_point(field_set:CreateRoomReq.maxPlayer)
}

// required uint32 levelIdx = 3;
inline bool CreateRoomReq::has_levelidx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreateRoomReq::set_has_levelidx() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreateRoomReq::clear_has_levelidx() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreateRoomReq::clear_levelidx() {
  levelidx_ = 0u;
  clear_has_levelidx();
}
inline ::google::protobuf::uint32 CreateRoomReq::levelidx() const {
  // @@protoc_insertion_point(field_get:CreateRoomReq.levelIdx)
  return levelidx_;
}
inline void CreateRoomReq::set_levelidx(::google::protobuf::uint32 value) {
  set_has_levelidx();
  levelidx_ = value;
  // @@protoc_insertion_point(field_set:CreateRoomReq.levelIdx)
}

// required uint32 rule = 4;
inline bool CreateRoomReq::has_rule() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CreateRoomReq::set_has_rule() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CreateRoomReq::clear_has_rule() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CreateRoomReq::clear_rule() {
  rule_ = 0u;
  clear_has_rule();
}
inline ::google::protobuf::uint32 CreateRoomReq::rule() const {
  // @@protoc_insertion_point(field_get:CreateRoomReq.rule)
  return rule_;
}
inline void CreateRoomReq::set_rule(::google::protobuf::uint32 value) {
  set_has_rule();
  rule_ = value;
  // @@protoc_insertion_point(field_set:CreateRoomReq.rule)
}

// required string roomName = 5;
inline bool CreateRoomReq::has_roomname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateRoomReq::set_has_roomname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateRoomReq::clear_has_roomname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateRoomReq::clear_roomname() {
  roomname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_roomname();
}
inline const ::std::string& CreateRoomReq::roomname() const {
  // @@protoc_insertion_point(field_get:CreateRoomReq.roomName)
  return roomname_.GetNoArena();
}
inline void CreateRoomReq::set_roomname(const ::std::string& value) {
  set_has_roomname();
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CreateRoomReq.roomName)
}
#if LANG_CXX11
inline void CreateRoomReq::set_roomname(::std::string&& value) {
  set_has_roomname();
  roomname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CreateRoomReq.roomName)
}
#endif
inline void CreateRoomReq::set_roomname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_roomname();
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CreateRoomReq.roomName)
}
inline void CreateRoomReq::set_roomname(const char* value, size_t size) {
  set_has_roomname();
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CreateRoomReq.roomName)
}
inline ::std::string* CreateRoomReq::mutable_roomname() {
  set_has_roomname();
  // @@protoc_insertion_point(field_mutable:CreateRoomReq.roomName)
  return roomname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateRoomReq::release_roomname() {
  // @@protoc_insertion_point(field_release:CreateRoomReq.roomName)
  clear_has_roomname();
  return roomname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateRoomReq::set_allocated_roomname(::std::string* roomname) {
  if (roomname != NULL) {
    set_has_roomname();
  } else {
    clear_has_roomname();
  }
  roomname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), roomname);
  // @@protoc_insertion_point(field_set_allocated:CreateRoomReq.roomName)
}

// required uint32 hpMax = 6;
inline bool CreateRoomReq::has_hpmax() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CreateRoomReq::set_has_hpmax() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CreateRoomReq::clear_has_hpmax() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CreateRoomReq::clear_hpmax() {
  hpmax_ = 0u;
  clear_has_hpmax();
}
inline ::google::protobuf::uint32 CreateRoomReq::hpmax() const {
  // @@protoc_insertion_point(field_get:CreateRoomReq.hpMax)
  return hpmax_;
}
inline void CreateRoomReq::set_hpmax(::google::protobuf::uint32 value) {
  set_has_hpmax();
  hpmax_ = value;
  // @@protoc_insertion_point(field_set:CreateRoomReq.hpMax)
}

// -------------------------------------------------------------------

// CreateRoomRsp

// required uint32 result = 2;
inline bool CreateRoomRsp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateRoomRsp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateRoomRsp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateRoomRsp::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 CreateRoomRsp::result() const {
  // @@protoc_insertion_point(field_get:CreateRoomRsp.result)
  return result_;
}
inline void CreateRoomRsp::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:CreateRoomRsp.result)
}

// required uint32 roomId = 3;
inline bool CreateRoomRsp::has_roomid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateRoomRsp::set_has_roomid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateRoomRsp::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateRoomRsp::clear_roomid() {
  roomid_ = 0u;
  clear_has_roomid();
}
inline ::google::protobuf::uint32 CreateRoomRsp::roomid() const {
  // @@protoc_insertion_point(field_get:CreateRoomRsp.roomId)
  return roomid_;
}
inline void CreateRoomRsp::set_roomid(::google::protobuf::uint32 value) {
  set_has_roomid();
  roomid_ = value;
  // @@protoc_insertion_point(field_set:CreateRoomRsp.roomId)
}

// required uint32 levelId = 4;
inline bool CreateRoomRsp::has_levelid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreateRoomRsp::set_has_levelid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreateRoomRsp::clear_has_levelid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreateRoomRsp::clear_levelid() {
  levelid_ = 0u;
  clear_has_levelid();
}
inline ::google::protobuf::uint32 CreateRoomRsp::levelid() const {
  // @@protoc_insertion_point(field_get:CreateRoomRsp.levelId)
  return levelid_;
}
inline void CreateRoomRsp::set_levelid(::google::protobuf::uint32 value) {
  set_has_levelid();
  levelid_ = value;
  // @@protoc_insertion_point(field_set:CreateRoomRsp.levelId)
}

// -------------------------------------------------------------------

// JoinRoomReq

// required uint32 roomId = 2;
inline bool JoinRoomReq::has_roomid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JoinRoomReq::set_has_roomid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JoinRoomReq::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JoinRoomReq::clear_roomid() {
  roomid_ = 0u;
  clear_has_roomid();
}
inline ::google::protobuf::uint32 JoinRoomReq::roomid() const {
  // @@protoc_insertion_point(field_get:JoinRoomReq.roomId)
  return roomid_;
}
inline void JoinRoomReq::set_roomid(::google::protobuf::uint32 value) {
  set_has_roomid();
  roomid_ = value;
  // @@protoc_insertion_point(field_set:JoinRoomReq.roomId)
}

// required string userNick = 3;
inline bool JoinRoomReq::has_usernick() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JoinRoomReq::set_has_usernick() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JoinRoomReq::clear_has_usernick() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JoinRoomReq::clear_usernick() {
  usernick_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_usernick();
}
inline const ::std::string& JoinRoomReq::usernick() const {
  // @@protoc_insertion_point(field_get:JoinRoomReq.userNick)
  return usernick_.GetNoArena();
}
inline void JoinRoomReq::set_usernick(const ::std::string& value) {
  set_has_usernick();
  usernick_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:JoinRoomReq.userNick)
}
#if LANG_CXX11
inline void JoinRoomReq::set_usernick(::std::string&& value) {
  set_has_usernick();
  usernick_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:JoinRoomReq.userNick)
}
#endif
inline void JoinRoomReq::set_usernick(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_usernick();
  usernick_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:JoinRoomReq.userNick)
}
inline void JoinRoomReq::set_usernick(const char* value, size_t size) {
  set_has_usernick();
  usernick_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:JoinRoomReq.userNick)
}
inline ::std::string* JoinRoomReq::mutable_usernick() {
  set_has_usernick();
  // @@protoc_insertion_point(field_mutable:JoinRoomReq.userNick)
  return usernick_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JoinRoomReq::release_usernick() {
  // @@protoc_insertion_point(field_release:JoinRoomReq.userNick)
  clear_has_usernick();
  return usernick_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JoinRoomReq::set_allocated_usernick(::std::string* usernick) {
  if (usernick != NULL) {
    set_has_usernick();
  } else {
    clear_has_usernick();
  }
  usernick_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), usernick);
  // @@protoc_insertion_point(field_set_allocated:JoinRoomReq.userNick)
}

// -------------------------------------------------------------------

// JoinRoomRsp

// required uint32 result = 2;
inline bool JoinRoomRsp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JoinRoomRsp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JoinRoomRsp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JoinRoomRsp::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 JoinRoomRsp::result() const {
  // @@protoc_insertion_point(field_get:JoinRoomRsp.result)
  return result_;
}
inline void JoinRoomRsp::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:JoinRoomRsp.result)
}

// required uint32 reason = 3;
inline bool JoinRoomRsp::has_reason() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JoinRoomRsp::set_has_reason() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JoinRoomRsp::clear_has_reason() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JoinRoomRsp::clear_reason() {
  reason_ = 0u;
  clear_has_reason();
}
inline ::google::protobuf::uint32 JoinRoomRsp::reason() const {
  // @@protoc_insertion_point(field_get:JoinRoomRsp.reason)
  return reason_;
}
inline void JoinRoomRsp::set_reason(::google::protobuf::uint32 value) {
  set_has_reason();
  reason_ = value;
  // @@protoc_insertion_point(field_set:JoinRoomRsp.reason)
}

// required uint32 levelIdx = 4;
inline bool JoinRoomRsp::has_levelidx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void JoinRoomRsp::set_has_levelidx() {
  _has_bits_[0] |= 0x00000004u;
}
inline void JoinRoomRsp::clear_has_levelidx() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void JoinRoomRsp::clear_levelidx() {
  levelidx_ = 0u;
  clear_has_levelidx();
}
inline ::google::protobuf::uint32 JoinRoomRsp::levelidx() const {
  // @@protoc_insertion_point(field_get:JoinRoomRsp.levelIdx)
  return levelidx_;
}
inline void JoinRoomRsp::set_levelidx(::google::protobuf::uint32 value) {
  set_has_levelidx();
  levelidx_ = value;
  // @@protoc_insertion_point(field_set:JoinRoomRsp.levelIdx)
}

// required uint32 roomId = 5;
inline bool JoinRoomRsp::has_roomid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void JoinRoomRsp::set_has_roomid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void JoinRoomRsp::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void JoinRoomRsp::clear_roomid() {
  roomid_ = 0u;
  clear_has_roomid();
}
inline ::google::protobuf::uint32 JoinRoomRsp::roomid() const {
  // @@protoc_insertion_point(field_get:JoinRoomRsp.roomId)
  return roomid_;
}
inline void JoinRoomRsp::set_roomid(::google::protobuf::uint32 value) {
  set_has_roomid();
  roomid_ = value;
  // @@protoc_insertion_point(field_set:JoinRoomRsp.roomId)
}

// required uint32 playerId = 6;
inline bool JoinRoomRsp::has_playerid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void JoinRoomRsp::set_has_playerid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void JoinRoomRsp::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void JoinRoomRsp::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 JoinRoomRsp::playerid() const {
  // @@protoc_insertion_point(field_get:JoinRoomRsp.playerId)
  return playerid_;
}
inline void JoinRoomRsp::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
  // @@protoc_insertion_point(field_set:JoinRoomRsp.playerId)
}

// -------------------------------------------------------------------

// EnterLevelReq

// required uint32 camp = 2;
inline bool EnterLevelReq::has_camp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterLevelReq::set_has_camp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnterLevelReq::clear_has_camp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnterLevelReq::clear_camp() {
  camp_ = 0u;
  clear_has_camp();
}
inline ::google::protobuf::uint32 EnterLevelReq::camp() const {
  // @@protoc_insertion_point(field_get:EnterLevelReq.camp)
  return camp_;
}
inline void EnterLevelReq::set_camp(::google::protobuf::uint32 value) {
  set_has_camp();
  camp_ = value;
  // @@protoc_insertion_point(field_set:EnterLevelReq.camp)
}

// required uint32 model = 3;
inline bool EnterLevelReq::has_model() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnterLevelReq::set_has_model() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnterLevelReq::clear_has_model() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnterLevelReq::clear_model() {
  model_ = 0u;
  clear_has_model();
}
inline ::google::protobuf::uint32 EnterLevelReq::model() const {
  // @@protoc_insertion_point(field_get:EnterLevelReq.model)
  return model_;
}
inline void EnterLevelReq::set_model(::google::protobuf::uint32 value) {
  set_has_model();
  model_ = value;
  // @@protoc_insertion_point(field_set:EnterLevelReq.model)
}

// required uint32 weapon = 4;
inline bool EnterLevelReq::has_weapon() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EnterLevelReq::set_has_weapon() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EnterLevelReq::clear_has_weapon() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EnterLevelReq::clear_weapon() {
  weapon_ = 0u;
  clear_has_weapon();
}
inline ::google::protobuf::uint32 EnterLevelReq::weapon() const {
  // @@protoc_insertion_point(field_get:EnterLevelReq.weapon)
  return weapon_;
}
inline void EnterLevelReq::set_weapon(::google::protobuf::uint32 value) {
  set_has_weapon();
  weapon_ = value;
  // @@protoc_insertion_point(field_set:EnterLevelReq.weapon)
}

// -------------------------------------------------------------------

// EnterLevelRsp

// optional .SceneInfo scene = 2;
inline bool EnterLevelRsp::has_scene() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterLevelRsp::set_has_scene() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnterLevelRsp::clear_has_scene() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnterLevelRsp::clear_scene() {
  if (scene_ != NULL) scene_->Clear();
  clear_has_scene();
}
inline const ::SceneInfo& EnterLevelRsp::scene() const {
  const ::SceneInfo* p = scene_;
  // @@protoc_insertion_point(field_get:EnterLevelRsp.scene)
  return p != NULL ? *p : *reinterpret_cast<const ::SceneInfo*>(
      &::_SceneInfo_default_instance_);
}
inline ::SceneInfo* EnterLevelRsp::release_scene() {
  // @@protoc_insertion_point(field_release:EnterLevelRsp.scene)
  clear_has_scene();
  ::SceneInfo* temp = scene_;
  scene_ = NULL;
  return temp;
}
inline ::SceneInfo* EnterLevelRsp::mutable_scene() {
  set_has_scene();
  if (scene_ == NULL) {
    scene_ = new ::SceneInfo;
  }
  // @@protoc_insertion_point(field_mutable:EnterLevelRsp.scene)
  return scene_;
}
inline void EnterLevelRsp::set_allocated_scene(::SceneInfo* scene) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete scene_;
  }
  if (scene) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      scene = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, scene, submessage_arena);
    }
    set_has_scene();
  } else {
    clear_has_scene();
  }
  scene_ = scene;
  // @@protoc_insertion_point(field_set_allocated:EnterLevelRsp.scene)
}

// -------------------------------------------------------------------

// OnEnterRoomRsp

// required string playerNick = 2;
inline bool OnEnterRoomRsp::has_playernick() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OnEnterRoomRsp::set_has_playernick() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OnEnterRoomRsp::clear_has_playernick() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OnEnterRoomRsp::clear_playernick() {
  playernick_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_playernick();
}
inline const ::std::string& OnEnterRoomRsp::playernick() const {
  // @@protoc_insertion_point(field_get:OnEnterRoomRsp.playerNick)
  return playernick_.GetNoArena();
}
inline void OnEnterRoomRsp::set_playernick(const ::std::string& value) {
  set_has_playernick();
  playernick_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:OnEnterRoomRsp.playerNick)
}
#if LANG_CXX11
inline void OnEnterRoomRsp::set_playernick(::std::string&& value) {
  set_has_playernick();
  playernick_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:OnEnterRoomRsp.playerNick)
}
#endif
inline void OnEnterRoomRsp::set_playernick(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_playernick();
  playernick_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:OnEnterRoomRsp.playerNick)
}
inline void OnEnterRoomRsp::set_playernick(const char* value, size_t size) {
  set_has_playernick();
  playernick_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:OnEnterRoomRsp.playerNick)
}
inline ::std::string* OnEnterRoomRsp::mutable_playernick() {
  set_has_playernick();
  // @@protoc_insertion_point(field_mutable:OnEnterRoomRsp.playerNick)
  return playernick_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OnEnterRoomRsp::release_playernick() {
  // @@protoc_insertion_point(field_release:OnEnterRoomRsp.playerNick)
  clear_has_playernick();
  return playernick_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OnEnterRoomRsp::set_allocated_playernick(::std::string* playernick) {
  if (playernick != NULL) {
    set_has_playernick();
  } else {
    clear_has_playernick();
  }
  playernick_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), playernick);
  // @@protoc_insertion_point(field_set_allocated:OnEnterRoomRsp.playerNick)
}

// -------------------------------------------------------------------

// OnEnterLevelRsp

// required .Player_ player = 2;
inline bool OnEnterLevelRsp::has_player() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OnEnterLevelRsp::set_has_player() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OnEnterLevelRsp::clear_has_player() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OnEnterLevelRsp::clear_player() {
  if (player_ != NULL) player_->Clear();
  clear_has_player();
}
inline const ::Player_& OnEnterLevelRsp::player() const {
  const ::Player_* p = player_;
  // @@protoc_insertion_point(field_get:OnEnterLevelRsp.player)
  return p != NULL ? *p : *reinterpret_cast<const ::Player_*>(
      &::_Player__default_instance_);
}
inline ::Player_* OnEnterLevelRsp::release_player() {
  // @@protoc_insertion_point(field_release:OnEnterLevelRsp.player)
  clear_has_player();
  ::Player_* temp = player_;
  player_ = NULL;
  return temp;
}
inline ::Player_* OnEnterLevelRsp::mutable_player() {
  set_has_player();
  if (player_ == NULL) {
    player_ = new ::Player_;
  }
  // @@protoc_insertion_point(field_mutable:OnEnterLevelRsp.player)
  return player_;
}
inline void OnEnterLevelRsp::set_allocated_player(::Player_* player) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete player_;
  }
  if (player) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      player = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    set_has_player();
  } else {
    clear_has_player();
  }
  player_ = player;
  // @@protoc_insertion_point(field_set_allocated:OnEnterLevelRsp.player)
}

// -------------------------------------------------------------------

// Vector2_

// required int32 x = 1;
inline bool Vector2_::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vector2_::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vector2_::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vector2_::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 Vector2_::x() const {
  // @@protoc_insertion_point(field_get:Vector2_.x)
  return x_;
}
inline void Vector2_::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:Vector2_.x)
}

// required int32 y = 2;
inline bool Vector2_::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vector2_::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vector2_::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vector2_::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 Vector2_::y() const {
  // @@protoc_insertion_point(field_get:Vector2_.y)
  return y_;
}
inline void Vector2_::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:Vector2_.y)
}

// -------------------------------------------------------------------

// Vector3_

// required int32 x = 1;
inline bool Vector3_::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vector3_::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vector3_::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vector3_::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 Vector3_::x() const {
  // @@protoc_insertion_point(field_get:Vector3_.x)
  return x_;
}
inline void Vector3_::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:Vector3_.x)
}

// required int32 y = 2;
inline bool Vector3_::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vector3_::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vector3_::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vector3_::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 Vector3_::y() const {
  // @@protoc_insertion_point(field_get:Vector3_.y)
  return y_;
}
inline void Vector3_::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:Vector3_.y)
}

// required int32 z = 3;
inline bool Vector3_::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vector3_::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vector3_::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vector3_::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline ::google::protobuf::int32 Vector3_::z() const {
  // @@protoc_insertion_point(field_get:Vector3_.z)
  return z_;
}
inline void Vector3_::set_z(::google::protobuf::int32 value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:Vector3_.z)
}

// -------------------------------------------------------------------

// Quaternion_

// required int32 x = 1;
inline bool Quaternion_::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Quaternion_::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Quaternion_::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Quaternion_::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 Quaternion_::x() const {
  // @@protoc_insertion_point(field_get:Quaternion_.x)
  return x_;
}
inline void Quaternion_::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:Quaternion_.x)
}

// required int32 y = 2;
inline bool Quaternion_::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Quaternion_::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Quaternion_::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Quaternion_::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 Quaternion_::y() const {
  // @@protoc_insertion_point(field_get:Quaternion_.y)
  return y_;
}
inline void Quaternion_::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:Quaternion_.y)
}

// required int32 z = 3;
inline bool Quaternion_::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Quaternion_::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Quaternion_::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Quaternion_::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline ::google::protobuf::int32 Quaternion_::z() const {
  // @@protoc_insertion_point(field_get:Quaternion_.z)
  return z_;
}
inline void Quaternion_::set_z(::google::protobuf::int32 value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:Quaternion_.z)
}

// required int32 w = 4;
inline bool Quaternion_::has_w() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Quaternion_::set_has_w() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Quaternion_::clear_has_w() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Quaternion_::clear_w() {
  w_ = 0;
  clear_has_w();
}
inline ::google::protobuf::int32 Quaternion_::w() const {
  // @@protoc_insertion_point(field_get:Quaternion_.w)
  return w_;
}
inline void Quaternion_::set_w(::google::protobuf::int32 value) {
  set_has_w();
  w_ = value;
  // @@protoc_insertion_point(field_set:Quaternion_.w)
}

// -------------------------------------------------------------------

// SceneInfo

// repeated .SceneItem_ items = 1;
inline int SceneInfo::items_size() const {
  return items_.size();
}
inline void SceneInfo::clear_items() {
  items_.Clear();
}
inline const ::SceneItem_& SceneInfo::items(int index) const {
  // @@protoc_insertion_point(field_get:SceneInfo.items)
  return items_.Get(index);
}
inline ::SceneItem_* SceneInfo::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:SceneInfo.items)
  return items_.Mutable(index);
}
inline ::SceneItem_* SceneInfo::add_items() {
  // @@protoc_insertion_point(field_add:SceneInfo.items)
  return items_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::SceneItem_ >*
SceneInfo::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:SceneInfo.items)
  return &items_;
}
inline const ::google::protobuf::RepeatedPtrField< ::SceneItem_ >&
SceneInfo::items() const {
  // @@protoc_insertion_point(field_list:SceneInfo.items)
  return items_;
}

// repeated .Player_ players = 2;
inline int SceneInfo::players_size() const {
  return players_.size();
}
inline void SceneInfo::clear_players() {
  players_.Clear();
}
inline const ::Player_& SceneInfo::players(int index) const {
  // @@protoc_insertion_point(field_get:SceneInfo.players)
  return players_.Get(index);
}
inline ::Player_* SceneInfo::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:SceneInfo.players)
  return players_.Mutable(index);
}
inline ::Player_* SceneInfo::add_players() {
  // @@protoc_insertion_point(field_add:SceneInfo.players)
  return players_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Player_ >*
SceneInfo::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:SceneInfo.players)
  return &players_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Player_ >&
SceneInfo::players() const {
  // @@protoc_insertion_point(field_list:SceneInfo.players)
  return players_;
}

// -------------------------------------------------------------------

// SceneItem_

// required string model = 1;
inline bool SceneItem_::has_model() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SceneItem_::set_has_model() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SceneItem_::clear_has_model() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SceneItem_::clear_model() {
  model_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model();
}
inline const ::std::string& SceneItem_::model() const {
  // @@protoc_insertion_point(field_get:SceneItem_.model)
  return model_.GetNoArena();
}
inline void SceneItem_::set_model(const ::std::string& value) {
  set_has_model();
  model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SceneItem_.model)
}
#if LANG_CXX11
inline void SceneItem_::set_model(::std::string&& value) {
  set_has_model();
  model_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SceneItem_.model)
}
#endif
inline void SceneItem_::set_model(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_model();
  model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SceneItem_.model)
}
inline void SceneItem_::set_model(const char* value, size_t size) {
  set_has_model();
  model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SceneItem_.model)
}
inline ::std::string* SceneItem_::mutable_model() {
  set_has_model();
  // @@protoc_insertion_point(field_mutable:SceneItem_.model)
  return model_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SceneItem_::release_model() {
  // @@protoc_insertion_point(field_release:SceneItem_.model)
  clear_has_model();
  return model_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SceneItem_::set_allocated_model(::std::string* model) {
  if (model != NULL) {
    set_has_model();
  } else {
    clear_has_model();
  }
  model_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model);
  // @@protoc_insertion_point(field_set_allocated:SceneItem_.model)
}

// required .Vector3_ pos = 2;
inline bool SceneItem_::has_pos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SceneItem_::set_has_pos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SceneItem_::clear_has_pos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SceneItem_::clear_pos() {
  if (pos_ != NULL) pos_->Clear();
  clear_has_pos();
}
inline const ::Vector3_& SceneItem_::pos() const {
  const ::Vector3_* p = pos_;
  // @@protoc_insertion_point(field_get:SceneItem_.pos)
  return p != NULL ? *p : *reinterpret_cast<const ::Vector3_*>(
      &::_Vector3__default_instance_);
}
inline ::Vector3_* SceneItem_::release_pos() {
  // @@protoc_insertion_point(field_release:SceneItem_.pos)
  clear_has_pos();
  ::Vector3_* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline ::Vector3_* SceneItem_::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) {
    pos_ = new ::Vector3_;
  }
  // @@protoc_insertion_point(field_mutable:SceneItem_.pos)
  return pos_;
}
inline void SceneItem_::set_allocated_pos(::Vector3_* pos) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete pos_;
  }
  if (pos) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pos = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    set_has_pos();
  } else {
    clear_has_pos();
  }
  pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:SceneItem_.pos)
}

// required .Quaternion_ rotation = 3;
inline bool SceneItem_::has_rotation() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SceneItem_::set_has_rotation() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SceneItem_::clear_has_rotation() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SceneItem_::clear_rotation() {
  if (rotation_ != NULL) rotation_->Clear();
  clear_has_rotation();
}
inline const ::Quaternion_& SceneItem_::rotation() const {
  const ::Quaternion_* p = rotation_;
  // @@protoc_insertion_point(field_get:SceneItem_.rotation)
  return p != NULL ? *p : *reinterpret_cast<const ::Quaternion_*>(
      &::_Quaternion__default_instance_);
}
inline ::Quaternion_* SceneItem_::release_rotation() {
  // @@protoc_insertion_point(field_release:SceneItem_.rotation)
  clear_has_rotation();
  ::Quaternion_* temp = rotation_;
  rotation_ = NULL;
  return temp;
}
inline ::Quaternion_* SceneItem_::mutable_rotation() {
  set_has_rotation();
  if (rotation_ == NULL) {
    rotation_ = new ::Quaternion_;
  }
  // @@protoc_insertion_point(field_mutable:SceneItem_.rotation)
  return rotation_;
}
inline void SceneItem_::set_allocated_rotation(::Quaternion_* rotation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete rotation_;
  }
  if (rotation) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      rotation = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rotation, submessage_arena);
    }
    set_has_rotation();
  } else {
    clear_has_rotation();
  }
  rotation_ = rotation;
  // @@protoc_insertion_point(field_set_allocated:SceneItem_.rotation)
}

// required int32 frame = 4;
inline bool SceneItem_::has_frame() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SceneItem_::set_has_frame() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SceneItem_::clear_has_frame() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SceneItem_::clear_frame() {
  frame_ = 0;
  clear_has_frame();
}
inline ::google::protobuf::int32 SceneItem_::frame() const {
  // @@protoc_insertion_point(field_get:SceneItem_.frame)
  return frame_;
}
inline void SceneItem_::set_frame(::google::protobuf::int32 value) {
  set_has_frame();
  frame_ = value;
  // @@protoc_insertion_point(field_set:SceneItem_.frame)
}

// -------------------------------------------------------------------

// Player_

// required uint32 id = 1;
inline bool Player_::has_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Player_::set_has_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Player_::clear_has_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Player_::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 Player_::id() const {
  // @@protoc_insertion_point(field_get:Player_.id)
  return id_;
}
inline void Player_::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:Player_.id)
}

// required string name = 2;
inline bool Player_::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Player_::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Player_::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Player_::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Player_::name() const {
  // @@protoc_insertion_point(field_get:Player_.name)
  return name_.GetNoArena();
}
inline void Player_::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Player_.name)
}
#if LANG_CXX11
inline void Player_::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Player_.name)
}
#endif
inline void Player_::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Player_.name)
}
inline void Player_::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Player_.name)
}
inline ::std::string* Player_::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:Player_.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Player_::release_name() {
  // @@protoc_insertion_point(field_release:Player_.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Player_::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Player_.name)
}

// required uint32 weapon1 = 3;
inline bool Player_::has_weapon1() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Player_::set_has_weapon1() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Player_::clear_has_weapon1() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Player_::clear_weapon1() {
  weapon1_ = 0u;
  clear_has_weapon1();
}
inline ::google::protobuf::uint32 Player_::weapon1() const {
  // @@protoc_insertion_point(field_get:Player_.weapon1)
  return weapon1_;
}
inline void Player_::set_weapon1(::google::protobuf::uint32 value) {
  set_has_weapon1();
  weapon1_ = value;
  // @@protoc_insertion_point(field_set:Player_.weapon1)
}

// required uint32 weapon2 = 4;
inline bool Player_::has_weapon2() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Player_::set_has_weapon2() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Player_::clear_has_weapon2() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Player_::clear_weapon2() {
  weapon2_ = 0u;
  clear_has_weapon2();
}
inline ::google::protobuf::uint32 Player_::weapon2() const {
  // @@protoc_insertion_point(field_get:Player_.weapon2)
  return weapon2_;
}
inline void Player_::set_weapon2(::google::protobuf::uint32 value) {
  set_has_weapon2();
  weapon2_ = value;
  // @@protoc_insertion_point(field_set:Player_.weapon2)
}

// required uint32 weapon = 5;
inline bool Player_::has_weapon() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Player_::set_has_weapon() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Player_::clear_has_weapon() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Player_::clear_weapon() {
  weapon_ = 0u;
  clear_has_weapon();
}
inline ::google::protobuf::uint32 Player_::weapon() const {
  // @@protoc_insertion_point(field_get:Player_.weapon)
  return weapon_;
}
inline void Player_::set_weapon(::google::protobuf::uint32 value) {
  set_has_weapon();
  weapon_ = value;
  // @@protoc_insertion_point(field_set:Player_.weapon)
}

// required uint32 weapon_pos = 6;
inline bool Player_::has_weapon_pos() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Player_::set_has_weapon_pos() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Player_::clear_has_weapon_pos() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Player_::clear_weapon_pos() {
  weapon_pos_ = 0u;
  clear_has_weapon_pos();
}
inline ::google::protobuf::uint32 Player_::weapon_pos() const {
  // @@protoc_insertion_point(field_get:Player_.weapon_pos)
  return weapon_pos_;
}
inline void Player_::set_weapon_pos(::google::protobuf::uint32 value) {
  set_has_weapon_pos();
  weapon_pos_ = value;
  // @@protoc_insertion_point(field_set:Player_.weapon_pos)
}

// required .Vector3_ pos = 7;
inline bool Player_::has_pos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Player_::set_has_pos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Player_::clear_has_pos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Player_::clear_pos() {
  if (pos_ != NULL) pos_->Clear();
  clear_has_pos();
}
inline const ::Vector3_& Player_::pos() const {
  const ::Vector3_* p = pos_;
  // @@protoc_insertion_point(field_get:Player_.pos)
  return p != NULL ? *p : *reinterpret_cast<const ::Vector3_*>(
      &::_Vector3__default_instance_);
}
inline ::Vector3_* Player_::release_pos() {
  // @@protoc_insertion_point(field_release:Player_.pos)
  clear_has_pos();
  ::Vector3_* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline ::Vector3_* Player_::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) {
    pos_ = new ::Vector3_;
  }
  // @@protoc_insertion_point(field_mutable:Player_.pos)
  return pos_;
}
inline void Player_::set_allocated_pos(::Vector3_* pos) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete pos_;
  }
  if (pos) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pos = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    set_has_pos();
  } else {
    clear_has_pos();
  }
  pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:Player_.pos)
}

// required .Quaternion_ rotation = 8;
inline bool Player_::has_rotation() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Player_::set_has_rotation() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Player_::clear_has_rotation() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Player_::clear_rotation() {
  if (rotation_ != NULL) rotation_->Clear();
  clear_has_rotation();
}
inline const ::Quaternion_& Player_::rotation() const {
  const ::Quaternion_* p = rotation_;
  // @@protoc_insertion_point(field_get:Player_.rotation)
  return p != NULL ? *p : *reinterpret_cast<const ::Quaternion_*>(
      &::_Quaternion__default_instance_);
}
inline ::Quaternion_* Player_::release_rotation() {
  // @@protoc_insertion_point(field_release:Player_.rotation)
  clear_has_rotation();
  ::Quaternion_* temp = rotation_;
  rotation_ = NULL;
  return temp;
}
inline ::Quaternion_* Player_::mutable_rotation() {
  set_has_rotation();
  if (rotation_ == NULL) {
    rotation_ = new ::Quaternion_;
  }
  // @@protoc_insertion_point(field_mutable:Player_.rotation)
  return rotation_;
}
inline void Player_::set_allocated_rotation(::Quaternion_* rotation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete rotation_;
  }
  if (rotation) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      rotation = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rotation, submessage_arena);
    }
    set_has_rotation();
  } else {
    clear_has_rotation();
  }
  rotation_ = rotation;
  // @@protoc_insertion_point(field_set_allocated:Player_.rotation)
}

// required int32 model = 9;
inline bool Player_::has_model() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Player_::set_has_model() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Player_::clear_has_model() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Player_::clear_model() {
  model_ = 0;
  clear_has_model();
}
inline ::google::protobuf::int32 Player_::model() const {
  // @@protoc_insertion_point(field_get:Player_.model)
  return model_;
}
inline void Player_::set_model(::google::protobuf::int32 value) {
  set_has_model();
  model_ = value;
  // @@protoc_insertion_point(field_set:Player_.model)
}

// required int32 aniSource = 10;
inline bool Player_::has_anisource() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Player_::set_has_anisource() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Player_::clear_has_anisource() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Player_::clear_anisource() {
  anisource_ = 0;
  clear_has_anisource();
}
inline ::google::protobuf::int32 Player_::anisource() const {
  // @@protoc_insertion_point(field_get:Player_.aniSource)
  return anisource_;
}
inline void Player_::set_anisource(::google::protobuf::int32 value) {
  set_has_anisource();
  anisource_ = value;
  // @@protoc_insertion_point(field_set:Player_.aniSource)
}

// required int32 frame = 11;
inline bool Player_::has_frame() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Player_::set_has_frame() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Player_::clear_has_frame() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Player_::clear_frame() {
  frame_ = 0;
  clear_has_frame();
}
inline ::google::protobuf::int32 Player_::frame() const {
  // @@protoc_insertion_point(field_get:Player_.frame)
  return frame_;
}
inline void Player_::set_frame(::google::protobuf::int32 value) {
  set_has_frame();
  frame_ = value;
  // @@protoc_insertion_point(field_set:Player_.frame)
}

// required int32 hpMax = 12;
inline bool Player_::has_hpmax() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Player_::set_has_hpmax() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Player_::clear_has_hpmax() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Player_::clear_hpmax() {
  hpmax_ = 0;
  clear_has_hpmax();
}
inline ::google::protobuf::int32 Player_::hpmax() const {
  // @@protoc_insertion_point(field_get:Player_.hpMax)
  return hpmax_;
}
inline void Player_::set_hpmax(::google::protobuf::int32 value) {
  set_has_hpmax();
  hpmax_ = value;
  // @@protoc_insertion_point(field_set:Player_.hpMax)
}

// required int32 hp = 13;
inline bool Player_::has_hp() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Player_::set_has_hp() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Player_::clear_has_hp() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Player_::clear_hp() {
  hp_ = 0;
  clear_has_hp();
}
inline ::google::protobuf::int32 Player_::hp() const {
  // @@protoc_insertion_point(field_get:Player_.hp)
  return hp_;
}
inline void Player_::set_hp(::google::protobuf::int32 value) {
  set_has_hp();
  hp_ = value;
  // @@protoc_insertion_point(field_set:Player_.hp)
}

// required int32 angry = 14;
inline bool Player_::has_angry() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Player_::set_has_angry() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Player_::clear_has_angry() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Player_::clear_angry() {
  angry_ = 0;
  clear_has_angry();
}
inline ::google::protobuf::int32 Player_::angry() const {
  // @@protoc_insertion_point(field_get:Player_.angry)
  return angry_;
}
inline void Player_::set_angry(::google::protobuf::int32 value) {
  set_has_angry();
  angry_ = value;
  // @@protoc_insertion_point(field_set:Player_.angry)
}

// required int32 Camp = 15;
inline bool Player_::has_camp() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Player_::set_has_camp() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Player_::clear_has_camp() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Player_::clear_camp() {
  camp_ = 0;
  clear_has_camp();
}
inline ::google::protobuf::int32 Player_::camp() const {
  // @@protoc_insertion_point(field_get:Player_.Camp)
  return camp_;
}
inline void Player_::set_camp(::google::protobuf::int32 value) {
  set_has_camp();
  camp_ = value;
  // @@protoc_insertion_point(field_set:Player_.Camp)
}

// required int32 SpawnPoint = 16;
inline bool Player_::has_spawnpoint() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Player_::set_has_spawnpoint() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Player_::clear_has_spawnpoint() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Player_::clear_spawnpoint() {
  spawnpoint_ = 0;
  clear_has_spawnpoint();
}
inline ::google::protobuf::int32 Player_::spawnpoint() const {
  // @@protoc_insertion_point(field_get:Player_.SpawnPoint)
  return spawnpoint_;
}
inline void Player_::set_spawnpoint(::google::protobuf::int32 value) {
  set_has_spawnpoint();
  spawnpoint_ = value;
  // @@protoc_insertion_point(field_set:Player_.SpawnPoint)
}

// -------------------------------------------------------------------

// InputReq

// repeated .Input_ input = 1;
inline int InputReq::input_size() const {
  return input_.size();
}
inline void InputReq::clear_input() {
  input_.Clear();
}
inline const ::Input_& InputReq::input(int index) const {
  // @@protoc_insertion_point(field_get:InputReq.input)
  return input_.Get(index);
}
inline ::Input_* InputReq::mutable_input(int index) {
  // @@protoc_insertion_point(field_mutable:InputReq.input)
  return input_.Mutable(index);
}
inline ::Input_* InputReq::add_input() {
  // @@protoc_insertion_point(field_add:InputReq.input)
  return input_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Input_ >*
InputReq::mutable_input() {
  // @@protoc_insertion_point(field_mutable_list:InputReq.input)
  return &input_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Input_ >&
InputReq::input() const {
  // @@protoc_insertion_point(field_list:InputReq.input)
  return input_;
}

// -------------------------------------------------------------------

// Input_

// required uint32 playerId = 1;
inline bool Input_::has_playerid() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Input_::set_has_playerid() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Input_::clear_has_playerid() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Input_::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 Input_::playerid() const {
  // @@protoc_insertion_point(field_get:Input_.playerId)
  return playerid_;
}
inline void Input_::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
  // @@protoc_insertion_point(field_set:Input_.playerId)
}

// required .Vector2_ JoyStick = 2;
inline bool Input_::has_joystick() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Input_::set_has_joystick() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Input_::clear_has_joystick() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Input_::clear_joystick() {
  if (joystick_ != NULL) joystick_->Clear();
  clear_has_joystick();
}
inline const ::Vector2_& Input_::joystick() const {
  const ::Vector2_* p = joystick_;
  // @@protoc_insertion_point(field_get:Input_.JoyStick)
  return p != NULL ? *p : *reinterpret_cast<const ::Vector2_*>(
      &::_Vector2__default_instance_);
}
inline ::Vector2_* Input_::release_joystick() {
  // @@protoc_insertion_point(field_release:Input_.JoyStick)
  clear_has_joystick();
  ::Vector2_* temp = joystick_;
  joystick_ = NULL;
  return temp;
}
inline ::Vector2_* Input_::mutable_joystick() {
  set_has_joystick();
  if (joystick_ == NULL) {
    joystick_ = new ::Vector2_;
  }
  // @@protoc_insertion_point(field_mutable:Input_.JoyStick)
  return joystick_;
}
inline void Input_::set_allocated_joystick(::Vector2_* joystick) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete joystick_;
  }
  if (joystick) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      joystick = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, joystick, submessage_arena);
    }
    set_has_joystick();
  } else {
    clear_has_joystick();
  }
  joystick_ = joystick;
  // @@protoc_insertion_point(field_set_allocated:Input_.JoyStick)
}

// required .Vector2_ MouseDelta = 3;
inline bool Input_::has_mousedelta() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Input_::set_has_mousedelta() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Input_::clear_has_mousedelta() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Input_::clear_mousedelta() {
  if (mousedelta_ != NULL) mousedelta_->Clear();
  clear_has_mousedelta();
}
inline const ::Vector2_& Input_::mousedelta() const {
  const ::Vector2_* p = mousedelta_;
  // @@protoc_insertion_point(field_get:Input_.MouseDelta)
  return p != NULL ? *p : *reinterpret_cast<const ::Vector2_*>(
      &::_Vector2__default_instance_);
}
inline ::Vector2_* Input_::release_mousedelta() {
  // @@protoc_insertion_point(field_release:Input_.MouseDelta)
  clear_has_mousedelta();
  ::Vector2_* temp = mousedelta_;
  mousedelta_ = NULL;
  return temp;
}
inline ::Vector2_* Input_::mutable_mousedelta() {
  set_has_mousedelta();
  if (mousedelta_ == NULL) {
    mousedelta_ = new ::Vector2_;
  }
  // @@protoc_insertion_point(field_mutable:Input_.MouseDelta)
  return mousedelta_;
}
inline void Input_::set_allocated_mousedelta(::Vector2_* mousedelta) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete mousedelta_;
  }
  if (mousedelta) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      mousedelta = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, mousedelta, submessage_arena);
    }
    set_has_mousedelta();
  } else {
    clear_has_mousedelta();
  }
  mousedelta_ = mousedelta;
  // @@protoc_insertion_point(field_set_allocated:Input_.MouseDelta)
}

// required bytes w = 4;
inline bool Input_::has_w() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Input_::set_has_w() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Input_::clear_has_w() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Input_::clear_w() {
  w_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_w();
}
inline const ::std::string& Input_::w() const {
  // @@protoc_insertion_point(field_get:Input_.w)
  return w_.GetNoArena();
}
inline void Input_::set_w(const ::std::string& value) {
  set_has_w();
  w_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Input_.w)
}
#if LANG_CXX11
inline void Input_::set_w(::std::string&& value) {
  set_has_w();
  w_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Input_.w)
}
#endif
inline void Input_::set_w(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_w();
  w_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Input_.w)
}
inline void Input_::set_w(const void* value, size_t size) {
  set_has_w();
  w_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Input_.w)
}
inline ::std::string* Input_::mutable_w() {
  set_has_w();
  // @@protoc_insertion_point(field_mutable:Input_.w)
  return w_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Input_::release_w() {
  // @@protoc_insertion_point(field_release:Input_.w)
  clear_has_w();
  return w_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Input_::set_allocated_w(::std::string* w) {
  if (w != NULL) {
    set_has_w();
  } else {
    clear_has_w();
  }
  w_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), w);
  // @@protoc_insertion_point(field_set_allocated:Input_.w)
}

// required bytes s = 5;
inline bool Input_::has_s() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Input_::set_has_s() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Input_::clear_has_s() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Input_::clear_s() {
  s_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_s();
}
inline const ::std::string& Input_::s() const {
  // @@protoc_insertion_point(field_get:Input_.s)
  return s_.GetNoArena();
}
inline void Input_::set_s(const ::std::string& value) {
  set_has_s();
  s_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Input_.s)
}
#if LANG_CXX11
inline void Input_::set_s(::std::string&& value) {
  set_has_s();
  s_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Input_.s)
}
#endif
inline void Input_::set_s(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_s();
  s_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Input_.s)
}
inline void Input_::set_s(const void* value, size_t size) {
  set_has_s();
  s_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Input_.s)
}
inline ::std::string* Input_::mutable_s() {
  set_has_s();
  // @@protoc_insertion_point(field_mutable:Input_.s)
  return s_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Input_::release_s() {
  // @@protoc_insertion_point(field_release:Input_.s)
  clear_has_s();
  return s_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Input_::set_allocated_s(::std::string* s) {
  if (s != NULL) {
    set_has_s();
  } else {
    clear_has_s();
  }
  s_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), s);
  // @@protoc_insertion_point(field_set_allocated:Input_.s)
}

// required bytes a = 6;
inline bool Input_::has_a() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Input_::set_has_a() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Input_::clear_has_a() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Input_::clear_a() {
  a_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_a();
}
inline const ::std::string& Input_::a() const {
  // @@protoc_insertion_point(field_get:Input_.a)
  return a_.GetNoArena();
}
inline void Input_::set_a(const ::std::string& value) {
  set_has_a();
  a_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Input_.a)
}
#if LANG_CXX11
inline void Input_::set_a(::std::string&& value) {
  set_has_a();
  a_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Input_.a)
}
#endif
inline void Input_::set_a(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_a();
  a_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Input_.a)
}
inline void Input_::set_a(const void* value, size_t size) {
  set_has_a();
  a_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Input_.a)
}
inline ::std::string* Input_::mutable_a() {
  set_has_a();
  // @@protoc_insertion_point(field_mutable:Input_.a)
  return a_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Input_::release_a() {
  // @@protoc_insertion_point(field_release:Input_.a)
  clear_has_a();
  return a_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Input_::set_allocated_a(::std::string* a) {
  if (a != NULL) {
    set_has_a();
  } else {
    clear_has_a();
  }
  a_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), a);
  // @@protoc_insertion_point(field_set_allocated:Input_.a)
}

// required bytes d = 7;
inline bool Input_::has_d() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Input_::set_has_d() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Input_::clear_has_d() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Input_::clear_d() {
  d_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_d();
}
inline const ::std::string& Input_::d() const {
  // @@protoc_insertion_point(field_get:Input_.d)
  return d_.GetNoArena();
}
inline void Input_::set_d(const ::std::string& value) {
  set_has_d();
  d_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Input_.d)
}
#if LANG_CXX11
inline void Input_::set_d(::std::string&& value) {
  set_has_d();
  d_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Input_.d)
}
#endif
inline void Input_::set_d(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_d();
  d_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Input_.d)
}
inline void Input_::set_d(const void* value, size_t size) {
  set_has_d();
  d_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Input_.d)
}
inline ::std::string* Input_::mutable_d() {
  set_has_d();
  // @@protoc_insertion_point(field_mutable:Input_.d)
  return d_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Input_::release_d() {
  // @@protoc_insertion_point(field_release:Input_.d)
  clear_has_d();
  return d_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Input_::set_allocated_d(::std::string* d) {
  if (d != NULL) {
    set_has_d();
  } else {
    clear_has_d();
  }
  d_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), d);
  // @@protoc_insertion_point(field_set_allocated:Input_.d)
}

// required bytes jump = 8;
inline bool Input_::has_jump() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Input_::set_has_jump() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Input_::clear_has_jump() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Input_::clear_jump() {
  jump_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_jump();
}
inline const ::std::string& Input_::jump() const {
  // @@protoc_insertion_point(field_get:Input_.jump)
  return jump_.GetNoArena();
}
inline void Input_::set_jump(const ::std::string& value) {
  set_has_jump();
  jump_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Input_.jump)
}
#if LANG_CXX11
inline void Input_::set_jump(::std::string&& value) {
  set_has_jump();
  jump_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Input_.jump)
}
#endif
inline void Input_::set_jump(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_jump();
  jump_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Input_.jump)
}
inline void Input_::set_jump(const void* value, size_t size) {
  set_has_jump();
  jump_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Input_.jump)
}
inline ::std::string* Input_::mutable_jump() {
  set_has_jump();
  // @@protoc_insertion_point(field_mutable:Input_.jump)
  return jump_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Input_::release_jump() {
  // @@protoc_insertion_point(field_release:Input_.jump)
  clear_has_jump();
  return jump_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Input_::set_allocated_jump(::std::string* jump) {
  if (jump != NULL) {
    set_has_jump();
  } else {
    clear_has_jump();
  }
  jump_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), jump);
  // @@protoc_insertion_point(field_set_allocated:Input_.jump)
}

// required bytes break = 9;
inline bool Input_::has_break_() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Input_::set_has_break_() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Input_::clear_has_break_() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Input_::clear_break_() {
  break__.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_break_();
}
inline const ::std::string& Input_::break_() const {
  // @@protoc_insertion_point(field_get:Input_.break)
  return break__.GetNoArena();
}
inline void Input_::set_break_(const ::std::string& value) {
  set_has_break_();
  break__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Input_.break)
}
#if LANG_CXX11
inline void Input_::set_break_(::std::string&& value) {
  set_has_break_();
  break__.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Input_.break)
}
#endif
inline void Input_::set_break_(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_break_();
  break__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Input_.break)
}
inline void Input_::set_break_(const void* value, size_t size) {
  set_has_break_();
  break__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Input_.break)
}
inline ::std::string* Input_::mutable_break_() {
  set_has_break_();
  // @@protoc_insertion_point(field_mutable:Input_.break)
  return break__.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Input_::release_break_() {
  // @@protoc_insertion_point(field_release:Input_.break)
  clear_has_break_();
  return break__.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Input_::set_allocated_break_(::std::string* break_) {
  if (break_ != NULL) {
    set_has_break_();
  } else {
    clear_has_break_();
  }
  break__.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), break_);
  // @@protoc_insertion_point(field_set_allocated:Input_.break)
}

// required bytes attack = 10;
inline bool Input_::has_attack() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Input_::set_has_attack() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Input_::clear_has_attack() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Input_::clear_attack() {
  attack_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_attack();
}
inline const ::std::string& Input_::attack() const {
  // @@protoc_insertion_point(field_get:Input_.attack)
  return attack_.GetNoArena();
}
inline void Input_::set_attack(const ::std::string& value) {
  set_has_attack();
  attack_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Input_.attack)
}
#if LANG_CXX11
inline void Input_::set_attack(::std::string&& value) {
  set_has_attack();
  attack_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Input_.attack)
}
#endif
inline void Input_::set_attack(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_attack();
  attack_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Input_.attack)
}
inline void Input_::set_attack(const void* value, size_t size) {
  set_has_attack();
  attack_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Input_.attack)
}
inline ::std::string* Input_::mutable_attack() {
  set_has_attack();
  // @@protoc_insertion_point(field_mutable:Input_.attack)
  return attack_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Input_::release_attack() {
  // @@protoc_insertion_point(field_release:Input_.attack)
  clear_has_attack();
  return attack_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Input_::set_allocated_attack(::std::string* attack) {
  if (attack != NULL) {
    set_has_attack();
  } else {
    clear_has_attack();
  }
  attack_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), attack);
  // @@protoc_insertion_point(field_set_allocated:Input_.attack)
}

// required bytes e = 11;
inline bool Input_::has_e() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Input_::set_has_e() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Input_::clear_has_e() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Input_::clear_e() {
  e_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_e();
}
inline const ::std::string& Input_::e() const {
  // @@protoc_insertion_point(field_get:Input_.e)
  return e_.GetNoArena();
}
inline void Input_::set_e(const ::std::string& value) {
  set_has_e();
  e_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Input_.e)
}
#if LANG_CXX11
inline void Input_::set_e(::std::string&& value) {
  set_has_e();
  e_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Input_.e)
}
#endif
inline void Input_::set_e(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_e();
  e_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Input_.e)
}
inline void Input_::set_e(const void* value, size_t size) {
  set_has_e();
  e_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Input_.e)
}
inline ::std::string* Input_::mutable_e() {
  set_has_e();
  // @@protoc_insertion_point(field_mutable:Input_.e)
  return e_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Input_::release_e() {
  // @@protoc_insertion_point(field_release:Input_.e)
  clear_has_e();
  return e_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Input_::set_allocated_e(::std::string* e) {
  if (e != NULL) {
    set_has_e();
  } else {
    clear_has_e();
  }
  e_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), e);
  // @@protoc_insertion_point(field_set_allocated:Input_.e)
}

// required bytes r = 12;
inline bool Input_::has_r() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Input_::set_has_r() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Input_::clear_has_r() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Input_::clear_r() {
  r_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_r();
}
inline const ::std::string& Input_::r() const {
  // @@protoc_insertion_point(field_get:Input_.r)
  return r_.GetNoArena();
}
inline void Input_::set_r(const ::std::string& value) {
  set_has_r();
  r_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Input_.r)
}
#if LANG_CXX11
inline void Input_::set_r(::std::string&& value) {
  set_has_r();
  r_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Input_.r)
}
#endif
inline void Input_::set_r(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_r();
  r_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Input_.r)
}
inline void Input_::set_r(const void* value, size_t size) {
  set_has_r();
  r_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Input_.r)
}
inline ::std::string* Input_::mutable_r() {
  set_has_r();
  // @@protoc_insertion_point(field_mutable:Input_.r)
  return r_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Input_::release_r() {
  // @@protoc_insertion_point(field_release:Input_.r)
  clear_has_r();
  return r_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Input_::set_allocated_r(::std::string* r) {
  if (r != NULL) {
    set_has_r();
  } else {
    clear_has_r();
  }
  r_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), r);
  // @@protoc_insertion_point(field_set_allocated:Input_.r)
}

// required bytes y = 13;
inline bool Input_::has_y() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Input_::set_has_y() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Input_::clear_has_y() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Input_::clear_y() {
  y_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_y();
}
inline const ::std::string& Input_::y() const {
  // @@protoc_insertion_point(field_get:Input_.y)
  return y_.GetNoArena();
}
inline void Input_::set_y(const ::std::string& value) {
  set_has_y();
  y_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Input_.y)
}
#if LANG_CXX11
inline void Input_::set_y(::std::string&& value) {
  set_has_y();
  y_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Input_.y)
}
#endif
inline void Input_::set_y(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_y();
  y_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Input_.y)
}
inline void Input_::set_y(const void* value, size_t size) {
  set_has_y();
  y_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Input_.y)
}
inline ::std::string* Input_::mutable_y() {
  set_has_y();
  // @@protoc_insertion_point(field_mutable:Input_.y)
  return y_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Input_::release_y() {
  // @@protoc_insertion_point(field_release:Input_.y)
  clear_has_y();
  return y_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Input_::set_allocated_y(::std::string* y) {
  if (y != NULL) {
    set_has_y();
  } else {
    clear_has_y();
  }
  y_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), y);
  // @@protoc_insertion_point(field_set_allocated:Input_.y)
}

// required bytes space = 14;
inline bool Input_::has_space() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Input_::set_has_space() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Input_::clear_has_space() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Input_::clear_space() {
  space_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_space();
}
inline const ::std::string& Input_::space() const {
  // @@protoc_insertion_point(field_get:Input_.space)
  return space_.GetNoArena();
}
inline void Input_::set_space(const ::std::string& value) {
  set_has_space();
  space_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Input_.space)
}
#if LANG_CXX11
inline void Input_::set_space(::std::string&& value) {
  set_has_space();
  space_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Input_.space)
}
#endif
inline void Input_::set_space(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_space();
  space_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Input_.space)
}
inline void Input_::set_space(const void* value, size_t size) {
  set_has_space();
  space_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Input_.space)
}
inline ::std::string* Input_::mutable_space() {
  set_has_space();
  // @@protoc_insertion_point(field_mutable:Input_.space)
  return space_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Input_::release_space() {
  // @@protoc_insertion_point(field_release:Input_.space)
  clear_has_space();
  return space_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Input_::set_allocated_space(::std::string* space) {
  if (space != NULL) {
    set_has_space();
  } else {
    clear_has_space();
  }
  space_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), space);
  // @@protoc_insertion_point(field_set_allocated:Input_.space)
}

// required bytes c = 15;
inline bool Input_::has_c() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Input_::set_has_c() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Input_::clear_has_c() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Input_::clear_c() {
  c_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_c();
}
inline const ::std::string& Input_::c() const {
  // @@protoc_insertion_point(field_get:Input_.c)
  return c_.GetNoArena();
}
inline void Input_::set_c(const ::std::string& value) {
  set_has_c();
  c_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Input_.c)
}
#if LANG_CXX11
inline void Input_::set_c(::std::string&& value) {
  set_has_c();
  c_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Input_.c)
}
#endif
inline void Input_::set_c(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_c();
  c_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Input_.c)
}
inline void Input_::set_c(const void* value, size_t size) {
  set_has_c();
  c_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Input_.c)
}
inline ::std::string* Input_::mutable_c() {
  set_has_c();
  // @@protoc_insertion_point(field_mutable:Input_.c)
  return c_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Input_::release_c() {
  // @@protoc_insertion_point(field_release:Input_.c)
  clear_has_c();
  return c_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Input_::set_allocated_c(::std::string* c) {
  if (c != NULL) {
    set_has_c();
  } else {
    clear_has_c();
  }
  c_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), c);
  // @@protoc_insertion_point(field_set_allocated:Input_.c)
}

// -------------------------------------------------------------------

// KeyFrame

// required uint32 frameIndex = 1;
inline bool KeyFrame::has_frameindex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KeyFrame::set_has_frameindex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KeyFrame::clear_has_frameindex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KeyFrame::clear_frameindex() {
  frameindex_ = 0u;
  clear_has_frameindex();
}
inline ::google::protobuf::uint32 KeyFrame::frameindex() const {
  // @@protoc_insertion_point(field_get:KeyFrame.frameIndex)
  return frameindex_;
}
inline void KeyFrame::set_frameindex(::google::protobuf::uint32 value) {
  set_has_frameindex();
  frameindex_ = value;
  // @@protoc_insertion_point(field_set:KeyFrame.frameIndex)
}

// repeated .Input_ Inputs = 2;
inline int KeyFrame::inputs_size() const {
  return inputs_.size();
}
inline void KeyFrame::clear_inputs() {
  inputs_.Clear();
}
inline const ::Input_& KeyFrame::inputs(int index) const {
  // @@protoc_insertion_point(field_get:KeyFrame.Inputs)
  return inputs_.Get(index);
}
inline ::Input_* KeyFrame::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:KeyFrame.Inputs)
  return inputs_.Mutable(index);
}
inline ::Input_* KeyFrame::add_inputs() {
  // @@protoc_insertion_point(field_add:KeyFrame.Inputs)
  return inputs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Input_ >*
KeyFrame::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:KeyFrame.Inputs)
  return &inputs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Input_ >&
KeyFrame::inputs() const {
  // @@protoc_insertion_point(field_list:KeyFrame.Inputs)
  return inputs_;
}

// repeated .Player_ Players = 3;
inline int KeyFrame::players_size() const {
  return players_.size();
}
inline void KeyFrame::clear_players() {
  players_.Clear();
}
inline const ::Player_& KeyFrame::players(int index) const {
  // @@protoc_insertion_point(field_get:KeyFrame.Players)
  return players_.Get(index);
}
inline ::Player_* KeyFrame::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:KeyFrame.Players)
  return players_.Mutable(index);
}
inline ::Player_* KeyFrame::add_players() {
  // @@protoc_insertion_point(field_add:KeyFrame.Players)
  return players_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Player_ >*
KeyFrame::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:KeyFrame.Players)
  return &players_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Player_ >&
KeyFrame::players() const {
  // @@protoc_insertion_point(field_list:KeyFrame.Players)
  return players_;
}

// -------------------------------------------------------------------

// UserId

// repeated uint32 Player = 1;
inline int UserId::player_size() const {
  return player_.size();
}
inline void UserId::clear_player() {
  player_.Clear();
}
inline ::google::protobuf::uint32 UserId::player(int index) const {
  // @@protoc_insertion_point(field_get:UserId.Player)
  return player_.Get(index);
}
inline void UserId::set_player(int index, ::google::protobuf::uint32 value) {
  player_.Set(index, value);
  // @@protoc_insertion_point(field_set:UserId.Player)
}
inline void UserId::add_player(::google::protobuf::uint32 value) {
  player_.Add(value);
  // @@protoc_insertion_point(field_add:UserId.Player)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
UserId::player() const {
  // @@protoc_insertion_point(field_list:UserId.Player)
  return player_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
UserId::mutable_player() {
  // @@protoc_insertion_point(field_mutable_list:UserId.Player)
  return &player_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::MeteorMsg_MsgType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MeteorMsg_MsgType>() {
  return ::MeteorMsg_MsgType_descriptor();
}
template <> struct is_proto_enum< ::RoomInfo_RoomPattern> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RoomInfo_RoomPattern>() {
  return ::RoomInfo_RoomPattern_descriptor();
}
template <> struct is_proto_enum< ::RoomInfo_RoomRule> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RoomInfo_RoomRule>() {
  return ::RoomInfo_RoomRule_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protocol_2eproto__INCLUDED
