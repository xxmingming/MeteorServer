// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protocol.proto

#ifndef PROTOBUF_protocol_2eproto__INCLUDED
#define PROTOBUF_protocol_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_protocol_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[39];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsMeteorMsgImpl();
void InitDefaultsMeteorMsg();
void InitDefaultsEnterQueueRspImpl();
void InitDefaultsEnterQueueRsp();
void InitDefaultsOnBattleBeginImpl();
void InitDefaultsOnBattleBegin();
void InitDefaultsUserSelectRoleImpl();
void InitDefaultsUserSelectRole();
void InitDefaultsUserSelectSkillImpl();
void InitDefaultsUserSelectSkill();
void InitDefaultsUserSelectSkinImpl();
void InitDefaultsUserSelectSkin();
void InitDefaultsOnBattleCanceledImpl();
void InitDefaultsOnBattleCanceled();
void InitDefaultsOnBattleLoadingImpl();
void InitDefaultsOnBattleLoading();
void InitDefaultsOnBattleResultImpl();
void InitDefaultsOnBattleResult();
void InitDefaultsOnBattleResultDetailImpl();
void InitDefaultsOnBattleResultDetail();
void InitDefaultsPlayerSellItemImpl();
void InitDefaultsPlayerSellItem();
void InitDefaultsPlayerBuyItemImpl();
void InitDefaultsPlayerBuyItem();
void InitDefaultsOnPlayerFetchInputImpl();
void InitDefaultsOnPlayerFetchInput();
void InitDefaultsProtocolVerifyReqImpl();
void InitDefaultsProtocolVerifyReq();
void InitDefaultsProtocolVerifyRspImpl();
void InitDefaultsProtocolVerifyRsp();
void InitDefaultsRoomInfoImpl();
void InitDefaultsRoomInfo();
void InitDefaultsOnLeaveRoomRspImpl();
void InitDefaultsOnLeaveRoomRsp();
void InitDefaultsGetRoomRspImpl();
void InitDefaultsGetRoomRsp();
void InitDefaultsCreateRoomReqImpl();
void InitDefaultsCreateRoomReq();
void InitDefaultsCreateRoomRspImpl();
void InitDefaultsCreateRoomRsp();
void InitDefaultsJoinRoomReqImpl();
void InitDefaultsJoinRoomReq();
void InitDefaultsJoinRoomRspImpl();
void InitDefaultsJoinRoomRsp();
void InitDefaultsEnterLevelReqImpl();
void InitDefaultsEnterLevelReq();
void InitDefaultsEnterLevelRspImpl();
void InitDefaultsEnterLevelRsp();
void InitDefaultsOnEnterRoomRspImpl();
void InitDefaultsOnEnterRoomRsp();
void InitDefaultsOnEnterLevelRspImpl();
void InitDefaultsOnEnterLevelRsp();
void InitDefaultsVector2_Impl();
void InitDefaultsVector2_();
void InitDefaultsVector3_Impl();
void InitDefaultsVector3_();
void InitDefaultsQuaternion_Impl();
void InitDefaultsQuaternion_();
void InitDefaultsSceneInfoImpl();
void InitDefaultsSceneInfo();
void InitDefaultsSceneItem_Impl();
void InitDefaultsSceneItem_();
void InitDefaultsPlayer_Impl();
void InitDefaultsPlayer_();
void InitDefaultsInputReqImpl();
void InitDefaultsInputReq();
void InitDefaultsInput_Impl();
void InitDefaultsInput_();
void InitDefaultsTurnFramesImpl();
void InitDefaultsTurnFrames();
void InitDefaultsUserIdImpl();
void InitDefaultsUserId();
void InitDefaultsInputFrameImpl();
void InitDefaultsInputFrame();
void InitDefaultsChatMsgImpl();
void InitDefaultsChatMsg();
void InitDefaultsAudioChatMsgImpl();
void InitDefaultsAudioChatMsg();
inline void InitDefaults() {
  InitDefaultsMeteorMsg();
  InitDefaultsEnterQueueRsp();
  InitDefaultsOnBattleBegin();
  InitDefaultsUserSelectRole();
  InitDefaultsUserSelectSkill();
  InitDefaultsUserSelectSkin();
  InitDefaultsOnBattleCanceled();
  InitDefaultsOnBattleLoading();
  InitDefaultsOnBattleResult();
  InitDefaultsOnBattleResultDetail();
  InitDefaultsPlayerSellItem();
  InitDefaultsPlayerBuyItem();
  InitDefaultsOnPlayerFetchInput();
  InitDefaultsProtocolVerifyReq();
  InitDefaultsProtocolVerifyRsp();
  InitDefaultsRoomInfo();
  InitDefaultsOnLeaveRoomRsp();
  InitDefaultsGetRoomRsp();
  InitDefaultsCreateRoomReq();
  InitDefaultsCreateRoomRsp();
  InitDefaultsJoinRoomReq();
  InitDefaultsJoinRoomRsp();
  InitDefaultsEnterLevelReq();
  InitDefaultsEnterLevelRsp();
  InitDefaultsOnEnterRoomRsp();
  InitDefaultsOnEnterLevelRsp();
  InitDefaultsVector2_();
  InitDefaultsVector3_();
  InitDefaultsQuaternion_();
  InitDefaultsSceneInfo();
  InitDefaultsSceneItem_();
  InitDefaultsPlayer_();
  InitDefaultsInputReq();
  InitDefaultsInput_();
  InitDefaultsTurnFrames();
  InitDefaultsUserId();
  InitDefaultsInputFrame();
  InitDefaultsChatMsg();
  InitDefaultsAudioChatMsg();
}
}  // namespace protobuf_protocol_2eproto
class AudioChatMsg;
class AudioChatMsgDefaultTypeInternal;
extern AudioChatMsgDefaultTypeInternal _AudioChatMsg_default_instance_;
class ChatMsg;
class ChatMsgDefaultTypeInternal;
extern ChatMsgDefaultTypeInternal _ChatMsg_default_instance_;
class CreateRoomReq;
class CreateRoomReqDefaultTypeInternal;
extern CreateRoomReqDefaultTypeInternal _CreateRoomReq_default_instance_;
class CreateRoomRsp;
class CreateRoomRspDefaultTypeInternal;
extern CreateRoomRspDefaultTypeInternal _CreateRoomRsp_default_instance_;
class EnterLevelReq;
class EnterLevelReqDefaultTypeInternal;
extern EnterLevelReqDefaultTypeInternal _EnterLevelReq_default_instance_;
class EnterLevelRsp;
class EnterLevelRspDefaultTypeInternal;
extern EnterLevelRspDefaultTypeInternal _EnterLevelRsp_default_instance_;
class EnterQueueRsp;
class EnterQueueRspDefaultTypeInternal;
extern EnterQueueRspDefaultTypeInternal _EnterQueueRsp_default_instance_;
class GetRoomRsp;
class GetRoomRspDefaultTypeInternal;
extern GetRoomRspDefaultTypeInternal _GetRoomRsp_default_instance_;
class InputFrame;
class InputFrameDefaultTypeInternal;
extern InputFrameDefaultTypeInternal _InputFrame_default_instance_;
class InputReq;
class InputReqDefaultTypeInternal;
extern InputReqDefaultTypeInternal _InputReq_default_instance_;
class Input_;
class Input_DefaultTypeInternal;
extern Input_DefaultTypeInternal _Input__default_instance_;
class JoinRoomReq;
class JoinRoomReqDefaultTypeInternal;
extern JoinRoomReqDefaultTypeInternal _JoinRoomReq_default_instance_;
class JoinRoomRsp;
class JoinRoomRspDefaultTypeInternal;
extern JoinRoomRspDefaultTypeInternal _JoinRoomRsp_default_instance_;
class MeteorMsg;
class MeteorMsgDefaultTypeInternal;
extern MeteorMsgDefaultTypeInternal _MeteorMsg_default_instance_;
class OnBattleBegin;
class OnBattleBeginDefaultTypeInternal;
extern OnBattleBeginDefaultTypeInternal _OnBattleBegin_default_instance_;
class OnBattleCanceled;
class OnBattleCanceledDefaultTypeInternal;
extern OnBattleCanceledDefaultTypeInternal _OnBattleCanceled_default_instance_;
class OnBattleLoading;
class OnBattleLoadingDefaultTypeInternal;
extern OnBattleLoadingDefaultTypeInternal _OnBattleLoading_default_instance_;
class OnBattleResult;
class OnBattleResultDefaultTypeInternal;
extern OnBattleResultDefaultTypeInternal _OnBattleResult_default_instance_;
class OnBattleResultDetail;
class OnBattleResultDetailDefaultTypeInternal;
extern OnBattleResultDetailDefaultTypeInternal _OnBattleResultDetail_default_instance_;
class OnEnterLevelRsp;
class OnEnterLevelRspDefaultTypeInternal;
extern OnEnterLevelRspDefaultTypeInternal _OnEnterLevelRsp_default_instance_;
class OnEnterRoomRsp;
class OnEnterRoomRspDefaultTypeInternal;
extern OnEnterRoomRspDefaultTypeInternal _OnEnterRoomRsp_default_instance_;
class OnLeaveRoomRsp;
class OnLeaveRoomRspDefaultTypeInternal;
extern OnLeaveRoomRspDefaultTypeInternal _OnLeaveRoomRsp_default_instance_;
class OnPlayerFetchInput;
class OnPlayerFetchInputDefaultTypeInternal;
extern OnPlayerFetchInputDefaultTypeInternal _OnPlayerFetchInput_default_instance_;
class PlayerBuyItem;
class PlayerBuyItemDefaultTypeInternal;
extern PlayerBuyItemDefaultTypeInternal _PlayerBuyItem_default_instance_;
class PlayerSellItem;
class PlayerSellItemDefaultTypeInternal;
extern PlayerSellItemDefaultTypeInternal _PlayerSellItem_default_instance_;
class Player_;
class Player_DefaultTypeInternal;
extern Player_DefaultTypeInternal _Player__default_instance_;
class ProtocolVerifyReq;
class ProtocolVerifyReqDefaultTypeInternal;
extern ProtocolVerifyReqDefaultTypeInternal _ProtocolVerifyReq_default_instance_;
class ProtocolVerifyRsp;
class ProtocolVerifyRspDefaultTypeInternal;
extern ProtocolVerifyRspDefaultTypeInternal _ProtocolVerifyRsp_default_instance_;
class Quaternion_;
class Quaternion_DefaultTypeInternal;
extern Quaternion_DefaultTypeInternal _Quaternion__default_instance_;
class RoomInfo;
class RoomInfoDefaultTypeInternal;
extern RoomInfoDefaultTypeInternal _RoomInfo_default_instance_;
class SceneInfo;
class SceneInfoDefaultTypeInternal;
extern SceneInfoDefaultTypeInternal _SceneInfo_default_instance_;
class SceneItem_;
class SceneItem_DefaultTypeInternal;
extern SceneItem_DefaultTypeInternal _SceneItem__default_instance_;
class TurnFrames;
class TurnFramesDefaultTypeInternal;
extern TurnFramesDefaultTypeInternal _TurnFrames_default_instance_;
class UserId;
class UserIdDefaultTypeInternal;
extern UserIdDefaultTypeInternal _UserId_default_instance_;
class UserSelectRole;
class UserSelectRoleDefaultTypeInternal;
extern UserSelectRoleDefaultTypeInternal _UserSelectRole_default_instance_;
class UserSelectSkill;
class UserSelectSkillDefaultTypeInternal;
extern UserSelectSkillDefaultTypeInternal _UserSelectSkill_default_instance_;
class UserSelectSkin;
class UserSelectSkinDefaultTypeInternal;
extern UserSelectSkinDefaultTypeInternal _UserSelectSkin_default_instance_;
class Vector2_;
class Vector2_DefaultTypeInternal;
extern Vector2_DefaultTypeInternal _Vector2__default_instance_;
class Vector3_;
class Vector3_DefaultTypeInternal;
extern Vector3_DefaultTypeInternal _Vector3__default_instance_;

enum MeteorMsg_MsgType {
  MeteorMsg_MsgType_ProtocolVerify = 10,
  MeteorMsg_MsgType_GetRoomReq = 100,
  MeteorMsg_MsgType_GetRoomRsp = 101,
  MeteorMsg_MsgType_CreateRoomReq = 102,
  MeteorMsg_MsgType_CreateRoomRsp = 103,
  MeteorMsg_MsgType_JoinRoomReq = 104,
  MeteorMsg_MsgType_JoinRoomRsp = 105,
  MeteorMsg_MsgType_OnJoinRoomRsp = 106,
  MeteorMsg_MsgType_EnterLevelReq = 107,
  MeteorMsg_MsgType_EnterLevelRsp = 108,
  MeteorMsg_MsgType_OnEnterLevelRsp = 109,
  MeteorMsg_MsgType_LeaveRoomReq = 110,
  MeteorMsg_MsgType_LeaveRoomRsp = 119,
  MeteorMsg_MsgType_OnLeaveRoomRsp = 111,
  MeteorMsg_MsgType_SyncTurnReq = 112,
  MeteorMsg_MsgType_SyncTurnRsp = 113,
  MeteorMsg_MsgType_KeyFrameReq = 114,
  MeteorMsg_MsgType_SyncKeyFrame = 115,
  MeteorMsg_MsgType_UserDeadSB2C = 116,
  MeteorMsg_MsgType_UserRebornReq = 117,
  MeteorMsg_MsgType_UserRebornSB2C = 118,
  MeteorMsg_MsgType_ChatInRoomReq = 120,
  MeteorMsg_MsgType_ChatInRoomRsp = 121,
  MeteorMsg_MsgType_ChatInLobbyReq = 122,
  MeteorMsg_MsgType_ChatInLobbyRsp = 123,
  MeteorMsg_MsgType_EnterQueueReq = 124,
  MeteorMsg_MsgType_EnterQueueRsp = 125,
  MeteorMsg_MsgType_ExitQueueReq = 126,
  MeteorMsg_MsgType_QueueMsgWaitReady = 127,
  MeteorMsg_MsgType_QueueMsgCanceled = 128,
  MeteorMsg_MsgType_QueueMsgReadyReq = 129,
  MeteorMsg_MsgType_OnBattleBegin = 130,
  MeteorMsg_MsgType_OnBattleCancel = 131,
  MeteorMsg_MsgType_UserSelectRole = 132,
  MeteorMsg_MsgType_OnUserSelectRole = 133,
  MeteorMsg_MsgType_UserSelectSkill = 134,
  MeteorMsg_MsgType_OnUserSelectSkill = 135,
  MeteorMsg_MsgType_UserSelectSkin = 136,
  MeteorMsg_MsgType_OnUserSelectSkin = 137,
  MeteorMsg_MsgType_UserQuit = 138,
  MeteorMsg_MsgType_OnBattleEnterLevel = 139,
  MeteorMsg_MsgType_OnBattleLoading = 140,
  MeteorMsg_MsgType_OnBattleStart = 141,
  MeteorMsg_MsgType_OnBattleResult = 142,
  MeteorMsg_MsgType_OnBattleResultDetail = 143,
  MeteorMsg_MsgType_OnPlayerSellItem = 144,
  MeteorMsg_MsgType_OnPlayerBuyItem = 145,
  MeteorMsg_MsgType_OnPlayerQuit = 146,
  MeteorMsg_MsgType_OnPlayerReStart = 147,
  MeteorMsg_MsgType_OnPlayerFetchInput = 148,
  MeteorMsg_MsgType_OnPlayerReConnect = 149,
  MeteorMsg_MsgType_AudioChat = 150
};
bool MeteorMsg_MsgType_IsValid(int value);
const MeteorMsg_MsgType MeteorMsg_MsgType_MsgType_MIN = MeteorMsg_MsgType_ProtocolVerify;
const MeteorMsg_MsgType MeteorMsg_MsgType_MsgType_MAX = MeteorMsg_MsgType_AudioChat;
const int MeteorMsg_MsgType_MsgType_ARRAYSIZE = MeteorMsg_MsgType_MsgType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MeteorMsg_MsgType_descriptor();
inline const ::std::string& MeteorMsg_MsgType_Name(MeteorMsg_MsgType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MeteorMsg_MsgType_descriptor(), value);
}
inline bool MeteorMsg_MsgType_Parse(
    const ::std::string& name, MeteorMsg_MsgType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MeteorMsg_MsgType>(
    MeteorMsg_MsgType_descriptor(), name, value);
}
enum RoomInfo_RoomRule {
  RoomInfo_RoomRule_MZ = 1,
  RoomInfo_RoomRule_ROB = 2,
  RoomInfo_RoomRule_Defence = 3,
  RoomInfo_RoomRule_KillTarget = 4,
  RoomInfo_RoomRule_Endless = 5,
  RoomInfo_RoomRule_Normal = 6,
  RoomInfo_RoomRule_Story = 7,
  RoomInfo_RoomRule_Moba = 8
};
bool RoomInfo_RoomRule_IsValid(int value);
const RoomInfo_RoomRule RoomInfo_RoomRule_RoomRule_MIN = RoomInfo_RoomRule_MZ;
const RoomInfo_RoomRule RoomInfo_RoomRule_RoomRule_MAX = RoomInfo_RoomRule_Moba;
const int RoomInfo_RoomRule_RoomRule_ARRAYSIZE = RoomInfo_RoomRule_RoomRule_MAX + 1;

const ::google::protobuf::EnumDescriptor* RoomInfo_RoomRule_descriptor();
inline const ::std::string& RoomInfo_RoomRule_Name(RoomInfo_RoomRule value) {
  return ::google::protobuf::internal::NameOfEnum(
    RoomInfo_RoomRule_descriptor(), value);
}
inline bool RoomInfo_RoomRule_Parse(
    const ::std::string& name, RoomInfo_RoomRule* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoomInfo_RoomRule>(
    RoomInfo_RoomRule_descriptor(), name, value);
}
enum RoomInfo_RoomPattern {
  RoomInfo_RoomPattern__Normal = 1,
  RoomInfo_RoomPattern__Replay = 2
};
bool RoomInfo_RoomPattern_IsValid(int value);
const RoomInfo_RoomPattern RoomInfo_RoomPattern_RoomPattern_MIN = RoomInfo_RoomPattern__Normal;
const RoomInfo_RoomPattern RoomInfo_RoomPattern_RoomPattern_MAX = RoomInfo_RoomPattern__Replay;
const int RoomInfo_RoomPattern_RoomPattern_ARRAYSIZE = RoomInfo_RoomPattern_RoomPattern_MAX + 1;

const ::google::protobuf::EnumDescriptor* RoomInfo_RoomPattern_descriptor();
inline const ::std::string& RoomInfo_RoomPattern_Name(RoomInfo_RoomPattern value) {
  return ::google::protobuf::internal::NameOfEnum(
    RoomInfo_RoomPattern_descriptor(), value);
}
inline bool RoomInfo_RoomPattern_Parse(
    const ::std::string& name, RoomInfo_RoomPattern* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoomInfo_RoomPattern>(
    RoomInfo_RoomPattern_descriptor(), name, value);
}
// ===================================================================

class MeteorMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MeteorMsg) */ {
 public:
  MeteorMsg();
  virtual ~MeteorMsg();

  MeteorMsg(const MeteorMsg& from);

  inline MeteorMsg& operator=(const MeteorMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MeteorMsg(MeteorMsg&& from) noexcept
    : MeteorMsg() {
    *this = ::std::move(from);
  }

  inline MeteorMsg& operator=(MeteorMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MeteorMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MeteorMsg* internal_default_instance() {
    return reinterpret_cast<const MeteorMsg*>(
               &_MeteorMsg_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(MeteorMsg* other);
  friend void swap(MeteorMsg& a, MeteorMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MeteorMsg* New() const PROTOBUF_FINAL { return New(NULL); }

  MeteorMsg* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MeteorMsg& from);
  void MergeFrom(const MeteorMsg& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MeteorMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef MeteorMsg_MsgType MsgType;
  static const MsgType ProtocolVerify =
    MeteorMsg_MsgType_ProtocolVerify;
  static const MsgType GetRoomReq =
    MeteorMsg_MsgType_GetRoomReq;
  static const MsgType GetRoomRsp =
    MeteorMsg_MsgType_GetRoomRsp;
  static const MsgType CreateRoomReq =
    MeteorMsg_MsgType_CreateRoomReq;
  static const MsgType CreateRoomRsp =
    MeteorMsg_MsgType_CreateRoomRsp;
  static const MsgType JoinRoomReq =
    MeteorMsg_MsgType_JoinRoomReq;
  static const MsgType JoinRoomRsp =
    MeteorMsg_MsgType_JoinRoomRsp;
  static const MsgType OnJoinRoomRsp =
    MeteorMsg_MsgType_OnJoinRoomRsp;
  static const MsgType EnterLevelReq =
    MeteorMsg_MsgType_EnterLevelReq;
  static const MsgType EnterLevelRsp =
    MeteorMsg_MsgType_EnterLevelRsp;
  static const MsgType OnEnterLevelRsp =
    MeteorMsg_MsgType_OnEnterLevelRsp;
  static const MsgType LeaveRoomReq =
    MeteorMsg_MsgType_LeaveRoomReq;
  static const MsgType LeaveRoomRsp =
    MeteorMsg_MsgType_LeaveRoomRsp;
  static const MsgType OnLeaveRoomRsp =
    MeteorMsg_MsgType_OnLeaveRoomRsp;
  static const MsgType SyncTurnReq =
    MeteorMsg_MsgType_SyncTurnReq;
  static const MsgType SyncTurnRsp =
    MeteorMsg_MsgType_SyncTurnRsp;
  static const MsgType KeyFrameReq =
    MeteorMsg_MsgType_KeyFrameReq;
  static const MsgType SyncKeyFrame =
    MeteorMsg_MsgType_SyncKeyFrame;
  static const MsgType UserDeadSB2C =
    MeteorMsg_MsgType_UserDeadSB2C;
  static const MsgType UserRebornReq =
    MeteorMsg_MsgType_UserRebornReq;
  static const MsgType UserRebornSB2C =
    MeteorMsg_MsgType_UserRebornSB2C;
  static const MsgType ChatInRoomReq =
    MeteorMsg_MsgType_ChatInRoomReq;
  static const MsgType ChatInRoomRsp =
    MeteorMsg_MsgType_ChatInRoomRsp;
  static const MsgType ChatInLobbyReq =
    MeteorMsg_MsgType_ChatInLobbyReq;
  static const MsgType ChatInLobbyRsp =
    MeteorMsg_MsgType_ChatInLobbyRsp;
  static const MsgType EnterQueueReq =
    MeteorMsg_MsgType_EnterQueueReq;
  static const MsgType EnterQueueRsp =
    MeteorMsg_MsgType_EnterQueueRsp;
  static const MsgType ExitQueueReq =
    MeteorMsg_MsgType_ExitQueueReq;
  static const MsgType QueueMsgWaitReady =
    MeteorMsg_MsgType_QueueMsgWaitReady;
  static const MsgType QueueMsgCanceled =
    MeteorMsg_MsgType_QueueMsgCanceled;
  static const MsgType QueueMsgReadyReq =
    MeteorMsg_MsgType_QueueMsgReadyReq;
  static const MsgType OnBattleBegin =
    MeteorMsg_MsgType_OnBattleBegin;
  static const MsgType OnBattleCancel =
    MeteorMsg_MsgType_OnBattleCancel;
  static const MsgType UserSelectRole =
    MeteorMsg_MsgType_UserSelectRole;
  static const MsgType OnUserSelectRole =
    MeteorMsg_MsgType_OnUserSelectRole;
  static const MsgType UserSelectSkill =
    MeteorMsg_MsgType_UserSelectSkill;
  static const MsgType OnUserSelectSkill =
    MeteorMsg_MsgType_OnUserSelectSkill;
  static const MsgType UserSelectSkin =
    MeteorMsg_MsgType_UserSelectSkin;
  static const MsgType OnUserSelectSkin =
    MeteorMsg_MsgType_OnUserSelectSkin;
  static const MsgType UserQuit =
    MeteorMsg_MsgType_UserQuit;
  static const MsgType OnBattleEnterLevel =
    MeteorMsg_MsgType_OnBattleEnterLevel;
  static const MsgType OnBattleLoading =
    MeteorMsg_MsgType_OnBattleLoading;
  static const MsgType OnBattleStart =
    MeteorMsg_MsgType_OnBattleStart;
  static const MsgType OnBattleResult =
    MeteorMsg_MsgType_OnBattleResult;
  static const MsgType OnBattleResultDetail =
    MeteorMsg_MsgType_OnBattleResultDetail;
  static const MsgType OnPlayerSellItem =
    MeteorMsg_MsgType_OnPlayerSellItem;
  static const MsgType OnPlayerBuyItem =
    MeteorMsg_MsgType_OnPlayerBuyItem;
  static const MsgType OnPlayerQuit =
    MeteorMsg_MsgType_OnPlayerQuit;
  static const MsgType OnPlayerReStart =
    MeteorMsg_MsgType_OnPlayerReStart;
  static const MsgType OnPlayerFetchInput =
    MeteorMsg_MsgType_OnPlayerFetchInput;
  static const MsgType OnPlayerReConnect =
    MeteorMsg_MsgType_OnPlayerReConnect;
  static const MsgType AudioChat =
    MeteorMsg_MsgType_AudioChat;
  static inline bool MsgType_IsValid(int value) {
    return MeteorMsg_MsgType_IsValid(value);
  }
  static const MsgType MsgType_MIN =
    MeteorMsg_MsgType_MsgType_MIN;
  static const MsgType MsgType_MAX =
    MeteorMsg_MsgType_MsgType_MAX;
  static const int MsgType_ARRAYSIZE =
    MeteorMsg_MsgType_MsgType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MsgType_descriptor() {
    return MeteorMsg_MsgType_descriptor();
  }
  static inline const ::std::string& MsgType_Name(MsgType value) {
    return MeteorMsg_MsgType_Name(value);
  }
  static inline bool MsgType_Parse(const ::std::string& name,
      MsgType* value) {
    return MeteorMsg_MsgType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .MeteorMsg.MsgType cmd = 1;
  bool has_cmd() const;
  void clear_cmd();
  static const int kCmdFieldNumber = 1;
  ::MeteorMsg_MsgType cmd() const;
  void set_cmd(::MeteorMsg_MsgType value);

  // @@protoc_insertion_point(class_scope:MeteorMsg)
 private:
  void set_has_cmd();
  void clear_has_cmd();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int cmd_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsMeteorMsgImpl();
};
// -------------------------------------------------------------------

class EnterQueueRsp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:EnterQueueRsp) */ {
 public:
  EnterQueueRsp();
  virtual ~EnterQueueRsp();

  EnterQueueRsp(const EnterQueueRsp& from);

  inline EnterQueueRsp& operator=(const EnterQueueRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EnterQueueRsp(EnterQueueRsp&& from) noexcept
    : EnterQueueRsp() {
    *this = ::std::move(from);
  }

  inline EnterQueueRsp& operator=(EnterQueueRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnterQueueRsp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EnterQueueRsp* internal_default_instance() {
    return reinterpret_cast<const EnterQueueRsp*>(
               &_EnterQueueRsp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(EnterQueueRsp* other);
  friend void swap(EnterQueueRsp& a, EnterQueueRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EnterQueueRsp* New() const PROTOBUF_FINAL { return New(NULL); }

  EnterQueueRsp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EnterQueueRsp& from);
  void MergeFrom(const EnterQueueRsp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EnterQueueRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 result = 1;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::google::protobuf::uint32 result() const;
  void set_result(::google::protobuf::uint32 value);

  // required uint32 playerId = 2;
  bool has_playerid() const;
  void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  ::google::protobuf::uint32 playerid() const;
  void set_playerid(::google::protobuf::uint32 value);

  // required uint32 playerInQueue = 3;
  bool has_playerinqueue() const;
  void clear_playerinqueue();
  static const int kPlayerInQueueFieldNumber = 3;
  ::google::protobuf::uint32 playerinqueue() const;
  void set_playerinqueue(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:EnterQueueRsp)
 private:
  void set_has_result();
  void clear_has_result();
  void set_has_playerid();
  void clear_has_playerid();
  void set_has_playerinqueue();
  void clear_has_playerinqueue();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 result_;
  ::google::protobuf::uint32 playerid_;
  ::google::protobuf::uint32 playerinqueue_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsEnterQueueRspImpl();
};
// -------------------------------------------------------------------

class OnBattleBegin : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OnBattleBegin) */ {
 public:
  OnBattleBegin();
  virtual ~OnBattleBegin();

  OnBattleBegin(const OnBattleBegin& from);

  inline OnBattleBegin& operator=(const OnBattleBegin& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OnBattleBegin(OnBattleBegin&& from) noexcept
    : OnBattleBegin() {
    *this = ::std::move(from);
  }

  inline OnBattleBegin& operator=(OnBattleBegin&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OnBattleBegin& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OnBattleBegin* internal_default_instance() {
    return reinterpret_cast<const OnBattleBegin*>(
               &_OnBattleBegin_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(OnBattleBegin* other);
  friend void swap(OnBattleBegin& a, OnBattleBegin& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OnBattleBegin* New() const PROTOBUF_FINAL { return New(NULL); }

  OnBattleBegin* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OnBattleBegin& from);
  void MergeFrom(const OnBattleBegin& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OnBattleBegin* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 TeamMemberAId = 1;
  int teammemberaid_size() const;
  void clear_teammemberaid();
  static const int kTeamMemberAIdFieldNumber = 1;
  ::google::protobuf::uint32 teammemberaid(int index) const;
  void set_teammemberaid(int index, ::google::protobuf::uint32 value);
  void add_teammemberaid(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      teammemberaid() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_teammemberaid();

  // repeated uint32 TeamMemberBId = 2;
  int teammemberbid_size() const;
  void clear_teammemberbid();
  static const int kTeamMemberBIdFieldNumber = 2;
  ::google::protobuf::uint32 teammemberbid(int index) const;
  void set_teammemberbid(int index, ::google::protobuf::uint32 value);
  void add_teammemberbid(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      teammemberbid() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_teammemberbid();

  // repeated string TeamMemberA = 3;
  int teammembera_size() const;
  void clear_teammembera();
  static const int kTeamMemberAFieldNumber = 3;
  const ::std::string& teammembera(int index) const;
  ::std::string* mutable_teammembera(int index);
  void set_teammembera(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_teammembera(int index, ::std::string&& value);
  #endif
  void set_teammembera(int index, const char* value);
  void set_teammembera(int index, const char* value, size_t size);
  ::std::string* add_teammembera();
  void add_teammembera(const ::std::string& value);
  #if LANG_CXX11
  void add_teammembera(::std::string&& value);
  #endif
  void add_teammembera(const char* value);
  void add_teammembera(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& teammembera() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_teammembera();

  // repeated string TeamMemberB = 4;
  int teammemberb_size() const;
  void clear_teammemberb();
  static const int kTeamMemberBFieldNumber = 4;
  const ::std::string& teammemberb(int index) const;
  ::std::string* mutable_teammemberb(int index);
  void set_teammemberb(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_teammemberb(int index, ::std::string&& value);
  #endif
  void set_teammemberb(int index, const char* value);
  void set_teammemberb(int index, const char* value, size_t size);
  ::std::string* add_teammemberb();
  void add_teammemberb(const ::std::string& value);
  #if LANG_CXX11
  void add_teammemberb(::std::string&& value);
  #endif
  void add_teammemberb(const char* value);
  void add_teammemberb(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& teammemberb() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_teammemberb();

  // @@protoc_insertion_point(class_scope:OnBattleBegin)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > teammemberaid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > teammemberbid_;
  ::google::protobuf::RepeatedPtrField< ::std::string> teammembera_;
  ::google::protobuf::RepeatedPtrField< ::std::string> teammemberb_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsOnBattleBeginImpl();
};
// -------------------------------------------------------------------

class UserSelectRole : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:UserSelectRole) */ {
 public:
  UserSelectRole();
  virtual ~UserSelectRole();

  UserSelectRole(const UserSelectRole& from);

  inline UserSelectRole& operator=(const UserSelectRole& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserSelectRole(UserSelectRole&& from) noexcept
    : UserSelectRole() {
    *this = ::std::move(from);
  }

  inline UserSelectRole& operator=(UserSelectRole&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserSelectRole& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserSelectRole* internal_default_instance() {
    return reinterpret_cast<const UserSelectRole*>(
               &_UserSelectRole_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(UserSelectRole* other);
  friend void swap(UserSelectRole& a, UserSelectRole& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserSelectRole* New() const PROTOBUF_FINAL { return New(NULL); }

  UserSelectRole* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UserSelectRole& from);
  void MergeFrom(const UserSelectRole& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UserSelectRole* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 playerId = 1;
  bool has_playerid() const;
  void clear_playerid();
  static const int kPlayerIdFieldNumber = 1;
  ::google::protobuf::uint32 playerid() const;
  void set_playerid(::google::protobuf::uint32 value);

  // required uint32 HeroId = 2;
  bool has_heroid() const;
  void clear_heroid();
  static const int kHeroIdFieldNumber = 2;
  ::google::protobuf::uint32 heroid() const;
  void set_heroid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:UserSelectRole)
 private:
  void set_has_playerid();
  void clear_has_playerid();
  void set_has_heroid();
  void clear_has_heroid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 playerid_;
  ::google::protobuf::uint32 heroid_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsUserSelectRoleImpl();
};
// -------------------------------------------------------------------

class UserSelectSkill : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:UserSelectSkill) */ {
 public:
  UserSelectSkill();
  virtual ~UserSelectSkill();

  UserSelectSkill(const UserSelectSkill& from);

  inline UserSelectSkill& operator=(const UserSelectSkill& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserSelectSkill(UserSelectSkill&& from) noexcept
    : UserSelectSkill() {
    *this = ::std::move(from);
  }

  inline UserSelectSkill& operator=(UserSelectSkill&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserSelectSkill& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserSelectSkill* internal_default_instance() {
    return reinterpret_cast<const UserSelectSkill*>(
               &_UserSelectSkill_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(UserSelectSkill* other);
  friend void swap(UserSelectSkill& a, UserSelectSkill& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserSelectSkill* New() const PROTOBUF_FINAL { return New(NULL); }

  UserSelectSkill* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UserSelectSkill& from);
  void MergeFrom(const UserSelectSkill& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UserSelectSkill* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 playerId = 1;
  bool has_playerid() const;
  void clear_playerid();
  static const int kPlayerIdFieldNumber = 1;
  ::google::protobuf::uint32 playerid() const;
  void set_playerid(::google::protobuf::uint32 value);

  // required uint32 SkillId = 2;
  bool has_skillid() const;
  void clear_skillid();
  static const int kSkillIdFieldNumber = 2;
  ::google::protobuf::uint32 skillid() const;
  void set_skillid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:UserSelectSkill)
 private:
  void set_has_playerid();
  void clear_has_playerid();
  void set_has_skillid();
  void clear_has_skillid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 playerid_;
  ::google::protobuf::uint32 skillid_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsUserSelectSkillImpl();
};
// -------------------------------------------------------------------

class UserSelectSkin : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:UserSelectSkin) */ {
 public:
  UserSelectSkin();
  virtual ~UserSelectSkin();

  UserSelectSkin(const UserSelectSkin& from);

  inline UserSelectSkin& operator=(const UserSelectSkin& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserSelectSkin(UserSelectSkin&& from) noexcept
    : UserSelectSkin() {
    *this = ::std::move(from);
  }

  inline UserSelectSkin& operator=(UserSelectSkin&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserSelectSkin& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserSelectSkin* internal_default_instance() {
    return reinterpret_cast<const UserSelectSkin*>(
               &_UserSelectSkin_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(UserSelectSkin* other);
  friend void swap(UserSelectSkin& a, UserSelectSkin& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserSelectSkin* New() const PROTOBUF_FINAL { return New(NULL); }

  UserSelectSkin* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UserSelectSkin& from);
  void MergeFrom(const UserSelectSkin& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UserSelectSkin* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 playerId = 1;
  bool has_playerid() const;
  void clear_playerid();
  static const int kPlayerIdFieldNumber = 1;
  ::google::protobuf::uint32 playerid() const;
  void set_playerid(::google::protobuf::uint32 value);

  // required uint32 Skin = 2;
  bool has_skin() const;
  void clear_skin();
  static const int kSkinFieldNumber = 2;
  ::google::protobuf::uint32 skin() const;
  void set_skin(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:UserSelectSkin)
 private:
  void set_has_playerid();
  void clear_has_playerid();
  void set_has_skin();
  void clear_has_skin();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 playerid_;
  ::google::protobuf::uint32 skin_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsUserSelectSkinImpl();
};
// -------------------------------------------------------------------

class OnBattleCanceled : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OnBattleCanceled) */ {
 public:
  OnBattleCanceled();
  virtual ~OnBattleCanceled();

  OnBattleCanceled(const OnBattleCanceled& from);

  inline OnBattleCanceled& operator=(const OnBattleCanceled& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OnBattleCanceled(OnBattleCanceled&& from) noexcept
    : OnBattleCanceled() {
    *this = ::std::move(from);
  }

  inline OnBattleCanceled& operator=(OnBattleCanceled&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OnBattleCanceled& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OnBattleCanceled* internal_default_instance() {
    return reinterpret_cast<const OnBattleCanceled*>(
               &_OnBattleCanceled_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(OnBattleCanceled* other);
  friend void swap(OnBattleCanceled& a, OnBattleCanceled& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OnBattleCanceled* New() const PROTOBUF_FINAL { return New(NULL); }

  OnBattleCanceled* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OnBattleCanceled& from);
  void MergeFrom(const OnBattleCanceled& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OnBattleCanceled* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 reason = 1;
  bool has_reason() const;
  void clear_reason();
  static const int kReasonFieldNumber = 1;
  ::google::protobuf::uint32 reason() const;
  void set_reason(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:OnBattleCanceled)
 private:
  void set_has_reason();
  void clear_has_reason();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 reason_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsOnBattleCanceledImpl();
};
// -------------------------------------------------------------------

class OnBattleLoading : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OnBattleLoading) */ {
 public:
  OnBattleLoading();
  virtual ~OnBattleLoading();

  OnBattleLoading(const OnBattleLoading& from);

  inline OnBattleLoading& operator=(const OnBattleLoading& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OnBattleLoading(OnBattleLoading&& from) noexcept
    : OnBattleLoading() {
    *this = ::std::move(from);
  }

  inline OnBattleLoading& operator=(OnBattleLoading&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OnBattleLoading& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OnBattleLoading* internal_default_instance() {
    return reinterpret_cast<const OnBattleLoading*>(
               &_OnBattleLoading_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(OnBattleLoading* other);
  friend void swap(OnBattleLoading& a, OnBattleLoading& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OnBattleLoading* New() const PROTOBUF_FINAL { return New(NULL); }

  OnBattleLoading* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OnBattleLoading& from);
  void MergeFrom(const OnBattleLoading& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OnBattleLoading* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 playerId = 1;
  int playerid_size() const;
  void clear_playerid();
  static const int kPlayerIdFieldNumber = 1;
  ::google::protobuf::uint32 playerid(int index) const;
  void set_playerid(int index, ::google::protobuf::uint32 value);
  void add_playerid(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      playerid() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_playerid();

  // repeated uint32 percent = 2;
  int percent_size() const;
  void clear_percent();
  static const int kPercentFieldNumber = 2;
  ::google::protobuf::uint32 percent(int index) const;
  void set_percent(int index, ::google::protobuf::uint32 value);
  void add_percent(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      percent() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_percent();

  // @@protoc_insertion_point(class_scope:OnBattleLoading)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > playerid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > percent_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsOnBattleLoadingImpl();
};
// -------------------------------------------------------------------

class OnBattleResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OnBattleResult) */ {
 public:
  OnBattleResult();
  virtual ~OnBattleResult();

  OnBattleResult(const OnBattleResult& from);

  inline OnBattleResult& operator=(const OnBattleResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OnBattleResult(OnBattleResult&& from) noexcept
    : OnBattleResult() {
    *this = ::std::move(from);
  }

  inline OnBattleResult& operator=(OnBattleResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OnBattleResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OnBattleResult* internal_default_instance() {
    return reinterpret_cast<const OnBattleResult*>(
               &_OnBattleResult_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(OnBattleResult* other);
  friend void swap(OnBattleResult& a, OnBattleResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OnBattleResult* New() const PROTOBUF_FINAL { return New(NULL); }

  OnBattleResult* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OnBattleResult& from);
  void MergeFrom(const OnBattleResult& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OnBattleResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 result = 1;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::google::protobuf::uint32 result() const;
  void set_result(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:OnBattleResult)
 private:
  void set_has_result();
  void clear_has_result();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 result_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsOnBattleResultImpl();
};
// -------------------------------------------------------------------

class OnBattleResultDetail : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OnBattleResultDetail) */ {
 public:
  OnBattleResultDetail();
  virtual ~OnBattleResultDetail();

  OnBattleResultDetail(const OnBattleResultDetail& from);

  inline OnBattleResultDetail& operator=(const OnBattleResultDetail& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OnBattleResultDetail(OnBattleResultDetail&& from) noexcept
    : OnBattleResultDetail() {
    *this = ::std::move(from);
  }

  inline OnBattleResultDetail& operator=(OnBattleResultDetail&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OnBattleResultDetail& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OnBattleResultDetail* internal_default_instance() {
    return reinterpret_cast<const OnBattleResultDetail*>(
               &_OnBattleResultDetail_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(OnBattleResultDetail* other);
  friend void swap(OnBattleResultDetail& a, OnBattleResultDetail& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OnBattleResultDetail* New() const PROTOBUF_FINAL { return New(NULL); }

  OnBattleResultDetail* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OnBattleResultDetail& from);
  void MergeFrom(const OnBattleResultDetail& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OnBattleResultDetail* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:OnBattleResultDetail)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsOnBattleResultDetailImpl();
};
// -------------------------------------------------------------------

class PlayerSellItem : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PlayerSellItem) */ {
 public:
  PlayerSellItem();
  virtual ~PlayerSellItem();

  PlayerSellItem(const PlayerSellItem& from);

  inline PlayerSellItem& operator=(const PlayerSellItem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayerSellItem(PlayerSellItem&& from) noexcept
    : PlayerSellItem() {
    *this = ::std::move(from);
  }

  inline PlayerSellItem& operator=(PlayerSellItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerSellItem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerSellItem* internal_default_instance() {
    return reinterpret_cast<const PlayerSellItem*>(
               &_PlayerSellItem_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(PlayerSellItem* other);
  friend void swap(PlayerSellItem& a, PlayerSellItem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayerSellItem* New() const PROTOBUF_FINAL { return New(NULL); }

  PlayerSellItem* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PlayerSellItem& from);
  void MergeFrom(const PlayerSellItem& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PlayerSellItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 playerId = 1;
  bool has_playerid() const;
  void clear_playerid();
  static const int kPlayerIdFieldNumber = 1;
  ::google::protobuf::uint32 playerid() const;
  void set_playerid(::google::protobuf::uint32 value);

  // required uint32 itemId = 2;
  bool has_itemid() const;
  void clear_itemid();
  static const int kItemIdFieldNumber = 2;
  ::google::protobuf::uint32 itemid() const;
  void set_itemid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:PlayerSellItem)
 private:
  void set_has_playerid();
  void clear_has_playerid();
  void set_has_itemid();
  void clear_has_itemid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 playerid_;
  ::google::protobuf::uint32 itemid_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsPlayerSellItemImpl();
};
// -------------------------------------------------------------------

class PlayerBuyItem : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PlayerBuyItem) */ {
 public:
  PlayerBuyItem();
  virtual ~PlayerBuyItem();

  PlayerBuyItem(const PlayerBuyItem& from);

  inline PlayerBuyItem& operator=(const PlayerBuyItem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayerBuyItem(PlayerBuyItem&& from) noexcept
    : PlayerBuyItem() {
    *this = ::std::move(from);
  }

  inline PlayerBuyItem& operator=(PlayerBuyItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerBuyItem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerBuyItem* internal_default_instance() {
    return reinterpret_cast<const PlayerBuyItem*>(
               &_PlayerBuyItem_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(PlayerBuyItem* other);
  friend void swap(PlayerBuyItem& a, PlayerBuyItem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayerBuyItem* New() const PROTOBUF_FINAL { return New(NULL); }

  PlayerBuyItem* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PlayerBuyItem& from);
  void MergeFrom(const PlayerBuyItem& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PlayerBuyItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 playerId = 1;
  bool has_playerid() const;
  void clear_playerid();
  static const int kPlayerIdFieldNumber = 1;
  ::google::protobuf::uint32 playerid() const;
  void set_playerid(::google::protobuf::uint32 value);

  // required uint32 itemId = 2;
  bool has_itemid() const;
  void clear_itemid();
  static const int kItemIdFieldNumber = 2;
  ::google::protobuf::uint32 itemid() const;
  void set_itemid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:PlayerBuyItem)
 private:
  void set_has_playerid();
  void clear_has_playerid();
  void set_has_itemid();
  void clear_has_itemid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 playerid_;
  ::google::protobuf::uint32 itemid_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsPlayerBuyItemImpl();
};
// -------------------------------------------------------------------

class OnPlayerFetchInput : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OnPlayerFetchInput) */ {
 public:
  OnPlayerFetchInput();
  virtual ~OnPlayerFetchInput();

  OnPlayerFetchInput(const OnPlayerFetchInput& from);

  inline OnPlayerFetchInput& operator=(const OnPlayerFetchInput& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OnPlayerFetchInput(OnPlayerFetchInput&& from) noexcept
    : OnPlayerFetchInput() {
    *this = ::std::move(from);
  }

  inline OnPlayerFetchInput& operator=(OnPlayerFetchInput&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OnPlayerFetchInput& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OnPlayerFetchInput* internal_default_instance() {
    return reinterpret_cast<const OnPlayerFetchInput*>(
               &_OnPlayerFetchInput_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(OnPlayerFetchInput* other);
  friend void swap(OnPlayerFetchInput& a, OnPlayerFetchInput& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OnPlayerFetchInput* New() const PROTOBUF_FINAL { return New(NULL); }

  OnPlayerFetchInput* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OnPlayerFetchInput& from);
  void MergeFrom(const OnPlayerFetchInput& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OnPlayerFetchInput* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .TurnFrames frames = 1;
  int frames_size() const;
  void clear_frames();
  static const int kFramesFieldNumber = 1;
  const ::TurnFrames& frames(int index) const;
  ::TurnFrames* mutable_frames(int index);
  ::TurnFrames* add_frames();
  ::google::protobuf::RepeatedPtrField< ::TurnFrames >*
      mutable_frames();
  const ::google::protobuf::RepeatedPtrField< ::TurnFrames >&
      frames() const;

  // @@protoc_insertion_point(class_scope:OnPlayerFetchInput)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::TurnFrames > frames_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsOnPlayerFetchInputImpl();
};
// -------------------------------------------------------------------

class ProtocolVerifyReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ProtocolVerifyReq) */ {
 public:
  ProtocolVerifyReq();
  virtual ~ProtocolVerifyReq();

  ProtocolVerifyReq(const ProtocolVerifyReq& from);

  inline ProtocolVerifyReq& operator=(const ProtocolVerifyReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtocolVerifyReq(ProtocolVerifyReq&& from) noexcept
    : ProtocolVerifyReq() {
    *this = ::std::move(from);
  }

  inline ProtocolVerifyReq& operator=(ProtocolVerifyReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtocolVerifyReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtocolVerifyReq* internal_default_instance() {
    return reinterpret_cast<const ProtocolVerifyReq*>(
               &_ProtocolVerifyReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(ProtocolVerifyReq* other);
  friend void swap(ProtocolVerifyReq& a, ProtocolVerifyReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtocolVerifyReq* New() const PROTOBUF_FINAL { return New(NULL); }

  ProtocolVerifyReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ProtocolVerifyReq& from);
  void MergeFrom(const ProtocolVerifyReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ProtocolVerifyReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string data = 2;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const char* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // required uint32 protocol = 1;
  bool has_protocol() const;
  void clear_protocol();
  static const int kProtocolFieldNumber = 1;
  ::google::protobuf::uint32 protocol() const;
  void set_protocol(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ProtocolVerifyReq)
 private:
  void set_has_protocol();
  void clear_has_protocol();
  void set_has_data();
  void clear_has_data();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::uint32 protocol_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsProtocolVerifyReqImpl();
};
// -------------------------------------------------------------------

class ProtocolVerifyRsp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ProtocolVerifyRsp) */ {
 public:
  ProtocolVerifyRsp();
  virtual ~ProtocolVerifyRsp();

  ProtocolVerifyRsp(const ProtocolVerifyRsp& from);

  inline ProtocolVerifyRsp& operator=(const ProtocolVerifyRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtocolVerifyRsp(ProtocolVerifyRsp&& from) noexcept
    : ProtocolVerifyRsp() {
    *this = ::std::move(from);
  }

  inline ProtocolVerifyRsp& operator=(ProtocolVerifyRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtocolVerifyRsp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtocolVerifyRsp* internal_default_instance() {
    return reinterpret_cast<const ProtocolVerifyRsp*>(
               &_ProtocolVerifyRsp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(ProtocolVerifyRsp* other);
  friend void swap(ProtocolVerifyRsp& a, ProtocolVerifyRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtocolVerifyRsp* New() const PROTOBUF_FINAL { return New(NULL); }

  ProtocolVerifyRsp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ProtocolVerifyRsp& from);
  void MergeFrom(const ProtocolVerifyRsp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ProtocolVerifyRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string message = 2;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // required string Secret = 3;
  bool has_secret() const;
  void clear_secret();
  static const int kSecretFieldNumber = 3;
  const ::std::string& secret() const;
  void set_secret(const ::std::string& value);
  #if LANG_CXX11
  void set_secret(::std::string&& value);
  #endif
  void set_secret(const char* value);
  void set_secret(const char* value, size_t size);
  ::std::string* mutable_secret();
  ::std::string* release_secret();
  void set_allocated_secret(::std::string* secret);

  // required uint32 result = 1;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::google::protobuf::uint32 result() const;
  void set_result(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ProtocolVerifyRsp)
 private:
  void set_has_result();
  void clear_has_result();
  void set_has_message();
  void clear_has_message();
  void set_has_secret();
  void clear_has_secret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::internal::ArenaStringPtr secret_;
  ::google::protobuf::uint32 result_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsProtocolVerifyRspImpl();
};
// -------------------------------------------------------------------

class RoomInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RoomInfo) */ {
 public:
  RoomInfo();
  virtual ~RoomInfo();

  RoomInfo(const RoomInfo& from);

  inline RoomInfo& operator=(const RoomInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoomInfo(RoomInfo&& from) noexcept
    : RoomInfo() {
    *this = ::std::move(from);
  }

  inline RoomInfo& operator=(RoomInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoomInfo* internal_default_instance() {
    return reinterpret_cast<const RoomInfo*>(
               &_RoomInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(RoomInfo* other);
  friend void swap(RoomInfo& a, RoomInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoomInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  RoomInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RoomInfo& from);
  void MergeFrom(const RoomInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RoomInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef RoomInfo_RoomRule RoomRule;
  static const RoomRule MZ =
    RoomInfo_RoomRule_MZ;
  static const RoomRule ROB =
    RoomInfo_RoomRule_ROB;
  static const RoomRule Defence =
    RoomInfo_RoomRule_Defence;
  static const RoomRule KillTarget =
    RoomInfo_RoomRule_KillTarget;
  static const RoomRule Endless =
    RoomInfo_RoomRule_Endless;
  static const RoomRule Normal =
    RoomInfo_RoomRule_Normal;
  static const RoomRule Story =
    RoomInfo_RoomRule_Story;
  static const RoomRule Moba =
    RoomInfo_RoomRule_Moba;
  static inline bool RoomRule_IsValid(int value) {
    return RoomInfo_RoomRule_IsValid(value);
  }
  static const RoomRule RoomRule_MIN =
    RoomInfo_RoomRule_RoomRule_MIN;
  static const RoomRule RoomRule_MAX =
    RoomInfo_RoomRule_RoomRule_MAX;
  static const int RoomRule_ARRAYSIZE =
    RoomInfo_RoomRule_RoomRule_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RoomRule_descriptor() {
    return RoomInfo_RoomRule_descriptor();
  }
  static inline const ::std::string& RoomRule_Name(RoomRule value) {
    return RoomInfo_RoomRule_Name(value);
  }
  static inline bool RoomRule_Parse(const ::std::string& name,
      RoomRule* value) {
    return RoomInfo_RoomRule_Parse(name, value);
  }

  typedef RoomInfo_RoomPattern RoomPattern;
  static const RoomPattern _Normal =
    RoomInfo_RoomPattern__Normal;
  static const RoomPattern _Replay =
    RoomInfo_RoomPattern__Replay;
  static inline bool RoomPattern_IsValid(int value) {
    return RoomInfo_RoomPattern_IsValid(value);
  }
  static const RoomPattern RoomPattern_MIN =
    RoomInfo_RoomPattern_RoomPattern_MIN;
  static const RoomPattern RoomPattern_MAX =
    RoomInfo_RoomPattern_RoomPattern_MAX;
  static const int RoomPattern_ARRAYSIZE =
    RoomInfo_RoomPattern_RoomPattern_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RoomPattern_descriptor() {
    return RoomInfo_RoomPattern_descriptor();
  }
  static inline const ::std::string& RoomPattern_Name(RoomPattern value) {
    return RoomInfo_RoomPattern_Name(value);
  }
  static inline bool RoomPattern_Parse(const ::std::string& name,
      RoomPattern* value) {
    return RoomInfo_RoomPattern_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string roomName = 2;
  bool has_roomname() const;
  void clear_roomname();
  static const int kRoomNameFieldNumber = 2;
  const ::std::string& roomname() const;
  void set_roomname(const ::std::string& value);
  #if LANG_CXX11
  void set_roomname(::std::string&& value);
  #endif
  void set_roomname(const char* value);
  void set_roomname(const char* value, size_t size);
  ::std::string* mutable_roomname();
  ::std::string* release_roomname();
  void set_allocated_roomname(::std::string* roomname);

  // required uint32 roomId = 1;
  bool has_roomid() const;
  void clear_roomid();
  static const int kRoomIdFieldNumber = 1;
  ::google::protobuf::uint32 roomid() const;
  void set_roomid(::google::protobuf::uint32 value);

  // required uint32 levelIdx = 4;
  bool has_levelidx() const;
  void clear_levelidx();
  static const int kLevelIdxFieldNumber = 4;
  ::google::protobuf::uint32 levelidx() const;
  void set_levelidx(::google::protobuf::uint32 value);

  // required uint32 Group1 = 5;
  bool has_group1() const;
  void clear_group1();
  static const int kGroup1FieldNumber = 5;
  ::google::protobuf::uint32 group1() const;
  void set_group1(::google::protobuf::uint32 value);

  // required uint32 Group2 = 6;
  bool has_group2() const;
  void clear_group2();
  static const int kGroup2FieldNumber = 6;
  ::google::protobuf::uint32 group2() const;
  void set_group2(::google::protobuf::uint32 value);

  // required uint32 playerCount = 7;
  bool has_playercount() const;
  void clear_playercount();
  static const int kPlayerCountFieldNumber = 7;
  ::google::protobuf::uint32 playercount() const;
  void set_playercount(::google::protobuf::uint32 value);

  // required uint32 maxPlayer = 8;
  bool has_maxplayer() const;
  void clear_maxplayer();
  static const int kMaxPlayerFieldNumber = 8;
  ::google::protobuf::uint32 maxplayer() const;
  void set_maxplayer(::google::protobuf::uint32 value);

  // required .RoomInfo.RoomRule rule = 3;
  bool has_rule() const;
  void clear_rule();
  static const int kRuleFieldNumber = 3;
  ::RoomInfo_RoomRule rule() const;
  void set_rule(::RoomInfo_RoomRule value);

  // @@protoc_insertion_point(class_scope:RoomInfo)
 private:
  void set_has_roomid();
  void clear_has_roomid();
  void set_has_roomname();
  void clear_has_roomname();
  void set_has_rule();
  void clear_has_rule();
  void set_has_levelidx();
  void clear_has_levelidx();
  void set_has_group1();
  void clear_has_group1();
  void set_has_group2();
  void clear_has_group2();
  void set_has_playercount();
  void clear_has_playercount();
  void set_has_maxplayer();
  void clear_has_maxplayer();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr roomname_;
  ::google::protobuf::uint32 roomid_;
  ::google::protobuf::uint32 levelidx_;
  ::google::protobuf::uint32 group1_;
  ::google::protobuf::uint32 group2_;
  ::google::protobuf::uint32 playercount_;
  ::google::protobuf::uint32 maxplayer_;
  int rule_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsRoomInfoImpl();
};
// -------------------------------------------------------------------

class OnLeaveRoomRsp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OnLeaveRoomRsp) */ {
 public:
  OnLeaveRoomRsp();
  virtual ~OnLeaveRoomRsp();

  OnLeaveRoomRsp(const OnLeaveRoomRsp& from);

  inline OnLeaveRoomRsp& operator=(const OnLeaveRoomRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OnLeaveRoomRsp(OnLeaveRoomRsp&& from) noexcept
    : OnLeaveRoomRsp() {
    *this = ::std::move(from);
  }

  inline OnLeaveRoomRsp& operator=(OnLeaveRoomRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OnLeaveRoomRsp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OnLeaveRoomRsp* internal_default_instance() {
    return reinterpret_cast<const OnLeaveRoomRsp*>(
               &_OnLeaveRoomRsp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(OnLeaveRoomRsp* other);
  friend void swap(OnLeaveRoomRsp& a, OnLeaveRoomRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OnLeaveRoomRsp* New() const PROTOBUF_FINAL { return New(NULL); }

  OnLeaveRoomRsp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OnLeaveRoomRsp& from);
  void MergeFrom(const OnLeaveRoomRsp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OnLeaveRoomRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 playerId = 2;
  bool has_playerid() const;
  void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  ::google::protobuf::uint32 playerid() const;
  void set_playerid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:OnLeaveRoomRsp)
 private:
  void set_has_playerid();
  void clear_has_playerid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 playerid_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsOnLeaveRoomRspImpl();
};
// -------------------------------------------------------------------

class GetRoomRsp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GetRoomRsp) */ {
 public:
  GetRoomRsp();
  virtual ~GetRoomRsp();

  GetRoomRsp(const GetRoomRsp& from);

  inline GetRoomRsp& operator=(const GetRoomRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetRoomRsp(GetRoomRsp&& from) noexcept
    : GetRoomRsp() {
    *this = ::std::move(from);
  }

  inline GetRoomRsp& operator=(GetRoomRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetRoomRsp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetRoomRsp* internal_default_instance() {
    return reinterpret_cast<const GetRoomRsp*>(
               &_GetRoomRsp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(GetRoomRsp* other);
  friend void swap(GetRoomRsp& a, GetRoomRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetRoomRsp* New() const PROTOBUF_FINAL { return New(NULL); }

  GetRoomRsp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetRoomRsp& from);
  void MergeFrom(const GetRoomRsp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetRoomRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .RoomInfo RoomInLobby = 2;
  int roominlobby_size() const;
  void clear_roominlobby();
  static const int kRoomInLobbyFieldNumber = 2;
  const ::RoomInfo& roominlobby(int index) const;
  ::RoomInfo* mutable_roominlobby(int index);
  ::RoomInfo* add_roominlobby();
  ::google::protobuf::RepeatedPtrField< ::RoomInfo >*
      mutable_roominlobby();
  const ::google::protobuf::RepeatedPtrField< ::RoomInfo >&
      roominlobby() const;

  // @@protoc_insertion_point(class_scope:GetRoomRsp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::RoomInfo > roominlobby_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsGetRoomRspImpl();
};
// -------------------------------------------------------------------

class CreateRoomReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CreateRoomReq) */ {
 public:
  CreateRoomReq();
  virtual ~CreateRoomReq();

  CreateRoomReq(const CreateRoomReq& from);

  inline CreateRoomReq& operator=(const CreateRoomReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateRoomReq(CreateRoomReq&& from) noexcept
    : CreateRoomReq() {
    *this = ::std::move(from);
  }

  inline CreateRoomReq& operator=(CreateRoomReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateRoomReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateRoomReq* internal_default_instance() {
    return reinterpret_cast<const CreateRoomReq*>(
               &_CreateRoomReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(CreateRoomReq* other);
  friend void swap(CreateRoomReq& a, CreateRoomReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateRoomReq* New() const PROTOBUF_FINAL { return New(NULL); }

  CreateRoomReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CreateRoomReq& from);
  void MergeFrom(const CreateRoomReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CreateRoomReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string roomName = 5;
  bool has_roomname() const;
  void clear_roomname();
  static const int kRoomNameFieldNumber = 5;
  const ::std::string& roomname() const;
  void set_roomname(const ::std::string& value);
  #if LANG_CXX11
  void set_roomname(::std::string&& value);
  #endif
  void set_roomname(const char* value);
  void set_roomname(const char* value, size_t size);
  ::std::string* mutable_roomname();
  ::std::string* release_roomname();
  void set_allocated_roomname(::std::string* roomname);

  // optional string secret = 8;
  bool has_secret() const;
  void clear_secret();
  static const int kSecretFieldNumber = 8;
  const ::std::string& secret() const;
  void set_secret(const ::std::string& value);
  #if LANG_CXX11
  void set_secret(::std::string&& value);
  #endif
  void set_secret(const char* value);
  void set_secret(const char* value, size_t size);
  ::std::string* mutable_secret();
  ::std::string* release_secret();
  void set_allocated_secret(::std::string* secret);

  // required uint32 maxPlayer = 2;
  bool has_maxplayer() const;
  void clear_maxplayer();
  static const int kMaxPlayerFieldNumber = 2;
  ::google::protobuf::uint32 maxplayer() const;
  void set_maxplayer(::google::protobuf::uint32 value);

  // required uint32 levelIdx = 3;
  bool has_levelidx() const;
  void clear_levelidx();
  static const int kLevelIdxFieldNumber = 3;
  ::google::protobuf::uint32 levelidx() const;
  void set_levelidx(::google::protobuf::uint32 value);

  // required uint32 rule = 4;
  bool has_rule() const;
  void clear_rule();
  static const int kRuleFieldNumber = 4;
  ::google::protobuf::uint32 rule() const;
  void set_rule(::google::protobuf::uint32 value);

  // required uint32 hpMax = 6;
  bool has_hpmax() const;
  void clear_hpmax();
  static const int kHpMaxFieldNumber = 6;
  ::google::protobuf::uint32 hpmax() const;
  void set_hpmax(::google::protobuf::uint32 value);

  // required uint32 roundTime = 7;
  bool has_roundtime() const;
  void clear_roundtime();
  static const int kRoundTimeFieldNumber = 7;
  ::google::protobuf::uint32 roundtime() const;
  void set_roundtime(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CreateRoomReq)
 private:
  void set_has_maxplayer();
  void clear_has_maxplayer();
  void set_has_levelidx();
  void clear_has_levelidx();
  void set_has_rule();
  void clear_has_rule();
  void set_has_roomname();
  void clear_has_roomname();
  void set_has_hpmax();
  void clear_has_hpmax();
  void set_has_roundtime();
  void clear_has_roundtime();
  void set_has_secret();
  void clear_has_secret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr roomname_;
  ::google::protobuf::internal::ArenaStringPtr secret_;
  ::google::protobuf::uint32 maxplayer_;
  ::google::protobuf::uint32 levelidx_;
  ::google::protobuf::uint32 rule_;
  ::google::protobuf::uint32 hpmax_;
  ::google::protobuf::uint32 roundtime_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsCreateRoomReqImpl();
};
// -------------------------------------------------------------------

class CreateRoomRsp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CreateRoomRsp) */ {
 public:
  CreateRoomRsp();
  virtual ~CreateRoomRsp();

  CreateRoomRsp(const CreateRoomRsp& from);

  inline CreateRoomRsp& operator=(const CreateRoomRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateRoomRsp(CreateRoomRsp&& from) noexcept
    : CreateRoomRsp() {
    *this = ::std::move(from);
  }

  inline CreateRoomRsp& operator=(CreateRoomRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateRoomRsp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateRoomRsp* internal_default_instance() {
    return reinterpret_cast<const CreateRoomRsp*>(
               &_CreateRoomRsp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(CreateRoomRsp* other);
  friend void swap(CreateRoomRsp& a, CreateRoomRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateRoomRsp* New() const PROTOBUF_FINAL { return New(NULL); }

  CreateRoomRsp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CreateRoomRsp& from);
  void MergeFrom(const CreateRoomRsp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CreateRoomRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 result = 2;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 2;
  ::google::protobuf::uint32 result() const;
  void set_result(::google::protobuf::uint32 value);

  // required uint32 roomId = 3;
  bool has_roomid() const;
  void clear_roomid();
  static const int kRoomIdFieldNumber = 3;
  ::google::protobuf::uint32 roomid() const;
  void set_roomid(::google::protobuf::uint32 value);

  // required uint32 levelId = 4;
  bool has_levelid() const;
  void clear_levelid();
  static const int kLevelIdFieldNumber = 4;
  ::google::protobuf::uint32 levelid() const;
  void set_levelid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CreateRoomRsp)
 private:
  void set_has_result();
  void clear_has_result();
  void set_has_roomid();
  void clear_has_roomid();
  void set_has_levelid();
  void clear_has_levelid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 result_;
  ::google::protobuf::uint32 roomid_;
  ::google::protobuf::uint32 levelid_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsCreateRoomRspImpl();
};
// -------------------------------------------------------------------

class JoinRoomReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:JoinRoomReq) */ {
 public:
  JoinRoomReq();
  virtual ~JoinRoomReq();

  JoinRoomReq(const JoinRoomReq& from);

  inline JoinRoomReq& operator=(const JoinRoomReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JoinRoomReq(JoinRoomReq&& from) noexcept
    : JoinRoomReq() {
    *this = ::std::move(from);
  }

  inline JoinRoomReq& operator=(JoinRoomReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JoinRoomReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JoinRoomReq* internal_default_instance() {
    return reinterpret_cast<const JoinRoomReq*>(
               &_JoinRoomReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(JoinRoomReq* other);
  friend void swap(JoinRoomReq& a, JoinRoomReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JoinRoomReq* New() const PROTOBUF_FINAL { return New(NULL); }

  JoinRoomReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const JoinRoomReq& from);
  void MergeFrom(const JoinRoomReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(JoinRoomReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string userNick = 3;
  bool has_usernick() const;
  void clear_usernick();
  static const int kUserNickFieldNumber = 3;
  const ::std::string& usernick() const;
  void set_usernick(const ::std::string& value);
  #if LANG_CXX11
  void set_usernick(::std::string&& value);
  #endif
  void set_usernick(const char* value);
  void set_usernick(const char* value, size_t size);
  ::std::string* mutable_usernick();
  ::std::string* release_usernick();
  void set_allocated_usernick(::std::string* usernick);

  // optional string secret = 4;
  bool has_secret() const;
  void clear_secret();
  static const int kSecretFieldNumber = 4;
  const ::std::string& secret() const;
  void set_secret(const ::std::string& value);
  #if LANG_CXX11
  void set_secret(::std::string&& value);
  #endif
  void set_secret(const char* value);
  void set_secret(const char* value, size_t size);
  ::std::string* mutable_secret();
  ::std::string* release_secret();
  void set_allocated_secret(::std::string* secret);

  // required uint32 roomId = 2;
  bool has_roomid() const;
  void clear_roomid();
  static const int kRoomIdFieldNumber = 2;
  ::google::protobuf::uint32 roomid() const;
  void set_roomid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:JoinRoomReq)
 private:
  void set_has_roomid();
  void clear_has_roomid();
  void set_has_usernick();
  void clear_has_usernick();
  void set_has_secret();
  void clear_has_secret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr usernick_;
  ::google::protobuf::internal::ArenaStringPtr secret_;
  ::google::protobuf::uint32 roomid_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsJoinRoomReqImpl();
};
// -------------------------------------------------------------------

class JoinRoomRsp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:JoinRoomRsp) */ {
 public:
  JoinRoomRsp();
  virtual ~JoinRoomRsp();

  JoinRoomRsp(const JoinRoomRsp& from);

  inline JoinRoomRsp& operator=(const JoinRoomRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JoinRoomRsp(JoinRoomRsp&& from) noexcept
    : JoinRoomRsp() {
    *this = ::std::move(from);
  }

  inline JoinRoomRsp& operator=(JoinRoomRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JoinRoomRsp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JoinRoomRsp* internal_default_instance() {
    return reinterpret_cast<const JoinRoomRsp*>(
               &_JoinRoomRsp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(JoinRoomRsp* other);
  friend void swap(JoinRoomRsp& a, JoinRoomRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JoinRoomRsp* New() const PROTOBUF_FINAL { return New(NULL); }

  JoinRoomRsp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const JoinRoomRsp& from);
  void MergeFrom(const JoinRoomRsp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(JoinRoomRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string userNick = 7;
  bool has_usernick() const;
  void clear_usernick();
  static const int kUserNickFieldNumber = 7;
  const ::std::string& usernick() const;
  void set_usernick(const ::std::string& value);
  #if LANG_CXX11
  void set_usernick(::std::string&& value);
  #endif
  void set_usernick(const char* value);
  void set_usernick(const char* value, size_t size);
  ::std::string* mutable_usernick();
  ::std::string* release_usernick();
  void set_allocated_usernick(::std::string* usernick);

  // required uint32 result = 2;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 2;
  ::google::protobuf::uint32 result() const;
  void set_result(::google::protobuf::uint32 value);

  // required uint32 reason = 3;
  bool has_reason() const;
  void clear_reason();
  static const int kReasonFieldNumber = 3;
  ::google::protobuf::uint32 reason() const;
  void set_reason(::google::protobuf::uint32 value);

  // required uint32 levelIdx = 4;
  bool has_levelidx() const;
  void clear_levelidx();
  static const int kLevelIdxFieldNumber = 4;
  ::google::protobuf::uint32 levelidx() const;
  void set_levelidx(::google::protobuf::uint32 value);

  // required uint32 roomId = 5;
  bool has_roomid() const;
  void clear_roomid();
  static const int kRoomIdFieldNumber = 5;
  ::google::protobuf::uint32 roomid() const;
  void set_roomid(::google::protobuf::uint32 value);

  // required uint32 playerId = 6;
  bool has_playerid() const;
  void clear_playerid();
  static const int kPlayerIdFieldNumber = 6;
  ::google::protobuf::uint32 playerid() const;
  void set_playerid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:JoinRoomRsp)
 private:
  void set_has_result();
  void clear_has_result();
  void set_has_reason();
  void clear_has_reason();
  void set_has_levelidx();
  void clear_has_levelidx();
  void set_has_roomid();
  void clear_has_roomid();
  void set_has_playerid();
  void clear_has_playerid();
  void set_has_usernick();
  void clear_has_usernick();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr usernick_;
  ::google::protobuf::uint32 result_;
  ::google::protobuf::uint32 reason_;
  ::google::protobuf::uint32 levelidx_;
  ::google::protobuf::uint32 roomid_;
  ::google::protobuf::uint32 playerid_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsJoinRoomRspImpl();
};
// -------------------------------------------------------------------

class EnterLevelReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:EnterLevelReq) */ {
 public:
  EnterLevelReq();
  virtual ~EnterLevelReq();

  EnterLevelReq(const EnterLevelReq& from);

  inline EnterLevelReq& operator=(const EnterLevelReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EnterLevelReq(EnterLevelReq&& from) noexcept
    : EnterLevelReq() {
    *this = ::std::move(from);
  }

  inline EnterLevelReq& operator=(EnterLevelReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnterLevelReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EnterLevelReq* internal_default_instance() {
    return reinterpret_cast<const EnterLevelReq*>(
               &_EnterLevelReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(EnterLevelReq* other);
  friend void swap(EnterLevelReq& a, EnterLevelReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EnterLevelReq* New() const PROTOBUF_FINAL { return New(NULL); }

  EnterLevelReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EnterLevelReq& from);
  void MergeFrom(const EnterLevelReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EnterLevelReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 camp = 2;
  bool has_camp() const;
  void clear_camp();
  static const int kCampFieldNumber = 2;
  ::google::protobuf::uint32 camp() const;
  void set_camp(::google::protobuf::uint32 value);

  // required uint32 model = 3;
  bool has_model() const;
  void clear_model();
  static const int kModelFieldNumber = 3;
  ::google::protobuf::uint32 model() const;
  void set_model(::google::protobuf::uint32 value);

  // required uint32 weapon = 4;
  bool has_weapon() const;
  void clear_weapon();
  static const int kWeaponFieldNumber = 4;
  ::google::protobuf::uint32 weapon() const;
  void set_weapon(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:EnterLevelReq)
 private:
  void set_has_camp();
  void clear_has_camp();
  void set_has_model();
  void clear_has_model();
  void set_has_weapon();
  void clear_has_weapon();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 camp_;
  ::google::protobuf::uint32 model_;
  ::google::protobuf::uint32 weapon_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsEnterLevelReqImpl();
};
// -------------------------------------------------------------------

class EnterLevelRsp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:EnterLevelRsp) */ {
 public:
  EnterLevelRsp();
  virtual ~EnterLevelRsp();

  EnterLevelRsp(const EnterLevelRsp& from);

  inline EnterLevelRsp& operator=(const EnterLevelRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EnterLevelRsp(EnterLevelRsp&& from) noexcept
    : EnterLevelRsp() {
    *this = ::std::move(from);
  }

  inline EnterLevelRsp& operator=(EnterLevelRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnterLevelRsp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EnterLevelRsp* internal_default_instance() {
    return reinterpret_cast<const EnterLevelRsp*>(
               &_EnterLevelRsp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(EnterLevelRsp* other);
  friend void swap(EnterLevelRsp& a, EnterLevelRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EnterLevelRsp* New() const PROTOBUF_FINAL { return New(NULL); }

  EnterLevelRsp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EnterLevelRsp& from);
  void MergeFrom(const EnterLevelRsp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EnterLevelRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SceneInfo scene = 1;
  bool has_scene() const;
  void clear_scene();
  static const int kSceneFieldNumber = 1;
  const ::SceneInfo& scene() const;
  ::SceneInfo* release_scene();
  ::SceneInfo* mutable_scene();
  void set_allocated_scene(::SceneInfo* scene);

  // @@protoc_insertion_point(class_scope:EnterLevelRsp)
 private:
  void set_has_scene();
  void clear_has_scene();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::SceneInfo* scene_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsEnterLevelRspImpl();
};
// -------------------------------------------------------------------

class OnEnterRoomRsp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OnEnterRoomRsp) */ {
 public:
  OnEnterRoomRsp();
  virtual ~OnEnterRoomRsp();

  OnEnterRoomRsp(const OnEnterRoomRsp& from);

  inline OnEnterRoomRsp& operator=(const OnEnterRoomRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OnEnterRoomRsp(OnEnterRoomRsp&& from) noexcept
    : OnEnterRoomRsp() {
    *this = ::std::move(from);
  }

  inline OnEnterRoomRsp& operator=(OnEnterRoomRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OnEnterRoomRsp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OnEnterRoomRsp* internal_default_instance() {
    return reinterpret_cast<const OnEnterRoomRsp*>(
               &_OnEnterRoomRsp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    24;

  void Swap(OnEnterRoomRsp* other);
  friend void swap(OnEnterRoomRsp& a, OnEnterRoomRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OnEnterRoomRsp* New() const PROTOBUF_FINAL { return New(NULL); }

  OnEnterRoomRsp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OnEnterRoomRsp& from);
  void MergeFrom(const OnEnterRoomRsp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OnEnterRoomRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string playerNick = 1;
  bool has_playernick() const;
  void clear_playernick();
  static const int kPlayerNickFieldNumber = 1;
  const ::std::string& playernick() const;
  void set_playernick(const ::std::string& value);
  #if LANG_CXX11
  void set_playernick(::std::string&& value);
  #endif
  void set_playernick(const char* value);
  void set_playernick(const char* value, size_t size);
  ::std::string* mutable_playernick();
  ::std::string* release_playernick();
  void set_allocated_playernick(::std::string* playernick);

  // @@protoc_insertion_point(class_scope:OnEnterRoomRsp)
 private:
  void set_has_playernick();
  void clear_has_playernick();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr playernick_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsOnEnterRoomRspImpl();
};
// -------------------------------------------------------------------

class OnEnterLevelRsp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OnEnterLevelRsp) */ {
 public:
  OnEnterLevelRsp();
  virtual ~OnEnterLevelRsp();

  OnEnterLevelRsp(const OnEnterLevelRsp& from);

  inline OnEnterLevelRsp& operator=(const OnEnterLevelRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OnEnterLevelRsp(OnEnterLevelRsp&& from) noexcept
    : OnEnterLevelRsp() {
    *this = ::std::move(from);
  }

  inline OnEnterLevelRsp& operator=(OnEnterLevelRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OnEnterLevelRsp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OnEnterLevelRsp* internal_default_instance() {
    return reinterpret_cast<const OnEnterLevelRsp*>(
               &_OnEnterLevelRsp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    25;

  void Swap(OnEnterLevelRsp* other);
  friend void swap(OnEnterLevelRsp& a, OnEnterLevelRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OnEnterLevelRsp* New() const PROTOBUF_FINAL { return New(NULL); }

  OnEnterLevelRsp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OnEnterLevelRsp& from);
  void MergeFrom(const OnEnterLevelRsp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OnEnterLevelRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Player_ player = 1;
  bool has_player() const;
  void clear_player();
  static const int kPlayerFieldNumber = 1;
  const ::Player_& player() const;
  ::Player_* release_player();
  ::Player_* mutable_player();
  void set_allocated_player(::Player_* player);

  // @@protoc_insertion_point(class_scope:OnEnterLevelRsp)
 private:
  void set_has_player();
  void clear_has_player();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::Player_* player_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsOnEnterLevelRspImpl();
};
// -------------------------------------------------------------------

class Vector2_ : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Vector2_) */ {
 public:
  Vector2_();
  virtual ~Vector2_();

  Vector2_(const Vector2_& from);

  inline Vector2_& operator=(const Vector2_& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Vector2_(Vector2_&& from) noexcept
    : Vector2_() {
    *this = ::std::move(from);
  }

  inline Vector2_& operator=(Vector2_&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector2_& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vector2_* internal_default_instance() {
    return reinterpret_cast<const Vector2_*>(
               &_Vector2__default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    26;

  void Swap(Vector2_* other);
  friend void swap(Vector2_& a, Vector2_& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Vector2_* New() const PROTOBUF_FINAL { return New(NULL); }

  Vector2_* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Vector2_& from);
  void MergeFrom(const Vector2_& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Vector2_* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  ::google::protobuf::int32 x() const;
  void set_x(::google::protobuf::int32 value);

  // required int32 y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  ::google::protobuf::int32 y() const;
  void set_y(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Vector2_)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsVector2_Impl();
};
// -------------------------------------------------------------------

class Vector3_ : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Vector3_) */ {
 public:
  Vector3_();
  virtual ~Vector3_();

  Vector3_(const Vector3_& from);

  inline Vector3_& operator=(const Vector3_& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Vector3_(Vector3_&& from) noexcept
    : Vector3_() {
    *this = ::std::move(from);
  }

  inline Vector3_& operator=(Vector3_&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector3_& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vector3_* internal_default_instance() {
    return reinterpret_cast<const Vector3_*>(
               &_Vector3__default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    27;

  void Swap(Vector3_* other);
  friend void swap(Vector3_& a, Vector3_& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Vector3_* New() const PROTOBUF_FINAL { return New(NULL); }

  Vector3_* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Vector3_& from);
  void MergeFrom(const Vector3_& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Vector3_* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  ::google::protobuf::int32 x() const;
  void set_x(::google::protobuf::int32 value);

  // required int32 y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  ::google::protobuf::int32 y() const;
  void set_y(::google::protobuf::int32 value);

  // required int32 z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  ::google::protobuf::int32 z() const;
  void set_z(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Vector3_)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 z_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsVector3_Impl();
};
// -------------------------------------------------------------------

class Quaternion_ : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Quaternion_) */ {
 public:
  Quaternion_();
  virtual ~Quaternion_();

  Quaternion_(const Quaternion_& from);

  inline Quaternion_& operator=(const Quaternion_& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Quaternion_(Quaternion_&& from) noexcept
    : Quaternion_() {
    *this = ::std::move(from);
  }

  inline Quaternion_& operator=(Quaternion_&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Quaternion_& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Quaternion_* internal_default_instance() {
    return reinterpret_cast<const Quaternion_*>(
               &_Quaternion__default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    28;

  void Swap(Quaternion_* other);
  friend void swap(Quaternion_& a, Quaternion_& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Quaternion_* New() const PROTOBUF_FINAL { return New(NULL); }

  Quaternion_* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Quaternion_& from);
  void MergeFrom(const Quaternion_& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Quaternion_* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  ::google::protobuf::int32 x() const;
  void set_x(::google::protobuf::int32 value);

  // required int32 y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  ::google::protobuf::int32 y() const;
  void set_y(::google::protobuf::int32 value);

  // required int32 z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  ::google::protobuf::int32 z() const;
  void set_z(::google::protobuf::int32 value);

  // required int32 w = 4;
  bool has_w() const;
  void clear_w();
  static const int kWFieldNumber = 4;
  ::google::protobuf::int32 w() const;
  void set_w(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Quaternion_)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();
  void set_has_w();
  void clear_has_w();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 z_;
  ::google::protobuf::int32 w_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsQuaternion_Impl();
};
// -------------------------------------------------------------------

class SceneInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SceneInfo) */ {
 public:
  SceneInfo();
  virtual ~SceneInfo();

  SceneInfo(const SceneInfo& from);

  inline SceneInfo& operator=(const SceneInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SceneInfo(SceneInfo&& from) noexcept
    : SceneInfo() {
    *this = ::std::move(from);
  }

  inline SceneInfo& operator=(SceneInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SceneInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SceneInfo* internal_default_instance() {
    return reinterpret_cast<const SceneInfo*>(
               &_SceneInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    29;

  void Swap(SceneInfo* other);
  friend void swap(SceneInfo& a, SceneInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SceneInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  SceneInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SceneInfo& from);
  void MergeFrom(const SceneInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SceneInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .SceneItem_ items = 1;
  int items_size() const;
  void clear_items();
  static const int kItemsFieldNumber = 1;
  const ::SceneItem_& items(int index) const;
  ::SceneItem_* mutable_items(int index);
  ::SceneItem_* add_items();
  ::google::protobuf::RepeatedPtrField< ::SceneItem_ >*
      mutable_items();
  const ::google::protobuf::RepeatedPtrField< ::SceneItem_ >&
      items() const;

  // repeated .Player_ players = 2;
  int players_size() const;
  void clear_players();
  static const int kPlayersFieldNumber = 2;
  const ::Player_& players(int index) const;
  ::Player_* mutable_players(int index);
  ::Player_* add_players();
  ::google::protobuf::RepeatedPtrField< ::Player_ >*
      mutable_players();
  const ::google::protobuf::RepeatedPtrField< ::Player_ >&
      players() const;

  // @@protoc_insertion_point(class_scope:SceneInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::SceneItem_ > items_;
  ::google::protobuf::RepeatedPtrField< ::Player_ > players_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsSceneInfoImpl();
};
// -------------------------------------------------------------------

class SceneItem_ : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SceneItem_) */ {
 public:
  SceneItem_();
  virtual ~SceneItem_();

  SceneItem_(const SceneItem_& from);

  inline SceneItem_& operator=(const SceneItem_& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SceneItem_(SceneItem_&& from) noexcept
    : SceneItem_() {
    *this = ::std::move(from);
  }

  inline SceneItem_& operator=(SceneItem_&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SceneItem_& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SceneItem_* internal_default_instance() {
    return reinterpret_cast<const SceneItem_*>(
               &_SceneItem__default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    30;

  void Swap(SceneItem_* other);
  friend void swap(SceneItem_& a, SceneItem_& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SceneItem_* New() const PROTOBUF_FINAL { return New(NULL); }

  SceneItem_* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SceneItem_& from);
  void MergeFrom(const SceneItem_& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SceneItem_* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string model = 1;
  bool has_model() const;
  void clear_model();
  static const int kModelFieldNumber = 1;
  const ::std::string& model() const;
  void set_model(const ::std::string& value);
  #if LANG_CXX11
  void set_model(::std::string&& value);
  #endif
  void set_model(const char* value);
  void set_model(const char* value, size_t size);
  ::std::string* mutable_model();
  ::std::string* release_model();
  void set_allocated_model(::std::string* model);

  // required .Vector3_ pos = 2;
  bool has_pos() const;
  void clear_pos();
  static const int kPosFieldNumber = 2;
  const ::Vector3_& pos() const;
  ::Vector3_* release_pos();
  ::Vector3_* mutable_pos();
  void set_allocated_pos(::Vector3_* pos);

  // required .Quaternion_ rotation = 3;
  bool has_rotation() const;
  void clear_rotation();
  static const int kRotationFieldNumber = 3;
  const ::Quaternion_& rotation() const;
  ::Quaternion_* release_rotation();
  ::Quaternion_* mutable_rotation();
  void set_allocated_rotation(::Quaternion_* rotation);

  // required int32 frame = 4;
  bool has_frame() const;
  void clear_frame();
  static const int kFrameFieldNumber = 4;
  ::google::protobuf::int32 frame() const;
  void set_frame(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SceneItem_)
 private:
  void set_has_model();
  void clear_has_model();
  void set_has_pos();
  void clear_has_pos();
  void set_has_rotation();
  void clear_has_rotation();
  void set_has_frame();
  void clear_has_frame();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr model_;
  ::Vector3_* pos_;
  ::Quaternion_* rotation_;
  ::google::protobuf::int32 frame_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsSceneItem_Impl();
};
// -------------------------------------------------------------------

class Player_ : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Player_) */ {
 public:
  Player_();
  virtual ~Player_();

  Player_(const Player_& from);

  inline Player_& operator=(const Player_& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Player_(Player_&& from) noexcept
    : Player_() {
    *this = ::std::move(from);
  }

  inline Player_& operator=(Player_&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Player_& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Player_* internal_default_instance() {
    return reinterpret_cast<const Player_*>(
               &_Player__default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    31;

  void Swap(Player_* other);
  friend void swap(Player_& a, Player_& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Player_* New() const PROTOBUF_FINAL { return New(NULL); }

  Player_* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Player_& from);
  void MergeFrom(const Player_& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Player_* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required .Vector3_ pos = 7;
  bool has_pos() const;
  void clear_pos();
  static const int kPosFieldNumber = 7;
  const ::Vector3_& pos() const;
  ::Vector3_* release_pos();
  ::Vector3_* mutable_pos();
  void set_allocated_pos(::Vector3_* pos);

  // required .Quaternion_ rotation = 8;
  bool has_rotation() const;
  void clear_rotation();
  static const int kRotationFieldNumber = 8;
  const ::Quaternion_& rotation() const;
  ::Quaternion_* release_rotation();
  ::Quaternion_* mutable_rotation();
  void set_allocated_rotation(::Quaternion_* rotation);

  // required uint32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // required uint32 weapon1 = 3;
  bool has_weapon1() const;
  void clear_weapon1();
  static const int kWeapon1FieldNumber = 3;
  ::google::protobuf::uint32 weapon1() const;
  void set_weapon1(::google::protobuf::uint32 value);

  // required uint32 weapon2 = 4;
  bool has_weapon2() const;
  void clear_weapon2();
  static const int kWeapon2FieldNumber = 4;
  ::google::protobuf::uint32 weapon2() const;
  void set_weapon2(::google::protobuf::uint32 value);

  // required uint32 weapon = 5;
  bool has_weapon() const;
  void clear_weapon();
  static const int kWeaponFieldNumber = 5;
  ::google::protobuf::uint32 weapon() const;
  void set_weapon(::google::protobuf::uint32 value);

  // required uint32 weapon_pos = 6;
  bool has_weapon_pos() const;
  void clear_weapon_pos();
  static const int kWeaponPosFieldNumber = 6;
  ::google::protobuf::uint32 weapon_pos() const;
  void set_weapon_pos(::google::protobuf::uint32 value);

  // required int32 model = 9;
  bool has_model() const;
  void clear_model();
  static const int kModelFieldNumber = 9;
  ::google::protobuf::int32 model() const;
  void set_model(::google::protobuf::int32 value);

  // required int32 aniSource = 10;
  bool has_anisource() const;
  void clear_anisource();
  static const int kAniSourceFieldNumber = 10;
  ::google::protobuf::int32 anisource() const;
  void set_anisource(::google::protobuf::int32 value);

  // required int32 frame = 11;
  bool has_frame() const;
  void clear_frame();
  static const int kFrameFieldNumber = 11;
  ::google::protobuf::int32 frame() const;
  void set_frame(::google::protobuf::int32 value);

  // required int32 hpMax = 12;
  bool has_hpmax() const;
  void clear_hpmax();
  static const int kHpMaxFieldNumber = 12;
  ::google::protobuf::int32 hpmax() const;
  void set_hpmax(::google::protobuf::int32 value);

  // required int32 hp = 13;
  bool has_hp() const;
  void clear_hp();
  static const int kHpFieldNumber = 13;
  ::google::protobuf::int32 hp() const;
  void set_hp(::google::protobuf::int32 value);

  // required int32 angry = 14;
  bool has_angry() const;
  void clear_angry();
  static const int kAngryFieldNumber = 14;
  ::google::protobuf::int32 angry() const;
  void set_angry(::google::protobuf::int32 value);

  // required int32 Camp = 15;
  bool has_camp() const;
  void clear_camp();
  static const int kCampFieldNumber = 15;
  ::google::protobuf::int32 camp() const;
  void set_camp(::google::protobuf::int32 value);

  // required int32 SpawnPoint = 16;
  bool has_spawnpoint() const;
  void clear_spawnpoint();
  static const int kSpawnPointFieldNumber = 16;
  ::google::protobuf::int32 spawnpoint() const;
  void set_spawnpoint(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Player_)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_name();
  void clear_has_name();
  void set_has_weapon1();
  void clear_has_weapon1();
  void set_has_weapon2();
  void clear_has_weapon2();
  void set_has_weapon();
  void clear_has_weapon();
  void set_has_weapon_pos();
  void clear_has_weapon_pos();
  void set_has_pos();
  void clear_has_pos();
  void set_has_rotation();
  void clear_has_rotation();
  void set_has_model();
  void clear_has_model();
  void set_has_anisource();
  void clear_has_anisource();
  void set_has_frame();
  void clear_has_frame();
  void set_has_hpmax();
  void clear_has_hpmax();
  void set_has_hp();
  void clear_has_hp();
  void set_has_angry();
  void clear_has_angry();
  void set_has_camp();
  void clear_has_camp();
  void set_has_spawnpoint();
  void clear_has_spawnpoint();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::Vector3_* pos_;
  ::Quaternion_* rotation_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 weapon1_;
  ::google::protobuf::uint32 weapon2_;
  ::google::protobuf::uint32 weapon_;
  ::google::protobuf::uint32 weapon_pos_;
  ::google::protobuf::int32 model_;
  ::google::protobuf::int32 anisource_;
  ::google::protobuf::int32 frame_;
  ::google::protobuf::int32 hpmax_;
  ::google::protobuf::int32 hp_;
  ::google::protobuf::int32 angry_;
  ::google::protobuf::int32 camp_;
  ::google::protobuf::int32 spawnpoint_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsPlayer_Impl();
};
// -------------------------------------------------------------------

class InputReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:InputReq) */ {
 public:
  InputReq();
  virtual ~InputReq();

  InputReq(const InputReq& from);

  inline InputReq& operator=(const InputReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InputReq(InputReq&& from) noexcept
    : InputReq() {
    *this = ::std::move(from);
  }

  inline InputReq& operator=(InputReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InputReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InputReq* internal_default_instance() {
    return reinterpret_cast<const InputReq*>(
               &_InputReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    32;

  void Swap(InputReq* other);
  friend void swap(InputReq& a, InputReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InputReq* New() const PROTOBUF_FINAL { return New(NULL); }

  InputReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const InputReq& from);
  void MergeFrom(const InputReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(InputReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Input_ input = 1;
  int input_size() const;
  void clear_input();
  static const int kInputFieldNumber = 1;
  const ::Input_& input(int index) const;
  ::Input_* mutable_input(int index);
  ::Input_* add_input();
  ::google::protobuf::RepeatedPtrField< ::Input_ >*
      mutable_input();
  const ::google::protobuf::RepeatedPtrField< ::Input_ >&
      input() const;

  // @@protoc_insertion_point(class_scope:InputReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Input_ > input_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsInputReqImpl();
};
// -------------------------------------------------------------------

class Input_ : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Input_) */ {
 public:
  Input_();
  virtual ~Input_();

  Input_(const Input_& from);

  inline Input_& operator=(const Input_& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Input_(Input_&& from) noexcept
    : Input_() {
    *this = ::std::move(from);
  }

  inline Input_& operator=(Input_&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Input_& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Input_* internal_default_instance() {
    return reinterpret_cast<const Input_*>(
               &_Input__default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    33;

  void Swap(Input_* other);
  friend void swap(Input_& a, Input_& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Input_* New() const PROTOBUF_FINAL { return New(NULL); }

  Input_* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Input_& from);
  void MergeFrom(const Input_& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Input_* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .InputFrame frames = 2;
  int frames_size() const;
  void clear_frames();
  static const int kFramesFieldNumber = 2;
  const ::InputFrame& frames(int index) const;
  ::InputFrame* mutable_frames(int index);
  ::InputFrame* add_frames();
  ::google::protobuf::RepeatedPtrField< ::InputFrame >*
      mutable_frames();
  const ::google::protobuf::RepeatedPtrField< ::InputFrame >&
      frames() const;

  // required uint32 playerId = 1;
  bool has_playerid() const;
  void clear_playerid();
  static const int kPlayerIdFieldNumber = 1;
  ::google::protobuf::uint32 playerid() const;
  void set_playerid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Input_)
 private:
  void set_has_playerid();
  void clear_has_playerid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::InputFrame > frames_;
  ::google::protobuf::uint32 playerid_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsInput_Impl();
};
// -------------------------------------------------------------------

class TurnFrames : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TurnFrames) */ {
 public:
  TurnFrames();
  virtual ~TurnFrames();

  TurnFrames(const TurnFrames& from);

  inline TurnFrames& operator=(const TurnFrames& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TurnFrames(TurnFrames&& from) noexcept
    : TurnFrames() {
    *this = ::std::move(from);
  }

  inline TurnFrames& operator=(TurnFrames&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TurnFrames& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TurnFrames* internal_default_instance() {
    return reinterpret_cast<const TurnFrames*>(
               &_TurnFrames_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    34;

  void Swap(TurnFrames* other);
  friend void swap(TurnFrames& a, TurnFrames& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TurnFrames* New() const PROTOBUF_FINAL { return New(NULL); }

  TurnFrames* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TurnFrames& from);
  void MergeFrom(const TurnFrames& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TurnFrames* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Input_ Inputs = 2;
  int inputs_size() const;
  void clear_inputs();
  static const int kInputsFieldNumber = 2;
  const ::Input_& inputs(int index) const;
  ::Input_* mutable_inputs(int index);
  ::Input_* add_inputs();
  ::google::protobuf::RepeatedPtrField< ::Input_ >*
      mutable_inputs();
  const ::google::protobuf::RepeatedPtrField< ::Input_ >&
      inputs() const;

  // required uint32 turnIndex = 1;
  bool has_turnindex() const;
  void clear_turnindex();
  static const int kTurnIndexFieldNumber = 1;
  ::google::protobuf::uint32 turnindex() const;
  void set_turnindex(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TurnFrames)
 private:
  void set_has_turnindex();
  void clear_has_turnindex();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Input_ > inputs_;
  ::google::protobuf::uint32 turnindex_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsTurnFramesImpl();
};
// -------------------------------------------------------------------

class UserId : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:UserId) */ {
 public:
  UserId();
  virtual ~UserId();

  UserId(const UserId& from);

  inline UserId& operator=(const UserId& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserId(UserId&& from) noexcept
    : UserId() {
    *this = ::std::move(from);
  }

  inline UserId& operator=(UserId&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserId& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserId* internal_default_instance() {
    return reinterpret_cast<const UserId*>(
               &_UserId_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    35;

  void Swap(UserId* other);
  friend void swap(UserId& a, UserId& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserId* New() const PROTOBUF_FINAL { return New(NULL); }

  UserId* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UserId& from);
  void MergeFrom(const UserId& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UserId* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 Player = 1;
  int player_size() const;
  void clear_player();
  static const int kPlayerFieldNumber = 1;
  ::google::protobuf::uint32 player(int index) const;
  void set_player(int index, ::google::protobuf::uint32 value);
  void add_player(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      player() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_player();

  // @@protoc_insertion_point(class_scope:UserId)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > player_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsUserIdImpl();
};
// -------------------------------------------------------------------

class InputFrame : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:InputFrame) */ {
 public:
  InputFrame();
  virtual ~InputFrame();

  InputFrame(const InputFrame& from);

  inline InputFrame& operator=(const InputFrame& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InputFrame(InputFrame&& from) noexcept
    : InputFrame() {
    *this = ::std::move(from);
  }

  inline InputFrame& operator=(InputFrame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InputFrame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InputFrame* internal_default_instance() {
    return reinterpret_cast<const InputFrame*>(
               &_InputFrame_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    36;

  void Swap(InputFrame* other);
  friend void swap(InputFrame& a, InputFrame& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InputFrame* New() const PROTOBUF_FINAL { return New(NULL); }

  InputFrame* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const InputFrame& from);
  void MergeFrom(const InputFrame& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(InputFrame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes w = 4;
  bool has_w() const;
  void clear_w();
  static const int kWFieldNumber = 4;
  const ::std::string& w() const;
  void set_w(const ::std::string& value);
  #if LANG_CXX11
  void set_w(::std::string&& value);
  #endif
  void set_w(const char* value);
  void set_w(const void* value, size_t size);
  ::std::string* mutable_w();
  ::std::string* release_w();
  void set_allocated_w(::std::string* w);

  // required bytes s = 5;
  bool has_s() const;
  void clear_s();
  static const int kSFieldNumber = 5;
  const ::std::string& s() const;
  void set_s(const ::std::string& value);
  #if LANG_CXX11
  void set_s(::std::string&& value);
  #endif
  void set_s(const char* value);
  void set_s(const void* value, size_t size);
  ::std::string* mutable_s();
  ::std::string* release_s();
  void set_allocated_s(::std::string* s);

  // required bytes a = 6;
  bool has_a() const;
  void clear_a();
  static const int kAFieldNumber = 6;
  const ::std::string& a() const;
  void set_a(const ::std::string& value);
  #if LANG_CXX11
  void set_a(::std::string&& value);
  #endif
  void set_a(const char* value);
  void set_a(const void* value, size_t size);
  ::std::string* mutable_a();
  ::std::string* release_a();
  void set_allocated_a(::std::string* a);

  // required bytes d = 7;
  bool has_d() const;
  void clear_d();
  static const int kDFieldNumber = 7;
  const ::std::string& d() const;
  void set_d(const ::std::string& value);
  #if LANG_CXX11
  void set_d(::std::string&& value);
  #endif
  void set_d(const char* value);
  void set_d(const void* value, size_t size);
  ::std::string* mutable_d();
  ::std::string* release_d();
  void set_allocated_d(::std::string* d);

  // required bytes jump = 8;
  bool has_jump() const;
  void clear_jump();
  static const int kJumpFieldNumber = 8;
  const ::std::string& jump() const;
  void set_jump(const ::std::string& value);
  #if LANG_CXX11
  void set_jump(::std::string&& value);
  #endif
  void set_jump(const char* value);
  void set_jump(const void* value, size_t size);
  ::std::string* mutable_jump();
  ::std::string* release_jump();
  void set_allocated_jump(::std::string* jump);

  // required bytes break = 9;
  bool has_break_() const;
  void clear_break_();
  static const int kBreakFieldNumber = 9;
  const ::std::string& break_() const;
  void set_break_(const ::std::string& value);
  #if LANG_CXX11
  void set_break_(::std::string&& value);
  #endif
  void set_break_(const char* value);
  void set_break_(const void* value, size_t size);
  ::std::string* mutable_break_();
  ::std::string* release_break_();
  void set_allocated_break_(::std::string* break_);

  // required bytes attack = 10;
  bool has_attack() const;
  void clear_attack();
  static const int kAttackFieldNumber = 10;
  const ::std::string& attack() const;
  void set_attack(const ::std::string& value);
  #if LANG_CXX11
  void set_attack(::std::string&& value);
  #endif
  void set_attack(const char* value);
  void set_attack(const void* value, size_t size);
  ::std::string* mutable_attack();
  ::std::string* release_attack();
  void set_allocated_attack(::std::string* attack);

  // required bytes e = 11;
  bool has_e() const;
  void clear_e();
  static const int kEFieldNumber = 11;
  const ::std::string& e() const;
  void set_e(const ::std::string& value);
  #if LANG_CXX11
  void set_e(::std::string&& value);
  #endif
  void set_e(const char* value);
  void set_e(const void* value, size_t size);
  ::std::string* mutable_e();
  ::std::string* release_e();
  void set_allocated_e(::std::string* e);

  // required bytes r = 12;
  bool has_r() const;
  void clear_r();
  static const int kRFieldNumber = 12;
  const ::std::string& r() const;
  void set_r(const ::std::string& value);
  #if LANG_CXX11
  void set_r(::std::string&& value);
  #endif
  void set_r(const char* value);
  void set_r(const void* value, size_t size);
  ::std::string* mutable_r();
  ::std::string* release_r();
  void set_allocated_r(::std::string* r);

  // required bytes y = 13;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 13;
  const ::std::string& y() const;
  void set_y(const ::std::string& value);
  #if LANG_CXX11
  void set_y(::std::string&& value);
  #endif
  void set_y(const char* value);
  void set_y(const void* value, size_t size);
  ::std::string* mutable_y();
  ::std::string* release_y();
  void set_allocated_y(::std::string* y);

  // required bytes space = 14;
  bool has_space() const;
  void clear_space();
  static const int kSpaceFieldNumber = 14;
  const ::std::string& space() const;
  void set_space(const ::std::string& value);
  #if LANG_CXX11
  void set_space(::std::string&& value);
  #endif
  void set_space(const char* value);
  void set_space(const void* value, size_t size);
  ::std::string* mutable_space();
  ::std::string* release_space();
  void set_allocated_space(::std::string* space);

  // required bytes c = 15;
  bool has_c() const;
  void clear_c();
  static const int kCFieldNumber = 15;
  const ::std::string& c() const;
  void set_c(const ::std::string& value);
  #if LANG_CXX11
  void set_c(::std::string&& value);
  #endif
  void set_c(const char* value);
  void set_c(const void* value, size_t size);
  ::std::string* mutable_c();
  ::std::string* release_c();
  void set_allocated_c(::std::string* c);

  // required .Vector2_ JoyStick = 2;
  bool has_joystick() const;
  void clear_joystick();
  static const int kJoyStickFieldNumber = 2;
  const ::Vector2_& joystick() const;
  ::Vector2_* release_joystick();
  ::Vector2_* mutable_joystick();
  void set_allocated_joystick(::Vector2_* joystick);

  // required .Vector2_ MouseDelta = 3;
  bool has_mousedelta() const;
  void clear_mousedelta();
  static const int kMouseDeltaFieldNumber = 3;
  const ::Vector2_& mousedelta() const;
  ::Vector2_* release_mousedelta();
  ::Vector2_* mutable_mousedelta();
  void set_allocated_mousedelta(::Vector2_* mousedelta);

  // @@protoc_insertion_point(class_scope:InputFrame)
 private:
  void set_has_joystick();
  void clear_has_joystick();
  void set_has_mousedelta();
  void clear_has_mousedelta();
  void set_has_w();
  void clear_has_w();
  void set_has_s();
  void clear_has_s();
  void set_has_a();
  void clear_has_a();
  void set_has_d();
  void clear_has_d();
  void set_has_jump();
  void clear_has_jump();
  void set_has_break_();
  void clear_has_break_();
  void set_has_attack();
  void clear_has_attack();
  void set_has_e();
  void clear_has_e();
  void set_has_r();
  void clear_has_r();
  void set_has_y();
  void clear_has_y();
  void set_has_space();
  void clear_has_space();
  void set_has_c();
  void clear_has_c();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr w_;
  ::google::protobuf::internal::ArenaStringPtr s_;
  ::google::protobuf::internal::ArenaStringPtr a_;
  ::google::protobuf::internal::ArenaStringPtr d_;
  ::google::protobuf::internal::ArenaStringPtr jump_;
  ::google::protobuf::internal::ArenaStringPtr break__;
  ::google::protobuf::internal::ArenaStringPtr attack_;
  ::google::protobuf::internal::ArenaStringPtr e_;
  ::google::protobuf::internal::ArenaStringPtr r_;
  ::google::protobuf::internal::ArenaStringPtr y_;
  ::google::protobuf::internal::ArenaStringPtr space_;
  ::google::protobuf::internal::ArenaStringPtr c_;
  ::Vector2_* joystick_;
  ::Vector2_* mousedelta_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsInputFrameImpl();
};
// -------------------------------------------------------------------

class ChatMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ChatMsg) */ {
 public:
  ChatMsg();
  virtual ~ChatMsg();

  ChatMsg(const ChatMsg& from);

  inline ChatMsg& operator=(const ChatMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChatMsg(ChatMsg&& from) noexcept
    : ChatMsg() {
    *this = ::std::move(from);
  }

  inline ChatMsg& operator=(ChatMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChatMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChatMsg* internal_default_instance() {
    return reinterpret_cast<const ChatMsg*>(
               &_ChatMsg_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    37;

  void Swap(ChatMsg* other);
  friend void swap(ChatMsg& a, ChatMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChatMsg* New() const PROTOBUF_FINAL { return New(NULL); }

  ChatMsg* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ChatMsg& from);
  void MergeFrom(const ChatMsg& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ChatMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string chatMessage = 3;
  bool has_chatmessage() const;
  void clear_chatmessage();
  static const int kChatMessageFieldNumber = 3;
  const ::std::string& chatmessage() const;
  void set_chatmessage(const ::std::string& value);
  #if LANG_CXX11
  void set_chatmessage(::std::string&& value);
  #endif
  void set_chatmessage(const char* value);
  void set_chatmessage(const char* value, size_t size);
  ::std::string* mutable_chatmessage();
  ::std::string* release_chatmessage();
  void set_allocated_chatmessage(::std::string* chatmessage);

  // required uint32 playerId = 1;
  bool has_playerid() const;
  void clear_playerid();
  static const int kPlayerIdFieldNumber = 1;
  ::google::protobuf::uint32 playerid() const;
  void set_playerid(::google::protobuf::uint32 value);

  // required uint32 channelType = 2;
  bool has_channeltype() const;
  void clear_channeltype();
  static const int kChannelTypeFieldNumber = 2;
  ::google::protobuf::uint32 channeltype() const;
  void set_channeltype(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ChatMsg)
 private:
  void set_has_playerid();
  void clear_has_playerid();
  void set_has_channeltype();
  void clear_has_channeltype();
  void set_has_chatmessage();
  void clear_has_chatmessage();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr chatmessage_;
  ::google::protobuf::uint32 playerid_;
  ::google::protobuf::uint32 channeltype_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsChatMsgImpl();
};
// -------------------------------------------------------------------

class AudioChatMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:AudioChatMsg) */ {
 public:
  AudioChatMsg();
  virtual ~AudioChatMsg();

  AudioChatMsg(const AudioChatMsg& from);

  inline AudioChatMsg& operator=(const AudioChatMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AudioChatMsg(AudioChatMsg&& from) noexcept
    : AudioChatMsg() {
    *this = ::std::move(from);
  }

  inline AudioChatMsg& operator=(AudioChatMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AudioChatMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AudioChatMsg* internal_default_instance() {
    return reinterpret_cast<const AudioChatMsg*>(
               &_AudioChatMsg_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    38;

  void Swap(AudioChatMsg* other);
  friend void swap(AudioChatMsg& a, AudioChatMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AudioChatMsg* New() const PROTOBUF_FINAL { return New(NULL); }

  AudioChatMsg* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AudioChatMsg& from);
  void MergeFrom(const AudioChatMsg& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AudioChatMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float audio_data = 3;
  int audio_data_size() const;
  void clear_audio_data();
  static const int kAudioDataFieldNumber = 3;
  float audio_data(int index) const;
  void set_audio_data(int index, float value);
  void add_audio_data(float value);
  const ::google::protobuf::RepeatedField< float >&
      audio_data() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_audio_data();

  // required uint32 playerId = 1;
  bool has_playerid() const;
  void clear_playerid();
  static const int kPlayerIdFieldNumber = 1;
  ::google::protobuf::uint32 playerid() const;
  void set_playerid(::google::protobuf::uint32 value);

  // required uint32 type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::google::protobuf::uint32 type() const;
  void set_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:AudioChatMsg)
 private:
  void set_has_playerid();
  void clear_has_playerid();
  void set_has_type();
  void clear_has_type();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< float > audio_data_;
  ::google::protobuf::uint32 playerid_;
  ::google::protobuf::uint32 type_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsAudioChatMsgImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MeteorMsg

// required .MeteorMsg.MsgType cmd = 1;
inline bool MeteorMsg::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MeteorMsg::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MeteorMsg::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MeteorMsg::clear_cmd() {
  cmd_ = 10;
  clear_has_cmd();
}
inline ::MeteorMsg_MsgType MeteorMsg::cmd() const {
  // @@protoc_insertion_point(field_get:MeteorMsg.cmd)
  return static_cast< ::MeteorMsg_MsgType >(cmd_);
}
inline void MeteorMsg::set_cmd(::MeteorMsg_MsgType value) {
  assert(::MeteorMsg_MsgType_IsValid(value));
  set_has_cmd();
  cmd_ = value;
  // @@protoc_insertion_point(field_set:MeteorMsg.cmd)
}

// -------------------------------------------------------------------

// EnterQueueRsp

// required uint32 result = 1;
inline bool EnterQueueRsp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterQueueRsp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnterQueueRsp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnterQueueRsp::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 EnterQueueRsp::result() const {
  // @@protoc_insertion_point(field_get:EnterQueueRsp.result)
  return result_;
}
inline void EnterQueueRsp::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:EnterQueueRsp.result)
}

// required uint32 playerId = 2;
inline bool EnterQueueRsp::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnterQueueRsp::set_has_playerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnterQueueRsp::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnterQueueRsp::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 EnterQueueRsp::playerid() const {
  // @@protoc_insertion_point(field_get:EnterQueueRsp.playerId)
  return playerid_;
}
inline void EnterQueueRsp::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
  // @@protoc_insertion_point(field_set:EnterQueueRsp.playerId)
}

// required uint32 playerInQueue = 3;
inline bool EnterQueueRsp::has_playerinqueue() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EnterQueueRsp::set_has_playerinqueue() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EnterQueueRsp::clear_has_playerinqueue() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EnterQueueRsp::clear_playerinqueue() {
  playerinqueue_ = 0u;
  clear_has_playerinqueue();
}
inline ::google::protobuf::uint32 EnterQueueRsp::playerinqueue() const {
  // @@protoc_insertion_point(field_get:EnterQueueRsp.playerInQueue)
  return playerinqueue_;
}
inline void EnterQueueRsp::set_playerinqueue(::google::protobuf::uint32 value) {
  set_has_playerinqueue();
  playerinqueue_ = value;
  // @@protoc_insertion_point(field_set:EnterQueueRsp.playerInQueue)
}

// -------------------------------------------------------------------

// OnBattleBegin

// repeated uint32 TeamMemberAId = 1;
inline int OnBattleBegin::teammemberaid_size() const {
  return teammemberaid_.size();
}
inline void OnBattleBegin::clear_teammemberaid() {
  teammemberaid_.Clear();
}
inline ::google::protobuf::uint32 OnBattleBegin::teammemberaid(int index) const {
  // @@protoc_insertion_point(field_get:OnBattleBegin.TeamMemberAId)
  return teammemberaid_.Get(index);
}
inline void OnBattleBegin::set_teammemberaid(int index, ::google::protobuf::uint32 value) {
  teammemberaid_.Set(index, value);
  // @@protoc_insertion_point(field_set:OnBattleBegin.TeamMemberAId)
}
inline void OnBattleBegin::add_teammemberaid(::google::protobuf::uint32 value) {
  teammemberaid_.Add(value);
  // @@protoc_insertion_point(field_add:OnBattleBegin.TeamMemberAId)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
OnBattleBegin::teammemberaid() const {
  // @@protoc_insertion_point(field_list:OnBattleBegin.TeamMemberAId)
  return teammemberaid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
OnBattleBegin::mutable_teammemberaid() {
  // @@protoc_insertion_point(field_mutable_list:OnBattleBegin.TeamMemberAId)
  return &teammemberaid_;
}

// repeated uint32 TeamMemberBId = 2;
inline int OnBattleBegin::teammemberbid_size() const {
  return teammemberbid_.size();
}
inline void OnBattleBegin::clear_teammemberbid() {
  teammemberbid_.Clear();
}
inline ::google::protobuf::uint32 OnBattleBegin::teammemberbid(int index) const {
  // @@protoc_insertion_point(field_get:OnBattleBegin.TeamMemberBId)
  return teammemberbid_.Get(index);
}
inline void OnBattleBegin::set_teammemberbid(int index, ::google::protobuf::uint32 value) {
  teammemberbid_.Set(index, value);
  // @@protoc_insertion_point(field_set:OnBattleBegin.TeamMemberBId)
}
inline void OnBattleBegin::add_teammemberbid(::google::protobuf::uint32 value) {
  teammemberbid_.Add(value);
  // @@protoc_insertion_point(field_add:OnBattleBegin.TeamMemberBId)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
OnBattleBegin::teammemberbid() const {
  // @@protoc_insertion_point(field_list:OnBattleBegin.TeamMemberBId)
  return teammemberbid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
OnBattleBegin::mutable_teammemberbid() {
  // @@protoc_insertion_point(field_mutable_list:OnBattleBegin.TeamMemberBId)
  return &teammemberbid_;
}

// repeated string TeamMemberA = 3;
inline int OnBattleBegin::teammembera_size() const {
  return teammembera_.size();
}
inline void OnBattleBegin::clear_teammembera() {
  teammembera_.Clear();
}
inline const ::std::string& OnBattleBegin::teammembera(int index) const {
  // @@protoc_insertion_point(field_get:OnBattleBegin.TeamMemberA)
  return teammembera_.Get(index);
}
inline ::std::string* OnBattleBegin::mutable_teammembera(int index) {
  // @@protoc_insertion_point(field_mutable:OnBattleBegin.TeamMemberA)
  return teammembera_.Mutable(index);
}
inline void OnBattleBegin::set_teammembera(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:OnBattleBegin.TeamMemberA)
  teammembera_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void OnBattleBegin::set_teammembera(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:OnBattleBegin.TeamMemberA)
  teammembera_.Mutable(index)->assign(std::move(value));
}
#endif
inline void OnBattleBegin::set_teammembera(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  teammembera_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:OnBattleBegin.TeamMemberA)
}
inline void OnBattleBegin::set_teammembera(int index, const char* value, size_t size) {
  teammembera_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:OnBattleBegin.TeamMemberA)
}
inline ::std::string* OnBattleBegin::add_teammembera() {
  // @@protoc_insertion_point(field_add_mutable:OnBattleBegin.TeamMemberA)
  return teammembera_.Add();
}
inline void OnBattleBegin::add_teammembera(const ::std::string& value) {
  teammembera_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:OnBattleBegin.TeamMemberA)
}
#if LANG_CXX11
inline void OnBattleBegin::add_teammembera(::std::string&& value) {
  teammembera_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:OnBattleBegin.TeamMemberA)
}
#endif
inline void OnBattleBegin::add_teammembera(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  teammembera_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:OnBattleBegin.TeamMemberA)
}
inline void OnBattleBegin::add_teammembera(const char* value, size_t size) {
  teammembera_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:OnBattleBegin.TeamMemberA)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
OnBattleBegin::teammembera() const {
  // @@protoc_insertion_point(field_list:OnBattleBegin.TeamMemberA)
  return teammembera_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
OnBattleBegin::mutable_teammembera() {
  // @@protoc_insertion_point(field_mutable_list:OnBattleBegin.TeamMemberA)
  return &teammembera_;
}

// repeated string TeamMemberB = 4;
inline int OnBattleBegin::teammemberb_size() const {
  return teammemberb_.size();
}
inline void OnBattleBegin::clear_teammemberb() {
  teammemberb_.Clear();
}
inline const ::std::string& OnBattleBegin::teammemberb(int index) const {
  // @@protoc_insertion_point(field_get:OnBattleBegin.TeamMemberB)
  return teammemberb_.Get(index);
}
inline ::std::string* OnBattleBegin::mutable_teammemberb(int index) {
  // @@protoc_insertion_point(field_mutable:OnBattleBegin.TeamMemberB)
  return teammemberb_.Mutable(index);
}
inline void OnBattleBegin::set_teammemberb(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:OnBattleBegin.TeamMemberB)
  teammemberb_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void OnBattleBegin::set_teammemberb(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:OnBattleBegin.TeamMemberB)
  teammemberb_.Mutable(index)->assign(std::move(value));
}
#endif
inline void OnBattleBegin::set_teammemberb(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  teammemberb_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:OnBattleBegin.TeamMemberB)
}
inline void OnBattleBegin::set_teammemberb(int index, const char* value, size_t size) {
  teammemberb_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:OnBattleBegin.TeamMemberB)
}
inline ::std::string* OnBattleBegin::add_teammemberb() {
  // @@protoc_insertion_point(field_add_mutable:OnBattleBegin.TeamMemberB)
  return teammemberb_.Add();
}
inline void OnBattleBegin::add_teammemberb(const ::std::string& value) {
  teammemberb_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:OnBattleBegin.TeamMemberB)
}
#if LANG_CXX11
inline void OnBattleBegin::add_teammemberb(::std::string&& value) {
  teammemberb_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:OnBattleBegin.TeamMemberB)
}
#endif
inline void OnBattleBegin::add_teammemberb(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  teammemberb_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:OnBattleBegin.TeamMemberB)
}
inline void OnBattleBegin::add_teammemberb(const char* value, size_t size) {
  teammemberb_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:OnBattleBegin.TeamMemberB)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
OnBattleBegin::teammemberb() const {
  // @@protoc_insertion_point(field_list:OnBattleBegin.TeamMemberB)
  return teammemberb_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
OnBattleBegin::mutable_teammemberb() {
  // @@protoc_insertion_point(field_mutable_list:OnBattleBegin.TeamMemberB)
  return &teammemberb_;
}

// -------------------------------------------------------------------

// UserSelectRole

// required uint32 playerId = 1;
inline bool UserSelectRole::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserSelectRole::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserSelectRole::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserSelectRole::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 UserSelectRole::playerid() const {
  // @@protoc_insertion_point(field_get:UserSelectRole.playerId)
  return playerid_;
}
inline void UserSelectRole::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
  // @@protoc_insertion_point(field_set:UserSelectRole.playerId)
}

// required uint32 HeroId = 2;
inline bool UserSelectRole::has_heroid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserSelectRole::set_has_heroid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserSelectRole::clear_has_heroid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserSelectRole::clear_heroid() {
  heroid_ = 0u;
  clear_has_heroid();
}
inline ::google::protobuf::uint32 UserSelectRole::heroid() const {
  // @@protoc_insertion_point(field_get:UserSelectRole.HeroId)
  return heroid_;
}
inline void UserSelectRole::set_heroid(::google::protobuf::uint32 value) {
  set_has_heroid();
  heroid_ = value;
  // @@protoc_insertion_point(field_set:UserSelectRole.HeroId)
}

// -------------------------------------------------------------------

// UserSelectSkill

// required uint32 playerId = 1;
inline bool UserSelectSkill::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserSelectSkill::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserSelectSkill::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserSelectSkill::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 UserSelectSkill::playerid() const {
  // @@protoc_insertion_point(field_get:UserSelectSkill.playerId)
  return playerid_;
}
inline void UserSelectSkill::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
  // @@protoc_insertion_point(field_set:UserSelectSkill.playerId)
}

// required uint32 SkillId = 2;
inline bool UserSelectSkill::has_skillid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserSelectSkill::set_has_skillid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserSelectSkill::clear_has_skillid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserSelectSkill::clear_skillid() {
  skillid_ = 0u;
  clear_has_skillid();
}
inline ::google::protobuf::uint32 UserSelectSkill::skillid() const {
  // @@protoc_insertion_point(field_get:UserSelectSkill.SkillId)
  return skillid_;
}
inline void UserSelectSkill::set_skillid(::google::protobuf::uint32 value) {
  set_has_skillid();
  skillid_ = value;
  // @@protoc_insertion_point(field_set:UserSelectSkill.SkillId)
}

// -------------------------------------------------------------------

// UserSelectSkin

// required uint32 playerId = 1;
inline bool UserSelectSkin::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserSelectSkin::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserSelectSkin::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserSelectSkin::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 UserSelectSkin::playerid() const {
  // @@protoc_insertion_point(field_get:UserSelectSkin.playerId)
  return playerid_;
}
inline void UserSelectSkin::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
  // @@protoc_insertion_point(field_set:UserSelectSkin.playerId)
}

// required uint32 Skin = 2;
inline bool UserSelectSkin::has_skin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserSelectSkin::set_has_skin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserSelectSkin::clear_has_skin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserSelectSkin::clear_skin() {
  skin_ = 0u;
  clear_has_skin();
}
inline ::google::protobuf::uint32 UserSelectSkin::skin() const {
  // @@protoc_insertion_point(field_get:UserSelectSkin.Skin)
  return skin_;
}
inline void UserSelectSkin::set_skin(::google::protobuf::uint32 value) {
  set_has_skin();
  skin_ = value;
  // @@protoc_insertion_point(field_set:UserSelectSkin.Skin)
}

// -------------------------------------------------------------------

// OnBattleCanceled

// required uint32 reason = 1;
inline bool OnBattleCanceled::has_reason() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OnBattleCanceled::set_has_reason() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OnBattleCanceled::clear_has_reason() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OnBattleCanceled::clear_reason() {
  reason_ = 0u;
  clear_has_reason();
}
inline ::google::protobuf::uint32 OnBattleCanceled::reason() const {
  // @@protoc_insertion_point(field_get:OnBattleCanceled.reason)
  return reason_;
}
inline void OnBattleCanceled::set_reason(::google::protobuf::uint32 value) {
  set_has_reason();
  reason_ = value;
  // @@protoc_insertion_point(field_set:OnBattleCanceled.reason)
}

// -------------------------------------------------------------------

// OnBattleLoading

// repeated uint32 playerId = 1;
inline int OnBattleLoading::playerid_size() const {
  return playerid_.size();
}
inline void OnBattleLoading::clear_playerid() {
  playerid_.Clear();
}
inline ::google::protobuf::uint32 OnBattleLoading::playerid(int index) const {
  // @@protoc_insertion_point(field_get:OnBattleLoading.playerId)
  return playerid_.Get(index);
}
inline void OnBattleLoading::set_playerid(int index, ::google::protobuf::uint32 value) {
  playerid_.Set(index, value);
  // @@protoc_insertion_point(field_set:OnBattleLoading.playerId)
}
inline void OnBattleLoading::add_playerid(::google::protobuf::uint32 value) {
  playerid_.Add(value);
  // @@protoc_insertion_point(field_add:OnBattleLoading.playerId)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
OnBattleLoading::playerid() const {
  // @@protoc_insertion_point(field_list:OnBattleLoading.playerId)
  return playerid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
OnBattleLoading::mutable_playerid() {
  // @@protoc_insertion_point(field_mutable_list:OnBattleLoading.playerId)
  return &playerid_;
}

// repeated uint32 percent = 2;
inline int OnBattleLoading::percent_size() const {
  return percent_.size();
}
inline void OnBattleLoading::clear_percent() {
  percent_.Clear();
}
inline ::google::protobuf::uint32 OnBattleLoading::percent(int index) const {
  // @@protoc_insertion_point(field_get:OnBattleLoading.percent)
  return percent_.Get(index);
}
inline void OnBattleLoading::set_percent(int index, ::google::protobuf::uint32 value) {
  percent_.Set(index, value);
  // @@protoc_insertion_point(field_set:OnBattleLoading.percent)
}
inline void OnBattleLoading::add_percent(::google::protobuf::uint32 value) {
  percent_.Add(value);
  // @@protoc_insertion_point(field_add:OnBattleLoading.percent)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
OnBattleLoading::percent() const {
  // @@protoc_insertion_point(field_list:OnBattleLoading.percent)
  return percent_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
OnBattleLoading::mutable_percent() {
  // @@protoc_insertion_point(field_mutable_list:OnBattleLoading.percent)
  return &percent_;
}

// -------------------------------------------------------------------

// OnBattleResult

// required uint32 result = 1;
inline bool OnBattleResult::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OnBattleResult::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OnBattleResult::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OnBattleResult::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 OnBattleResult::result() const {
  // @@protoc_insertion_point(field_get:OnBattleResult.result)
  return result_;
}
inline void OnBattleResult::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:OnBattleResult.result)
}

// -------------------------------------------------------------------

// OnBattleResultDetail

// -------------------------------------------------------------------

// PlayerSellItem

// required uint32 playerId = 1;
inline bool PlayerSellItem::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerSellItem::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerSellItem::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerSellItem::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 PlayerSellItem::playerid() const {
  // @@protoc_insertion_point(field_get:PlayerSellItem.playerId)
  return playerid_;
}
inline void PlayerSellItem::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
  // @@protoc_insertion_point(field_set:PlayerSellItem.playerId)
}

// required uint32 itemId = 2;
inline bool PlayerSellItem::has_itemid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerSellItem::set_has_itemid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerSellItem::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerSellItem::clear_itemid() {
  itemid_ = 0u;
  clear_has_itemid();
}
inline ::google::protobuf::uint32 PlayerSellItem::itemid() const {
  // @@protoc_insertion_point(field_get:PlayerSellItem.itemId)
  return itemid_;
}
inline void PlayerSellItem::set_itemid(::google::protobuf::uint32 value) {
  set_has_itemid();
  itemid_ = value;
  // @@protoc_insertion_point(field_set:PlayerSellItem.itemId)
}

// -------------------------------------------------------------------

// PlayerBuyItem

// required uint32 playerId = 1;
inline bool PlayerBuyItem::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerBuyItem::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerBuyItem::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerBuyItem::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 PlayerBuyItem::playerid() const {
  // @@protoc_insertion_point(field_get:PlayerBuyItem.playerId)
  return playerid_;
}
inline void PlayerBuyItem::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
  // @@protoc_insertion_point(field_set:PlayerBuyItem.playerId)
}

// required uint32 itemId = 2;
inline bool PlayerBuyItem::has_itemid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerBuyItem::set_has_itemid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerBuyItem::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerBuyItem::clear_itemid() {
  itemid_ = 0u;
  clear_has_itemid();
}
inline ::google::protobuf::uint32 PlayerBuyItem::itemid() const {
  // @@protoc_insertion_point(field_get:PlayerBuyItem.itemId)
  return itemid_;
}
inline void PlayerBuyItem::set_itemid(::google::protobuf::uint32 value) {
  set_has_itemid();
  itemid_ = value;
  // @@protoc_insertion_point(field_set:PlayerBuyItem.itemId)
}

// -------------------------------------------------------------------

// OnPlayerFetchInput

// repeated .TurnFrames frames = 1;
inline int OnPlayerFetchInput::frames_size() const {
  return frames_.size();
}
inline void OnPlayerFetchInput::clear_frames() {
  frames_.Clear();
}
inline const ::TurnFrames& OnPlayerFetchInput::frames(int index) const {
  // @@protoc_insertion_point(field_get:OnPlayerFetchInput.frames)
  return frames_.Get(index);
}
inline ::TurnFrames* OnPlayerFetchInput::mutable_frames(int index) {
  // @@protoc_insertion_point(field_mutable:OnPlayerFetchInput.frames)
  return frames_.Mutable(index);
}
inline ::TurnFrames* OnPlayerFetchInput::add_frames() {
  // @@protoc_insertion_point(field_add:OnPlayerFetchInput.frames)
  return frames_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::TurnFrames >*
OnPlayerFetchInput::mutable_frames() {
  // @@protoc_insertion_point(field_mutable_list:OnPlayerFetchInput.frames)
  return &frames_;
}
inline const ::google::protobuf::RepeatedPtrField< ::TurnFrames >&
OnPlayerFetchInput::frames() const {
  // @@protoc_insertion_point(field_list:OnPlayerFetchInput.frames)
  return frames_;
}

// -------------------------------------------------------------------

// ProtocolVerifyReq

// required uint32 protocol = 1;
inline bool ProtocolVerifyReq::has_protocol() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtocolVerifyReq::set_has_protocol() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtocolVerifyReq::clear_has_protocol() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtocolVerifyReq::clear_protocol() {
  protocol_ = 0u;
  clear_has_protocol();
}
inline ::google::protobuf::uint32 ProtocolVerifyReq::protocol() const {
  // @@protoc_insertion_point(field_get:ProtocolVerifyReq.protocol)
  return protocol_;
}
inline void ProtocolVerifyReq::set_protocol(::google::protobuf::uint32 value) {
  set_has_protocol();
  protocol_ = value;
  // @@protoc_insertion_point(field_set:ProtocolVerifyReq.protocol)
}

// required string data = 2;
inline bool ProtocolVerifyReq::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtocolVerifyReq::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtocolVerifyReq::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtocolVerifyReq::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
inline const ::std::string& ProtocolVerifyReq::data() const {
  // @@protoc_insertion_point(field_get:ProtocolVerifyReq.data)
  return data_.GetNoArena();
}
inline void ProtocolVerifyReq::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ProtocolVerifyReq.data)
}
#if LANG_CXX11
inline void ProtocolVerifyReq::set_data(::std::string&& value) {
  set_has_data();
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ProtocolVerifyReq.data)
}
#endif
inline void ProtocolVerifyReq::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ProtocolVerifyReq.data)
}
inline void ProtocolVerifyReq::set_data(const char* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ProtocolVerifyReq.data)
}
inline ::std::string* ProtocolVerifyReq::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:ProtocolVerifyReq.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProtocolVerifyReq::release_data() {
  // @@protoc_insertion_point(field_release:ProtocolVerifyReq.data)
  clear_has_data();
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProtocolVerifyReq::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:ProtocolVerifyReq.data)
}

// -------------------------------------------------------------------

// ProtocolVerifyRsp

// required uint32 result = 1;
inline bool ProtocolVerifyRsp::has_result() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProtocolVerifyRsp::set_has_result() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProtocolVerifyRsp::clear_has_result() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProtocolVerifyRsp::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 ProtocolVerifyRsp::result() const {
  // @@protoc_insertion_point(field_get:ProtocolVerifyRsp.result)
  return result_;
}
inline void ProtocolVerifyRsp::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:ProtocolVerifyRsp.result)
}

// required string message = 2;
inline bool ProtocolVerifyRsp::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtocolVerifyRsp::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtocolVerifyRsp::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtocolVerifyRsp::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& ProtocolVerifyRsp::message() const {
  // @@protoc_insertion_point(field_get:ProtocolVerifyRsp.message)
  return message_.GetNoArena();
}
inline void ProtocolVerifyRsp::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ProtocolVerifyRsp.message)
}
#if LANG_CXX11
inline void ProtocolVerifyRsp::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ProtocolVerifyRsp.message)
}
#endif
inline void ProtocolVerifyRsp::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ProtocolVerifyRsp.message)
}
inline void ProtocolVerifyRsp::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ProtocolVerifyRsp.message)
}
inline ::std::string* ProtocolVerifyRsp::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:ProtocolVerifyRsp.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProtocolVerifyRsp::release_message() {
  // @@protoc_insertion_point(field_release:ProtocolVerifyRsp.message)
  clear_has_message();
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProtocolVerifyRsp::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:ProtocolVerifyRsp.message)
}

// required string Secret = 3;
inline bool ProtocolVerifyRsp::has_secret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtocolVerifyRsp::set_has_secret() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtocolVerifyRsp::clear_has_secret() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtocolVerifyRsp::clear_secret() {
  secret_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_secret();
}
inline const ::std::string& ProtocolVerifyRsp::secret() const {
  // @@protoc_insertion_point(field_get:ProtocolVerifyRsp.Secret)
  return secret_.GetNoArena();
}
inline void ProtocolVerifyRsp::set_secret(const ::std::string& value) {
  set_has_secret();
  secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ProtocolVerifyRsp.Secret)
}
#if LANG_CXX11
inline void ProtocolVerifyRsp::set_secret(::std::string&& value) {
  set_has_secret();
  secret_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ProtocolVerifyRsp.Secret)
}
#endif
inline void ProtocolVerifyRsp::set_secret(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_secret();
  secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ProtocolVerifyRsp.Secret)
}
inline void ProtocolVerifyRsp::set_secret(const char* value, size_t size) {
  set_has_secret();
  secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ProtocolVerifyRsp.Secret)
}
inline ::std::string* ProtocolVerifyRsp::mutable_secret() {
  set_has_secret();
  // @@protoc_insertion_point(field_mutable:ProtocolVerifyRsp.Secret)
  return secret_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProtocolVerifyRsp::release_secret() {
  // @@protoc_insertion_point(field_release:ProtocolVerifyRsp.Secret)
  clear_has_secret();
  return secret_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProtocolVerifyRsp::set_allocated_secret(::std::string* secret) {
  if (secret != NULL) {
    set_has_secret();
  } else {
    clear_has_secret();
  }
  secret_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), secret);
  // @@protoc_insertion_point(field_set_allocated:ProtocolVerifyRsp.Secret)
}

// -------------------------------------------------------------------

// RoomInfo

// required uint32 roomId = 1;
inline bool RoomInfo::has_roomid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoomInfo::set_has_roomid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoomInfo::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoomInfo::clear_roomid() {
  roomid_ = 0u;
  clear_has_roomid();
}
inline ::google::protobuf::uint32 RoomInfo::roomid() const {
  // @@protoc_insertion_point(field_get:RoomInfo.roomId)
  return roomid_;
}
inline void RoomInfo::set_roomid(::google::protobuf::uint32 value) {
  set_has_roomid();
  roomid_ = value;
  // @@protoc_insertion_point(field_set:RoomInfo.roomId)
}

// required string roomName = 2;
inline bool RoomInfo::has_roomname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomInfo::set_has_roomname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomInfo::clear_has_roomname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomInfo::clear_roomname() {
  roomname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_roomname();
}
inline const ::std::string& RoomInfo::roomname() const {
  // @@protoc_insertion_point(field_get:RoomInfo.roomName)
  return roomname_.GetNoArena();
}
inline void RoomInfo::set_roomname(const ::std::string& value) {
  set_has_roomname();
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RoomInfo.roomName)
}
#if LANG_CXX11
inline void RoomInfo::set_roomname(::std::string&& value) {
  set_has_roomname();
  roomname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:RoomInfo.roomName)
}
#endif
inline void RoomInfo::set_roomname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_roomname();
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RoomInfo.roomName)
}
inline void RoomInfo::set_roomname(const char* value, size_t size) {
  set_has_roomname();
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RoomInfo.roomName)
}
inline ::std::string* RoomInfo::mutable_roomname() {
  set_has_roomname();
  // @@protoc_insertion_point(field_mutable:RoomInfo.roomName)
  return roomname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RoomInfo::release_roomname() {
  // @@protoc_insertion_point(field_release:RoomInfo.roomName)
  clear_has_roomname();
  return roomname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoomInfo::set_allocated_roomname(::std::string* roomname) {
  if (roomname != NULL) {
    set_has_roomname();
  } else {
    clear_has_roomname();
  }
  roomname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), roomname);
  // @@protoc_insertion_point(field_set_allocated:RoomInfo.roomName)
}

// required .RoomInfo.RoomRule rule = 3;
inline bool RoomInfo::has_rule() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RoomInfo::set_has_rule() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RoomInfo::clear_has_rule() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RoomInfo::clear_rule() {
  rule_ = 1;
  clear_has_rule();
}
inline ::RoomInfo_RoomRule RoomInfo::rule() const {
  // @@protoc_insertion_point(field_get:RoomInfo.rule)
  return static_cast< ::RoomInfo_RoomRule >(rule_);
}
inline void RoomInfo::set_rule(::RoomInfo_RoomRule value) {
  assert(::RoomInfo_RoomRule_IsValid(value));
  set_has_rule();
  rule_ = value;
  // @@protoc_insertion_point(field_set:RoomInfo.rule)
}

// required uint32 levelIdx = 4;
inline bool RoomInfo::has_levelidx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoomInfo::set_has_levelidx() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoomInfo::clear_has_levelidx() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoomInfo::clear_levelidx() {
  levelidx_ = 0u;
  clear_has_levelidx();
}
inline ::google::protobuf::uint32 RoomInfo::levelidx() const {
  // @@protoc_insertion_point(field_get:RoomInfo.levelIdx)
  return levelidx_;
}
inline void RoomInfo::set_levelidx(::google::protobuf::uint32 value) {
  set_has_levelidx();
  levelidx_ = value;
  // @@protoc_insertion_point(field_set:RoomInfo.levelIdx)
}

// required uint32 Group1 = 5;
inline bool RoomInfo::has_group1() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RoomInfo::set_has_group1() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RoomInfo::clear_has_group1() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RoomInfo::clear_group1() {
  group1_ = 0u;
  clear_has_group1();
}
inline ::google::protobuf::uint32 RoomInfo::group1() const {
  // @@protoc_insertion_point(field_get:RoomInfo.Group1)
  return group1_;
}
inline void RoomInfo::set_group1(::google::protobuf::uint32 value) {
  set_has_group1();
  group1_ = value;
  // @@protoc_insertion_point(field_set:RoomInfo.Group1)
}

// required uint32 Group2 = 6;
inline bool RoomInfo::has_group2() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RoomInfo::set_has_group2() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RoomInfo::clear_has_group2() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RoomInfo::clear_group2() {
  group2_ = 0u;
  clear_has_group2();
}
inline ::google::protobuf::uint32 RoomInfo::group2() const {
  // @@protoc_insertion_point(field_get:RoomInfo.Group2)
  return group2_;
}
inline void RoomInfo::set_group2(::google::protobuf::uint32 value) {
  set_has_group2();
  group2_ = value;
  // @@protoc_insertion_point(field_set:RoomInfo.Group2)
}

// required uint32 playerCount = 7;
inline bool RoomInfo::has_playercount() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RoomInfo::set_has_playercount() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RoomInfo::clear_has_playercount() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RoomInfo::clear_playercount() {
  playercount_ = 0u;
  clear_has_playercount();
}
inline ::google::protobuf::uint32 RoomInfo::playercount() const {
  // @@protoc_insertion_point(field_get:RoomInfo.playerCount)
  return playercount_;
}
inline void RoomInfo::set_playercount(::google::protobuf::uint32 value) {
  set_has_playercount();
  playercount_ = value;
  // @@protoc_insertion_point(field_set:RoomInfo.playerCount)
}

// required uint32 maxPlayer = 8;
inline bool RoomInfo::has_maxplayer() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RoomInfo::set_has_maxplayer() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RoomInfo::clear_has_maxplayer() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RoomInfo::clear_maxplayer() {
  maxplayer_ = 0u;
  clear_has_maxplayer();
}
inline ::google::protobuf::uint32 RoomInfo::maxplayer() const {
  // @@protoc_insertion_point(field_get:RoomInfo.maxPlayer)
  return maxplayer_;
}
inline void RoomInfo::set_maxplayer(::google::protobuf::uint32 value) {
  set_has_maxplayer();
  maxplayer_ = value;
  // @@protoc_insertion_point(field_set:RoomInfo.maxPlayer)
}

// -------------------------------------------------------------------

// OnLeaveRoomRsp

// required uint32 playerId = 2;
inline bool OnLeaveRoomRsp::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OnLeaveRoomRsp::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OnLeaveRoomRsp::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OnLeaveRoomRsp::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 OnLeaveRoomRsp::playerid() const {
  // @@protoc_insertion_point(field_get:OnLeaveRoomRsp.playerId)
  return playerid_;
}
inline void OnLeaveRoomRsp::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
  // @@protoc_insertion_point(field_set:OnLeaveRoomRsp.playerId)
}

// -------------------------------------------------------------------

// GetRoomRsp

// repeated .RoomInfo RoomInLobby = 2;
inline int GetRoomRsp::roominlobby_size() const {
  return roominlobby_.size();
}
inline void GetRoomRsp::clear_roominlobby() {
  roominlobby_.Clear();
}
inline const ::RoomInfo& GetRoomRsp::roominlobby(int index) const {
  // @@protoc_insertion_point(field_get:GetRoomRsp.RoomInLobby)
  return roominlobby_.Get(index);
}
inline ::RoomInfo* GetRoomRsp::mutable_roominlobby(int index) {
  // @@protoc_insertion_point(field_mutable:GetRoomRsp.RoomInLobby)
  return roominlobby_.Mutable(index);
}
inline ::RoomInfo* GetRoomRsp::add_roominlobby() {
  // @@protoc_insertion_point(field_add:GetRoomRsp.RoomInLobby)
  return roominlobby_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::RoomInfo >*
GetRoomRsp::mutable_roominlobby() {
  // @@protoc_insertion_point(field_mutable_list:GetRoomRsp.RoomInLobby)
  return &roominlobby_;
}
inline const ::google::protobuf::RepeatedPtrField< ::RoomInfo >&
GetRoomRsp::roominlobby() const {
  // @@protoc_insertion_point(field_list:GetRoomRsp.RoomInLobby)
  return roominlobby_;
}

// -------------------------------------------------------------------

// CreateRoomReq

// required uint32 maxPlayer = 2;
inline bool CreateRoomReq::has_maxplayer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreateRoomReq::set_has_maxplayer() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreateRoomReq::clear_has_maxplayer() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreateRoomReq::clear_maxplayer() {
  maxplayer_ = 0u;
  clear_has_maxplayer();
}
inline ::google::protobuf::uint32 CreateRoomReq::maxplayer() const {
  // @@protoc_insertion_point(field_get:CreateRoomReq.maxPlayer)
  return maxplayer_;
}
inline void CreateRoomReq::set_maxplayer(::google::protobuf::uint32 value) {
  set_has_maxplayer();
  maxplayer_ = value;
  // @@protoc_insertion_point(field_set:CreateRoomReq.maxPlayer)
}

// required uint32 levelIdx = 3;
inline bool CreateRoomReq::has_levelidx() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CreateRoomReq::set_has_levelidx() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CreateRoomReq::clear_has_levelidx() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CreateRoomReq::clear_levelidx() {
  levelidx_ = 0u;
  clear_has_levelidx();
}
inline ::google::protobuf::uint32 CreateRoomReq::levelidx() const {
  // @@protoc_insertion_point(field_get:CreateRoomReq.levelIdx)
  return levelidx_;
}
inline void CreateRoomReq::set_levelidx(::google::protobuf::uint32 value) {
  set_has_levelidx();
  levelidx_ = value;
  // @@protoc_insertion_point(field_set:CreateRoomReq.levelIdx)
}

// required uint32 rule = 4;
inline bool CreateRoomReq::has_rule() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CreateRoomReq::set_has_rule() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CreateRoomReq::clear_has_rule() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CreateRoomReq::clear_rule() {
  rule_ = 0u;
  clear_has_rule();
}
inline ::google::protobuf::uint32 CreateRoomReq::rule() const {
  // @@protoc_insertion_point(field_get:CreateRoomReq.rule)
  return rule_;
}
inline void CreateRoomReq::set_rule(::google::protobuf::uint32 value) {
  set_has_rule();
  rule_ = value;
  // @@protoc_insertion_point(field_set:CreateRoomReq.rule)
}

// required string roomName = 5;
inline bool CreateRoomReq::has_roomname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateRoomReq::set_has_roomname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateRoomReq::clear_has_roomname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateRoomReq::clear_roomname() {
  roomname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_roomname();
}
inline const ::std::string& CreateRoomReq::roomname() const {
  // @@protoc_insertion_point(field_get:CreateRoomReq.roomName)
  return roomname_.GetNoArena();
}
inline void CreateRoomReq::set_roomname(const ::std::string& value) {
  set_has_roomname();
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CreateRoomReq.roomName)
}
#if LANG_CXX11
inline void CreateRoomReq::set_roomname(::std::string&& value) {
  set_has_roomname();
  roomname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CreateRoomReq.roomName)
}
#endif
inline void CreateRoomReq::set_roomname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_roomname();
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CreateRoomReq.roomName)
}
inline void CreateRoomReq::set_roomname(const char* value, size_t size) {
  set_has_roomname();
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CreateRoomReq.roomName)
}
inline ::std::string* CreateRoomReq::mutable_roomname() {
  set_has_roomname();
  // @@protoc_insertion_point(field_mutable:CreateRoomReq.roomName)
  return roomname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateRoomReq::release_roomname() {
  // @@protoc_insertion_point(field_release:CreateRoomReq.roomName)
  clear_has_roomname();
  return roomname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateRoomReq::set_allocated_roomname(::std::string* roomname) {
  if (roomname != NULL) {
    set_has_roomname();
  } else {
    clear_has_roomname();
  }
  roomname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), roomname);
  // @@protoc_insertion_point(field_set_allocated:CreateRoomReq.roomName)
}

// required uint32 hpMax = 6;
inline bool CreateRoomReq::has_hpmax() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CreateRoomReq::set_has_hpmax() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CreateRoomReq::clear_has_hpmax() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CreateRoomReq::clear_hpmax() {
  hpmax_ = 0u;
  clear_has_hpmax();
}
inline ::google::protobuf::uint32 CreateRoomReq::hpmax() const {
  // @@protoc_insertion_point(field_get:CreateRoomReq.hpMax)
  return hpmax_;
}
inline void CreateRoomReq::set_hpmax(::google::protobuf::uint32 value) {
  set_has_hpmax();
  hpmax_ = value;
  // @@protoc_insertion_point(field_set:CreateRoomReq.hpMax)
}

// required uint32 roundTime = 7;
inline bool CreateRoomReq::has_roundtime() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CreateRoomReq::set_has_roundtime() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CreateRoomReq::clear_has_roundtime() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CreateRoomReq::clear_roundtime() {
  roundtime_ = 0u;
  clear_has_roundtime();
}
inline ::google::protobuf::uint32 CreateRoomReq::roundtime() const {
  // @@protoc_insertion_point(field_get:CreateRoomReq.roundTime)
  return roundtime_;
}
inline void CreateRoomReq::set_roundtime(::google::protobuf::uint32 value) {
  set_has_roundtime();
  roundtime_ = value;
  // @@protoc_insertion_point(field_set:CreateRoomReq.roundTime)
}

// optional string secret = 8;
inline bool CreateRoomReq::has_secret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateRoomReq::set_has_secret() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateRoomReq::clear_has_secret() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateRoomReq::clear_secret() {
  secret_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_secret();
}
inline const ::std::string& CreateRoomReq::secret() const {
  // @@protoc_insertion_point(field_get:CreateRoomReq.secret)
  return secret_.GetNoArena();
}
inline void CreateRoomReq::set_secret(const ::std::string& value) {
  set_has_secret();
  secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CreateRoomReq.secret)
}
#if LANG_CXX11
inline void CreateRoomReq::set_secret(::std::string&& value) {
  set_has_secret();
  secret_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CreateRoomReq.secret)
}
#endif
inline void CreateRoomReq::set_secret(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_secret();
  secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CreateRoomReq.secret)
}
inline void CreateRoomReq::set_secret(const char* value, size_t size) {
  set_has_secret();
  secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CreateRoomReq.secret)
}
inline ::std::string* CreateRoomReq::mutable_secret() {
  set_has_secret();
  // @@protoc_insertion_point(field_mutable:CreateRoomReq.secret)
  return secret_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateRoomReq::release_secret() {
  // @@protoc_insertion_point(field_release:CreateRoomReq.secret)
  clear_has_secret();
  return secret_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateRoomReq::set_allocated_secret(::std::string* secret) {
  if (secret != NULL) {
    set_has_secret();
  } else {
    clear_has_secret();
  }
  secret_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), secret);
  // @@protoc_insertion_point(field_set_allocated:CreateRoomReq.secret)
}

// -------------------------------------------------------------------

// CreateRoomRsp

// required uint32 result = 2;
inline bool CreateRoomRsp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateRoomRsp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateRoomRsp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateRoomRsp::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 CreateRoomRsp::result() const {
  // @@protoc_insertion_point(field_get:CreateRoomRsp.result)
  return result_;
}
inline void CreateRoomRsp::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:CreateRoomRsp.result)
}

// required uint32 roomId = 3;
inline bool CreateRoomRsp::has_roomid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateRoomRsp::set_has_roomid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateRoomRsp::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateRoomRsp::clear_roomid() {
  roomid_ = 0u;
  clear_has_roomid();
}
inline ::google::protobuf::uint32 CreateRoomRsp::roomid() const {
  // @@protoc_insertion_point(field_get:CreateRoomRsp.roomId)
  return roomid_;
}
inline void CreateRoomRsp::set_roomid(::google::protobuf::uint32 value) {
  set_has_roomid();
  roomid_ = value;
  // @@protoc_insertion_point(field_set:CreateRoomRsp.roomId)
}

// required uint32 levelId = 4;
inline bool CreateRoomRsp::has_levelid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreateRoomRsp::set_has_levelid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreateRoomRsp::clear_has_levelid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreateRoomRsp::clear_levelid() {
  levelid_ = 0u;
  clear_has_levelid();
}
inline ::google::protobuf::uint32 CreateRoomRsp::levelid() const {
  // @@protoc_insertion_point(field_get:CreateRoomRsp.levelId)
  return levelid_;
}
inline void CreateRoomRsp::set_levelid(::google::protobuf::uint32 value) {
  set_has_levelid();
  levelid_ = value;
  // @@protoc_insertion_point(field_set:CreateRoomRsp.levelId)
}

// -------------------------------------------------------------------

// JoinRoomReq

// required uint32 roomId = 2;
inline bool JoinRoomReq::has_roomid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void JoinRoomReq::set_has_roomid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void JoinRoomReq::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void JoinRoomReq::clear_roomid() {
  roomid_ = 0u;
  clear_has_roomid();
}
inline ::google::protobuf::uint32 JoinRoomReq::roomid() const {
  // @@protoc_insertion_point(field_get:JoinRoomReq.roomId)
  return roomid_;
}
inline void JoinRoomReq::set_roomid(::google::protobuf::uint32 value) {
  set_has_roomid();
  roomid_ = value;
  // @@protoc_insertion_point(field_set:JoinRoomReq.roomId)
}

// required string userNick = 3;
inline bool JoinRoomReq::has_usernick() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JoinRoomReq::set_has_usernick() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JoinRoomReq::clear_has_usernick() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JoinRoomReq::clear_usernick() {
  usernick_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_usernick();
}
inline const ::std::string& JoinRoomReq::usernick() const {
  // @@protoc_insertion_point(field_get:JoinRoomReq.userNick)
  return usernick_.GetNoArena();
}
inline void JoinRoomReq::set_usernick(const ::std::string& value) {
  set_has_usernick();
  usernick_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:JoinRoomReq.userNick)
}
#if LANG_CXX11
inline void JoinRoomReq::set_usernick(::std::string&& value) {
  set_has_usernick();
  usernick_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:JoinRoomReq.userNick)
}
#endif
inline void JoinRoomReq::set_usernick(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_usernick();
  usernick_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:JoinRoomReq.userNick)
}
inline void JoinRoomReq::set_usernick(const char* value, size_t size) {
  set_has_usernick();
  usernick_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:JoinRoomReq.userNick)
}
inline ::std::string* JoinRoomReq::mutable_usernick() {
  set_has_usernick();
  // @@protoc_insertion_point(field_mutable:JoinRoomReq.userNick)
  return usernick_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JoinRoomReq::release_usernick() {
  // @@protoc_insertion_point(field_release:JoinRoomReq.userNick)
  clear_has_usernick();
  return usernick_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JoinRoomReq::set_allocated_usernick(::std::string* usernick) {
  if (usernick != NULL) {
    set_has_usernick();
  } else {
    clear_has_usernick();
  }
  usernick_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), usernick);
  // @@protoc_insertion_point(field_set_allocated:JoinRoomReq.userNick)
}

// optional string secret = 4;
inline bool JoinRoomReq::has_secret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JoinRoomReq::set_has_secret() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JoinRoomReq::clear_has_secret() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JoinRoomReq::clear_secret() {
  secret_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_secret();
}
inline const ::std::string& JoinRoomReq::secret() const {
  // @@protoc_insertion_point(field_get:JoinRoomReq.secret)
  return secret_.GetNoArena();
}
inline void JoinRoomReq::set_secret(const ::std::string& value) {
  set_has_secret();
  secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:JoinRoomReq.secret)
}
#if LANG_CXX11
inline void JoinRoomReq::set_secret(::std::string&& value) {
  set_has_secret();
  secret_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:JoinRoomReq.secret)
}
#endif
inline void JoinRoomReq::set_secret(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_secret();
  secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:JoinRoomReq.secret)
}
inline void JoinRoomReq::set_secret(const char* value, size_t size) {
  set_has_secret();
  secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:JoinRoomReq.secret)
}
inline ::std::string* JoinRoomReq::mutable_secret() {
  set_has_secret();
  // @@protoc_insertion_point(field_mutable:JoinRoomReq.secret)
  return secret_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JoinRoomReq::release_secret() {
  // @@protoc_insertion_point(field_release:JoinRoomReq.secret)
  clear_has_secret();
  return secret_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JoinRoomReq::set_allocated_secret(::std::string* secret) {
  if (secret != NULL) {
    set_has_secret();
  } else {
    clear_has_secret();
  }
  secret_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), secret);
  // @@protoc_insertion_point(field_set_allocated:JoinRoomReq.secret)
}

// -------------------------------------------------------------------

// JoinRoomRsp

// required uint32 result = 2;
inline bool JoinRoomRsp::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JoinRoomRsp::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JoinRoomRsp::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JoinRoomRsp::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 JoinRoomRsp::result() const {
  // @@protoc_insertion_point(field_get:JoinRoomRsp.result)
  return result_;
}
inline void JoinRoomRsp::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:JoinRoomRsp.result)
}

// required uint32 reason = 3;
inline bool JoinRoomRsp::has_reason() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void JoinRoomRsp::set_has_reason() {
  _has_bits_[0] |= 0x00000004u;
}
inline void JoinRoomRsp::clear_has_reason() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void JoinRoomRsp::clear_reason() {
  reason_ = 0u;
  clear_has_reason();
}
inline ::google::protobuf::uint32 JoinRoomRsp::reason() const {
  // @@protoc_insertion_point(field_get:JoinRoomRsp.reason)
  return reason_;
}
inline void JoinRoomRsp::set_reason(::google::protobuf::uint32 value) {
  set_has_reason();
  reason_ = value;
  // @@protoc_insertion_point(field_set:JoinRoomRsp.reason)
}

// required uint32 levelIdx = 4;
inline bool JoinRoomRsp::has_levelidx() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void JoinRoomRsp::set_has_levelidx() {
  _has_bits_[0] |= 0x00000008u;
}
inline void JoinRoomRsp::clear_has_levelidx() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void JoinRoomRsp::clear_levelidx() {
  levelidx_ = 0u;
  clear_has_levelidx();
}
inline ::google::protobuf::uint32 JoinRoomRsp::levelidx() const {
  // @@protoc_insertion_point(field_get:JoinRoomRsp.levelIdx)
  return levelidx_;
}
inline void JoinRoomRsp::set_levelidx(::google::protobuf::uint32 value) {
  set_has_levelidx();
  levelidx_ = value;
  // @@protoc_insertion_point(field_set:JoinRoomRsp.levelIdx)
}

// required uint32 roomId = 5;
inline bool JoinRoomRsp::has_roomid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void JoinRoomRsp::set_has_roomid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void JoinRoomRsp::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void JoinRoomRsp::clear_roomid() {
  roomid_ = 0u;
  clear_has_roomid();
}
inline ::google::protobuf::uint32 JoinRoomRsp::roomid() const {
  // @@protoc_insertion_point(field_get:JoinRoomRsp.roomId)
  return roomid_;
}
inline void JoinRoomRsp::set_roomid(::google::protobuf::uint32 value) {
  set_has_roomid();
  roomid_ = value;
  // @@protoc_insertion_point(field_set:JoinRoomRsp.roomId)
}

// required uint32 playerId = 6;
inline bool JoinRoomRsp::has_playerid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void JoinRoomRsp::set_has_playerid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void JoinRoomRsp::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void JoinRoomRsp::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 JoinRoomRsp::playerid() const {
  // @@protoc_insertion_point(field_get:JoinRoomRsp.playerId)
  return playerid_;
}
inline void JoinRoomRsp::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
  // @@protoc_insertion_point(field_set:JoinRoomRsp.playerId)
}

// required string userNick = 7;
inline bool JoinRoomRsp::has_usernick() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JoinRoomRsp::set_has_usernick() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JoinRoomRsp::clear_has_usernick() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JoinRoomRsp::clear_usernick() {
  usernick_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_usernick();
}
inline const ::std::string& JoinRoomRsp::usernick() const {
  // @@protoc_insertion_point(field_get:JoinRoomRsp.userNick)
  return usernick_.GetNoArena();
}
inline void JoinRoomRsp::set_usernick(const ::std::string& value) {
  set_has_usernick();
  usernick_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:JoinRoomRsp.userNick)
}
#if LANG_CXX11
inline void JoinRoomRsp::set_usernick(::std::string&& value) {
  set_has_usernick();
  usernick_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:JoinRoomRsp.userNick)
}
#endif
inline void JoinRoomRsp::set_usernick(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_usernick();
  usernick_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:JoinRoomRsp.userNick)
}
inline void JoinRoomRsp::set_usernick(const char* value, size_t size) {
  set_has_usernick();
  usernick_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:JoinRoomRsp.userNick)
}
inline ::std::string* JoinRoomRsp::mutable_usernick() {
  set_has_usernick();
  // @@protoc_insertion_point(field_mutable:JoinRoomRsp.userNick)
  return usernick_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JoinRoomRsp::release_usernick() {
  // @@protoc_insertion_point(field_release:JoinRoomRsp.userNick)
  clear_has_usernick();
  return usernick_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JoinRoomRsp::set_allocated_usernick(::std::string* usernick) {
  if (usernick != NULL) {
    set_has_usernick();
  } else {
    clear_has_usernick();
  }
  usernick_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), usernick);
  // @@protoc_insertion_point(field_set_allocated:JoinRoomRsp.userNick)
}

// -------------------------------------------------------------------

// EnterLevelReq

// required uint32 camp = 2;
inline bool EnterLevelReq::has_camp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterLevelReq::set_has_camp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnterLevelReq::clear_has_camp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnterLevelReq::clear_camp() {
  camp_ = 0u;
  clear_has_camp();
}
inline ::google::protobuf::uint32 EnterLevelReq::camp() const {
  // @@protoc_insertion_point(field_get:EnterLevelReq.camp)
  return camp_;
}
inline void EnterLevelReq::set_camp(::google::protobuf::uint32 value) {
  set_has_camp();
  camp_ = value;
  // @@protoc_insertion_point(field_set:EnterLevelReq.camp)
}

// required uint32 model = 3;
inline bool EnterLevelReq::has_model() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnterLevelReq::set_has_model() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnterLevelReq::clear_has_model() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnterLevelReq::clear_model() {
  model_ = 0u;
  clear_has_model();
}
inline ::google::protobuf::uint32 EnterLevelReq::model() const {
  // @@protoc_insertion_point(field_get:EnterLevelReq.model)
  return model_;
}
inline void EnterLevelReq::set_model(::google::protobuf::uint32 value) {
  set_has_model();
  model_ = value;
  // @@protoc_insertion_point(field_set:EnterLevelReq.model)
}

// required uint32 weapon = 4;
inline bool EnterLevelReq::has_weapon() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EnterLevelReq::set_has_weapon() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EnterLevelReq::clear_has_weapon() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EnterLevelReq::clear_weapon() {
  weapon_ = 0u;
  clear_has_weapon();
}
inline ::google::protobuf::uint32 EnterLevelReq::weapon() const {
  // @@protoc_insertion_point(field_get:EnterLevelReq.weapon)
  return weapon_;
}
inline void EnterLevelReq::set_weapon(::google::protobuf::uint32 value) {
  set_has_weapon();
  weapon_ = value;
  // @@protoc_insertion_point(field_set:EnterLevelReq.weapon)
}

// -------------------------------------------------------------------

// EnterLevelRsp

// optional .SceneInfo scene = 1;
inline bool EnterLevelRsp::has_scene() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterLevelRsp::set_has_scene() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnterLevelRsp::clear_has_scene() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnterLevelRsp::clear_scene() {
  if (scene_ != NULL) scene_->Clear();
  clear_has_scene();
}
inline const ::SceneInfo& EnterLevelRsp::scene() const {
  const ::SceneInfo* p = scene_;
  // @@protoc_insertion_point(field_get:EnterLevelRsp.scene)
  return p != NULL ? *p : *reinterpret_cast<const ::SceneInfo*>(
      &::_SceneInfo_default_instance_);
}
inline ::SceneInfo* EnterLevelRsp::release_scene() {
  // @@protoc_insertion_point(field_release:EnterLevelRsp.scene)
  clear_has_scene();
  ::SceneInfo* temp = scene_;
  scene_ = NULL;
  return temp;
}
inline ::SceneInfo* EnterLevelRsp::mutable_scene() {
  set_has_scene();
  if (scene_ == NULL) {
    scene_ = new ::SceneInfo;
  }
  // @@protoc_insertion_point(field_mutable:EnterLevelRsp.scene)
  return scene_;
}
inline void EnterLevelRsp::set_allocated_scene(::SceneInfo* scene) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete scene_;
  }
  if (scene) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      scene = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, scene, submessage_arena);
    }
    set_has_scene();
  } else {
    clear_has_scene();
  }
  scene_ = scene;
  // @@protoc_insertion_point(field_set_allocated:EnterLevelRsp.scene)
}

// -------------------------------------------------------------------

// OnEnterRoomRsp

// required string playerNick = 1;
inline bool OnEnterRoomRsp::has_playernick() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OnEnterRoomRsp::set_has_playernick() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OnEnterRoomRsp::clear_has_playernick() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OnEnterRoomRsp::clear_playernick() {
  playernick_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_playernick();
}
inline const ::std::string& OnEnterRoomRsp::playernick() const {
  // @@protoc_insertion_point(field_get:OnEnterRoomRsp.playerNick)
  return playernick_.GetNoArena();
}
inline void OnEnterRoomRsp::set_playernick(const ::std::string& value) {
  set_has_playernick();
  playernick_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:OnEnterRoomRsp.playerNick)
}
#if LANG_CXX11
inline void OnEnterRoomRsp::set_playernick(::std::string&& value) {
  set_has_playernick();
  playernick_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:OnEnterRoomRsp.playerNick)
}
#endif
inline void OnEnterRoomRsp::set_playernick(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_playernick();
  playernick_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:OnEnterRoomRsp.playerNick)
}
inline void OnEnterRoomRsp::set_playernick(const char* value, size_t size) {
  set_has_playernick();
  playernick_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:OnEnterRoomRsp.playerNick)
}
inline ::std::string* OnEnterRoomRsp::mutable_playernick() {
  set_has_playernick();
  // @@protoc_insertion_point(field_mutable:OnEnterRoomRsp.playerNick)
  return playernick_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OnEnterRoomRsp::release_playernick() {
  // @@protoc_insertion_point(field_release:OnEnterRoomRsp.playerNick)
  clear_has_playernick();
  return playernick_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OnEnterRoomRsp::set_allocated_playernick(::std::string* playernick) {
  if (playernick != NULL) {
    set_has_playernick();
  } else {
    clear_has_playernick();
  }
  playernick_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), playernick);
  // @@protoc_insertion_point(field_set_allocated:OnEnterRoomRsp.playerNick)
}

// -------------------------------------------------------------------

// OnEnterLevelRsp

// required .Player_ player = 1;
inline bool OnEnterLevelRsp::has_player() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OnEnterLevelRsp::set_has_player() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OnEnterLevelRsp::clear_has_player() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OnEnterLevelRsp::clear_player() {
  if (player_ != NULL) player_->Clear();
  clear_has_player();
}
inline const ::Player_& OnEnterLevelRsp::player() const {
  const ::Player_* p = player_;
  // @@protoc_insertion_point(field_get:OnEnterLevelRsp.player)
  return p != NULL ? *p : *reinterpret_cast<const ::Player_*>(
      &::_Player__default_instance_);
}
inline ::Player_* OnEnterLevelRsp::release_player() {
  // @@protoc_insertion_point(field_release:OnEnterLevelRsp.player)
  clear_has_player();
  ::Player_* temp = player_;
  player_ = NULL;
  return temp;
}
inline ::Player_* OnEnterLevelRsp::mutable_player() {
  set_has_player();
  if (player_ == NULL) {
    player_ = new ::Player_;
  }
  // @@protoc_insertion_point(field_mutable:OnEnterLevelRsp.player)
  return player_;
}
inline void OnEnterLevelRsp::set_allocated_player(::Player_* player) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete player_;
  }
  if (player) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      player = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    set_has_player();
  } else {
    clear_has_player();
  }
  player_ = player;
  // @@protoc_insertion_point(field_set_allocated:OnEnterLevelRsp.player)
}

// -------------------------------------------------------------------

// Vector2_

// required int32 x = 1;
inline bool Vector2_::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vector2_::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vector2_::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vector2_::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 Vector2_::x() const {
  // @@protoc_insertion_point(field_get:Vector2_.x)
  return x_;
}
inline void Vector2_::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:Vector2_.x)
}

// required int32 y = 2;
inline bool Vector2_::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vector2_::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vector2_::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vector2_::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 Vector2_::y() const {
  // @@protoc_insertion_point(field_get:Vector2_.y)
  return y_;
}
inline void Vector2_::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:Vector2_.y)
}

// -------------------------------------------------------------------

// Vector3_

// required int32 x = 1;
inline bool Vector3_::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vector3_::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vector3_::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vector3_::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 Vector3_::x() const {
  // @@protoc_insertion_point(field_get:Vector3_.x)
  return x_;
}
inline void Vector3_::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:Vector3_.x)
}

// required int32 y = 2;
inline bool Vector3_::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vector3_::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vector3_::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vector3_::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 Vector3_::y() const {
  // @@protoc_insertion_point(field_get:Vector3_.y)
  return y_;
}
inline void Vector3_::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:Vector3_.y)
}

// required int32 z = 3;
inline bool Vector3_::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vector3_::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vector3_::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vector3_::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline ::google::protobuf::int32 Vector3_::z() const {
  // @@protoc_insertion_point(field_get:Vector3_.z)
  return z_;
}
inline void Vector3_::set_z(::google::protobuf::int32 value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:Vector3_.z)
}

// -------------------------------------------------------------------

// Quaternion_

// required int32 x = 1;
inline bool Quaternion_::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Quaternion_::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Quaternion_::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Quaternion_::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 Quaternion_::x() const {
  // @@protoc_insertion_point(field_get:Quaternion_.x)
  return x_;
}
inline void Quaternion_::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:Quaternion_.x)
}

// required int32 y = 2;
inline bool Quaternion_::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Quaternion_::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Quaternion_::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Quaternion_::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 Quaternion_::y() const {
  // @@protoc_insertion_point(field_get:Quaternion_.y)
  return y_;
}
inline void Quaternion_::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:Quaternion_.y)
}

// required int32 z = 3;
inline bool Quaternion_::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Quaternion_::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Quaternion_::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Quaternion_::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline ::google::protobuf::int32 Quaternion_::z() const {
  // @@protoc_insertion_point(field_get:Quaternion_.z)
  return z_;
}
inline void Quaternion_::set_z(::google::protobuf::int32 value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:Quaternion_.z)
}

// required int32 w = 4;
inline bool Quaternion_::has_w() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Quaternion_::set_has_w() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Quaternion_::clear_has_w() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Quaternion_::clear_w() {
  w_ = 0;
  clear_has_w();
}
inline ::google::protobuf::int32 Quaternion_::w() const {
  // @@protoc_insertion_point(field_get:Quaternion_.w)
  return w_;
}
inline void Quaternion_::set_w(::google::protobuf::int32 value) {
  set_has_w();
  w_ = value;
  // @@protoc_insertion_point(field_set:Quaternion_.w)
}

// -------------------------------------------------------------------

// SceneInfo

// repeated .SceneItem_ items = 1;
inline int SceneInfo::items_size() const {
  return items_.size();
}
inline void SceneInfo::clear_items() {
  items_.Clear();
}
inline const ::SceneItem_& SceneInfo::items(int index) const {
  // @@protoc_insertion_point(field_get:SceneInfo.items)
  return items_.Get(index);
}
inline ::SceneItem_* SceneInfo::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:SceneInfo.items)
  return items_.Mutable(index);
}
inline ::SceneItem_* SceneInfo::add_items() {
  // @@protoc_insertion_point(field_add:SceneInfo.items)
  return items_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::SceneItem_ >*
SceneInfo::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:SceneInfo.items)
  return &items_;
}
inline const ::google::protobuf::RepeatedPtrField< ::SceneItem_ >&
SceneInfo::items() const {
  // @@protoc_insertion_point(field_list:SceneInfo.items)
  return items_;
}

// repeated .Player_ players = 2;
inline int SceneInfo::players_size() const {
  return players_.size();
}
inline void SceneInfo::clear_players() {
  players_.Clear();
}
inline const ::Player_& SceneInfo::players(int index) const {
  // @@protoc_insertion_point(field_get:SceneInfo.players)
  return players_.Get(index);
}
inline ::Player_* SceneInfo::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:SceneInfo.players)
  return players_.Mutable(index);
}
inline ::Player_* SceneInfo::add_players() {
  // @@protoc_insertion_point(field_add:SceneInfo.players)
  return players_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Player_ >*
SceneInfo::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:SceneInfo.players)
  return &players_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Player_ >&
SceneInfo::players() const {
  // @@protoc_insertion_point(field_list:SceneInfo.players)
  return players_;
}

// -------------------------------------------------------------------

// SceneItem_

// required string model = 1;
inline bool SceneItem_::has_model() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SceneItem_::set_has_model() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SceneItem_::clear_has_model() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SceneItem_::clear_model() {
  model_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model();
}
inline const ::std::string& SceneItem_::model() const {
  // @@protoc_insertion_point(field_get:SceneItem_.model)
  return model_.GetNoArena();
}
inline void SceneItem_::set_model(const ::std::string& value) {
  set_has_model();
  model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SceneItem_.model)
}
#if LANG_CXX11
inline void SceneItem_::set_model(::std::string&& value) {
  set_has_model();
  model_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SceneItem_.model)
}
#endif
inline void SceneItem_::set_model(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_model();
  model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SceneItem_.model)
}
inline void SceneItem_::set_model(const char* value, size_t size) {
  set_has_model();
  model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SceneItem_.model)
}
inline ::std::string* SceneItem_::mutable_model() {
  set_has_model();
  // @@protoc_insertion_point(field_mutable:SceneItem_.model)
  return model_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SceneItem_::release_model() {
  // @@protoc_insertion_point(field_release:SceneItem_.model)
  clear_has_model();
  return model_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SceneItem_::set_allocated_model(::std::string* model) {
  if (model != NULL) {
    set_has_model();
  } else {
    clear_has_model();
  }
  model_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model);
  // @@protoc_insertion_point(field_set_allocated:SceneItem_.model)
}

// required .Vector3_ pos = 2;
inline bool SceneItem_::has_pos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SceneItem_::set_has_pos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SceneItem_::clear_has_pos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SceneItem_::clear_pos() {
  if (pos_ != NULL) pos_->Clear();
  clear_has_pos();
}
inline const ::Vector3_& SceneItem_::pos() const {
  const ::Vector3_* p = pos_;
  // @@protoc_insertion_point(field_get:SceneItem_.pos)
  return p != NULL ? *p : *reinterpret_cast<const ::Vector3_*>(
      &::_Vector3__default_instance_);
}
inline ::Vector3_* SceneItem_::release_pos() {
  // @@protoc_insertion_point(field_release:SceneItem_.pos)
  clear_has_pos();
  ::Vector3_* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline ::Vector3_* SceneItem_::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) {
    pos_ = new ::Vector3_;
  }
  // @@protoc_insertion_point(field_mutable:SceneItem_.pos)
  return pos_;
}
inline void SceneItem_::set_allocated_pos(::Vector3_* pos) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete pos_;
  }
  if (pos) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pos = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    set_has_pos();
  } else {
    clear_has_pos();
  }
  pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:SceneItem_.pos)
}

// required .Quaternion_ rotation = 3;
inline bool SceneItem_::has_rotation() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SceneItem_::set_has_rotation() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SceneItem_::clear_has_rotation() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SceneItem_::clear_rotation() {
  if (rotation_ != NULL) rotation_->Clear();
  clear_has_rotation();
}
inline const ::Quaternion_& SceneItem_::rotation() const {
  const ::Quaternion_* p = rotation_;
  // @@protoc_insertion_point(field_get:SceneItem_.rotation)
  return p != NULL ? *p : *reinterpret_cast<const ::Quaternion_*>(
      &::_Quaternion__default_instance_);
}
inline ::Quaternion_* SceneItem_::release_rotation() {
  // @@protoc_insertion_point(field_release:SceneItem_.rotation)
  clear_has_rotation();
  ::Quaternion_* temp = rotation_;
  rotation_ = NULL;
  return temp;
}
inline ::Quaternion_* SceneItem_::mutable_rotation() {
  set_has_rotation();
  if (rotation_ == NULL) {
    rotation_ = new ::Quaternion_;
  }
  // @@protoc_insertion_point(field_mutable:SceneItem_.rotation)
  return rotation_;
}
inline void SceneItem_::set_allocated_rotation(::Quaternion_* rotation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete rotation_;
  }
  if (rotation) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      rotation = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rotation, submessage_arena);
    }
    set_has_rotation();
  } else {
    clear_has_rotation();
  }
  rotation_ = rotation;
  // @@protoc_insertion_point(field_set_allocated:SceneItem_.rotation)
}

// required int32 frame = 4;
inline bool SceneItem_::has_frame() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SceneItem_::set_has_frame() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SceneItem_::clear_has_frame() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SceneItem_::clear_frame() {
  frame_ = 0;
  clear_has_frame();
}
inline ::google::protobuf::int32 SceneItem_::frame() const {
  // @@protoc_insertion_point(field_get:SceneItem_.frame)
  return frame_;
}
inline void SceneItem_::set_frame(::google::protobuf::int32 value) {
  set_has_frame();
  frame_ = value;
  // @@protoc_insertion_point(field_set:SceneItem_.frame)
}

// -------------------------------------------------------------------

// Player_

// required uint32 id = 1;
inline bool Player_::has_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Player_::set_has_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Player_::clear_has_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Player_::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 Player_::id() const {
  // @@protoc_insertion_point(field_get:Player_.id)
  return id_;
}
inline void Player_::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:Player_.id)
}

// required string name = 2;
inline bool Player_::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Player_::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Player_::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Player_::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Player_::name() const {
  // @@protoc_insertion_point(field_get:Player_.name)
  return name_.GetNoArena();
}
inline void Player_::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Player_.name)
}
#if LANG_CXX11
inline void Player_::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Player_.name)
}
#endif
inline void Player_::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Player_.name)
}
inline void Player_::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Player_.name)
}
inline ::std::string* Player_::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:Player_.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Player_::release_name() {
  // @@protoc_insertion_point(field_release:Player_.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Player_::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Player_.name)
}

// required uint32 weapon1 = 3;
inline bool Player_::has_weapon1() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Player_::set_has_weapon1() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Player_::clear_has_weapon1() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Player_::clear_weapon1() {
  weapon1_ = 0u;
  clear_has_weapon1();
}
inline ::google::protobuf::uint32 Player_::weapon1() const {
  // @@protoc_insertion_point(field_get:Player_.weapon1)
  return weapon1_;
}
inline void Player_::set_weapon1(::google::protobuf::uint32 value) {
  set_has_weapon1();
  weapon1_ = value;
  // @@protoc_insertion_point(field_set:Player_.weapon1)
}

// required uint32 weapon2 = 4;
inline bool Player_::has_weapon2() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Player_::set_has_weapon2() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Player_::clear_has_weapon2() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Player_::clear_weapon2() {
  weapon2_ = 0u;
  clear_has_weapon2();
}
inline ::google::protobuf::uint32 Player_::weapon2() const {
  // @@protoc_insertion_point(field_get:Player_.weapon2)
  return weapon2_;
}
inline void Player_::set_weapon2(::google::protobuf::uint32 value) {
  set_has_weapon2();
  weapon2_ = value;
  // @@protoc_insertion_point(field_set:Player_.weapon2)
}

// required uint32 weapon = 5;
inline bool Player_::has_weapon() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Player_::set_has_weapon() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Player_::clear_has_weapon() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Player_::clear_weapon() {
  weapon_ = 0u;
  clear_has_weapon();
}
inline ::google::protobuf::uint32 Player_::weapon() const {
  // @@protoc_insertion_point(field_get:Player_.weapon)
  return weapon_;
}
inline void Player_::set_weapon(::google::protobuf::uint32 value) {
  set_has_weapon();
  weapon_ = value;
  // @@protoc_insertion_point(field_set:Player_.weapon)
}

// required uint32 weapon_pos = 6;
inline bool Player_::has_weapon_pos() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Player_::set_has_weapon_pos() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Player_::clear_has_weapon_pos() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Player_::clear_weapon_pos() {
  weapon_pos_ = 0u;
  clear_has_weapon_pos();
}
inline ::google::protobuf::uint32 Player_::weapon_pos() const {
  // @@protoc_insertion_point(field_get:Player_.weapon_pos)
  return weapon_pos_;
}
inline void Player_::set_weapon_pos(::google::protobuf::uint32 value) {
  set_has_weapon_pos();
  weapon_pos_ = value;
  // @@protoc_insertion_point(field_set:Player_.weapon_pos)
}

// required .Vector3_ pos = 7;
inline bool Player_::has_pos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Player_::set_has_pos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Player_::clear_has_pos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Player_::clear_pos() {
  if (pos_ != NULL) pos_->Clear();
  clear_has_pos();
}
inline const ::Vector3_& Player_::pos() const {
  const ::Vector3_* p = pos_;
  // @@protoc_insertion_point(field_get:Player_.pos)
  return p != NULL ? *p : *reinterpret_cast<const ::Vector3_*>(
      &::_Vector3__default_instance_);
}
inline ::Vector3_* Player_::release_pos() {
  // @@protoc_insertion_point(field_release:Player_.pos)
  clear_has_pos();
  ::Vector3_* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline ::Vector3_* Player_::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) {
    pos_ = new ::Vector3_;
  }
  // @@protoc_insertion_point(field_mutable:Player_.pos)
  return pos_;
}
inline void Player_::set_allocated_pos(::Vector3_* pos) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete pos_;
  }
  if (pos) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pos = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    set_has_pos();
  } else {
    clear_has_pos();
  }
  pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:Player_.pos)
}

// required .Quaternion_ rotation = 8;
inline bool Player_::has_rotation() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Player_::set_has_rotation() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Player_::clear_has_rotation() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Player_::clear_rotation() {
  if (rotation_ != NULL) rotation_->Clear();
  clear_has_rotation();
}
inline const ::Quaternion_& Player_::rotation() const {
  const ::Quaternion_* p = rotation_;
  // @@protoc_insertion_point(field_get:Player_.rotation)
  return p != NULL ? *p : *reinterpret_cast<const ::Quaternion_*>(
      &::_Quaternion__default_instance_);
}
inline ::Quaternion_* Player_::release_rotation() {
  // @@protoc_insertion_point(field_release:Player_.rotation)
  clear_has_rotation();
  ::Quaternion_* temp = rotation_;
  rotation_ = NULL;
  return temp;
}
inline ::Quaternion_* Player_::mutable_rotation() {
  set_has_rotation();
  if (rotation_ == NULL) {
    rotation_ = new ::Quaternion_;
  }
  // @@protoc_insertion_point(field_mutable:Player_.rotation)
  return rotation_;
}
inline void Player_::set_allocated_rotation(::Quaternion_* rotation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete rotation_;
  }
  if (rotation) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      rotation = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rotation, submessage_arena);
    }
    set_has_rotation();
  } else {
    clear_has_rotation();
  }
  rotation_ = rotation;
  // @@protoc_insertion_point(field_set_allocated:Player_.rotation)
}

// required int32 model = 9;
inline bool Player_::has_model() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Player_::set_has_model() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Player_::clear_has_model() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Player_::clear_model() {
  model_ = 0;
  clear_has_model();
}
inline ::google::protobuf::int32 Player_::model() const {
  // @@protoc_insertion_point(field_get:Player_.model)
  return model_;
}
inline void Player_::set_model(::google::protobuf::int32 value) {
  set_has_model();
  model_ = value;
  // @@protoc_insertion_point(field_set:Player_.model)
}

// required int32 aniSource = 10;
inline bool Player_::has_anisource() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Player_::set_has_anisource() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Player_::clear_has_anisource() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Player_::clear_anisource() {
  anisource_ = 0;
  clear_has_anisource();
}
inline ::google::protobuf::int32 Player_::anisource() const {
  // @@protoc_insertion_point(field_get:Player_.aniSource)
  return anisource_;
}
inline void Player_::set_anisource(::google::protobuf::int32 value) {
  set_has_anisource();
  anisource_ = value;
  // @@protoc_insertion_point(field_set:Player_.aniSource)
}

// required int32 frame = 11;
inline bool Player_::has_frame() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Player_::set_has_frame() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Player_::clear_has_frame() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Player_::clear_frame() {
  frame_ = 0;
  clear_has_frame();
}
inline ::google::protobuf::int32 Player_::frame() const {
  // @@protoc_insertion_point(field_get:Player_.frame)
  return frame_;
}
inline void Player_::set_frame(::google::protobuf::int32 value) {
  set_has_frame();
  frame_ = value;
  // @@protoc_insertion_point(field_set:Player_.frame)
}

// required int32 hpMax = 12;
inline bool Player_::has_hpmax() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Player_::set_has_hpmax() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Player_::clear_has_hpmax() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Player_::clear_hpmax() {
  hpmax_ = 0;
  clear_has_hpmax();
}
inline ::google::protobuf::int32 Player_::hpmax() const {
  // @@protoc_insertion_point(field_get:Player_.hpMax)
  return hpmax_;
}
inline void Player_::set_hpmax(::google::protobuf::int32 value) {
  set_has_hpmax();
  hpmax_ = value;
  // @@protoc_insertion_point(field_set:Player_.hpMax)
}

// required int32 hp = 13;
inline bool Player_::has_hp() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Player_::set_has_hp() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Player_::clear_has_hp() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Player_::clear_hp() {
  hp_ = 0;
  clear_has_hp();
}
inline ::google::protobuf::int32 Player_::hp() const {
  // @@protoc_insertion_point(field_get:Player_.hp)
  return hp_;
}
inline void Player_::set_hp(::google::protobuf::int32 value) {
  set_has_hp();
  hp_ = value;
  // @@protoc_insertion_point(field_set:Player_.hp)
}

// required int32 angry = 14;
inline bool Player_::has_angry() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Player_::set_has_angry() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Player_::clear_has_angry() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Player_::clear_angry() {
  angry_ = 0;
  clear_has_angry();
}
inline ::google::protobuf::int32 Player_::angry() const {
  // @@protoc_insertion_point(field_get:Player_.angry)
  return angry_;
}
inline void Player_::set_angry(::google::protobuf::int32 value) {
  set_has_angry();
  angry_ = value;
  // @@protoc_insertion_point(field_set:Player_.angry)
}

// required int32 Camp = 15;
inline bool Player_::has_camp() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Player_::set_has_camp() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Player_::clear_has_camp() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Player_::clear_camp() {
  camp_ = 0;
  clear_has_camp();
}
inline ::google::protobuf::int32 Player_::camp() const {
  // @@protoc_insertion_point(field_get:Player_.Camp)
  return camp_;
}
inline void Player_::set_camp(::google::protobuf::int32 value) {
  set_has_camp();
  camp_ = value;
  // @@protoc_insertion_point(field_set:Player_.Camp)
}

// required int32 SpawnPoint = 16;
inline bool Player_::has_spawnpoint() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Player_::set_has_spawnpoint() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Player_::clear_has_spawnpoint() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Player_::clear_spawnpoint() {
  spawnpoint_ = 0;
  clear_has_spawnpoint();
}
inline ::google::protobuf::int32 Player_::spawnpoint() const {
  // @@protoc_insertion_point(field_get:Player_.SpawnPoint)
  return spawnpoint_;
}
inline void Player_::set_spawnpoint(::google::protobuf::int32 value) {
  set_has_spawnpoint();
  spawnpoint_ = value;
  // @@protoc_insertion_point(field_set:Player_.SpawnPoint)
}

// -------------------------------------------------------------------

// InputReq

// repeated .Input_ input = 1;
inline int InputReq::input_size() const {
  return input_.size();
}
inline void InputReq::clear_input() {
  input_.Clear();
}
inline const ::Input_& InputReq::input(int index) const {
  // @@protoc_insertion_point(field_get:InputReq.input)
  return input_.Get(index);
}
inline ::Input_* InputReq::mutable_input(int index) {
  // @@protoc_insertion_point(field_mutable:InputReq.input)
  return input_.Mutable(index);
}
inline ::Input_* InputReq::add_input() {
  // @@protoc_insertion_point(field_add:InputReq.input)
  return input_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Input_ >*
InputReq::mutable_input() {
  // @@protoc_insertion_point(field_mutable_list:InputReq.input)
  return &input_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Input_ >&
InputReq::input() const {
  // @@protoc_insertion_point(field_list:InputReq.input)
  return input_;
}

// -------------------------------------------------------------------

// Input_

// required uint32 playerId = 1;
inline bool Input_::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Input_::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Input_::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Input_::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 Input_::playerid() const {
  // @@protoc_insertion_point(field_get:Input_.playerId)
  return playerid_;
}
inline void Input_::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
  // @@protoc_insertion_point(field_set:Input_.playerId)
}

// repeated .InputFrame frames = 2;
inline int Input_::frames_size() const {
  return frames_.size();
}
inline void Input_::clear_frames() {
  frames_.Clear();
}
inline const ::InputFrame& Input_::frames(int index) const {
  // @@protoc_insertion_point(field_get:Input_.frames)
  return frames_.Get(index);
}
inline ::InputFrame* Input_::mutable_frames(int index) {
  // @@protoc_insertion_point(field_mutable:Input_.frames)
  return frames_.Mutable(index);
}
inline ::InputFrame* Input_::add_frames() {
  // @@protoc_insertion_point(field_add:Input_.frames)
  return frames_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::InputFrame >*
Input_::mutable_frames() {
  // @@protoc_insertion_point(field_mutable_list:Input_.frames)
  return &frames_;
}
inline const ::google::protobuf::RepeatedPtrField< ::InputFrame >&
Input_::frames() const {
  // @@protoc_insertion_point(field_list:Input_.frames)
  return frames_;
}

// -------------------------------------------------------------------

// TurnFrames

// required uint32 turnIndex = 1;
inline bool TurnFrames::has_turnindex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TurnFrames::set_has_turnindex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TurnFrames::clear_has_turnindex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TurnFrames::clear_turnindex() {
  turnindex_ = 0u;
  clear_has_turnindex();
}
inline ::google::protobuf::uint32 TurnFrames::turnindex() const {
  // @@protoc_insertion_point(field_get:TurnFrames.turnIndex)
  return turnindex_;
}
inline void TurnFrames::set_turnindex(::google::protobuf::uint32 value) {
  set_has_turnindex();
  turnindex_ = value;
  // @@protoc_insertion_point(field_set:TurnFrames.turnIndex)
}

// repeated .Input_ Inputs = 2;
inline int TurnFrames::inputs_size() const {
  return inputs_.size();
}
inline void TurnFrames::clear_inputs() {
  inputs_.Clear();
}
inline const ::Input_& TurnFrames::inputs(int index) const {
  // @@protoc_insertion_point(field_get:TurnFrames.Inputs)
  return inputs_.Get(index);
}
inline ::Input_* TurnFrames::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:TurnFrames.Inputs)
  return inputs_.Mutable(index);
}
inline ::Input_* TurnFrames::add_inputs() {
  // @@protoc_insertion_point(field_add:TurnFrames.Inputs)
  return inputs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Input_ >*
TurnFrames::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:TurnFrames.Inputs)
  return &inputs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Input_ >&
TurnFrames::inputs() const {
  // @@protoc_insertion_point(field_list:TurnFrames.Inputs)
  return inputs_;
}

// -------------------------------------------------------------------

// UserId

// repeated uint32 Player = 1;
inline int UserId::player_size() const {
  return player_.size();
}
inline void UserId::clear_player() {
  player_.Clear();
}
inline ::google::protobuf::uint32 UserId::player(int index) const {
  // @@protoc_insertion_point(field_get:UserId.Player)
  return player_.Get(index);
}
inline void UserId::set_player(int index, ::google::protobuf::uint32 value) {
  player_.Set(index, value);
  // @@protoc_insertion_point(field_set:UserId.Player)
}
inline void UserId::add_player(::google::protobuf::uint32 value) {
  player_.Add(value);
  // @@protoc_insertion_point(field_add:UserId.Player)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
UserId::player() const {
  // @@protoc_insertion_point(field_list:UserId.Player)
  return player_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
UserId::mutable_player() {
  // @@protoc_insertion_point(field_mutable_list:UserId.Player)
  return &player_;
}

// -------------------------------------------------------------------

// InputFrame

// required .Vector2_ JoyStick = 2;
inline bool InputFrame::has_joystick() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void InputFrame::set_has_joystick() {
  _has_bits_[0] |= 0x00001000u;
}
inline void InputFrame::clear_has_joystick() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void InputFrame::clear_joystick() {
  if (joystick_ != NULL) joystick_->Clear();
  clear_has_joystick();
}
inline const ::Vector2_& InputFrame::joystick() const {
  const ::Vector2_* p = joystick_;
  // @@protoc_insertion_point(field_get:InputFrame.JoyStick)
  return p != NULL ? *p : *reinterpret_cast<const ::Vector2_*>(
      &::_Vector2__default_instance_);
}
inline ::Vector2_* InputFrame::release_joystick() {
  // @@protoc_insertion_point(field_release:InputFrame.JoyStick)
  clear_has_joystick();
  ::Vector2_* temp = joystick_;
  joystick_ = NULL;
  return temp;
}
inline ::Vector2_* InputFrame::mutable_joystick() {
  set_has_joystick();
  if (joystick_ == NULL) {
    joystick_ = new ::Vector2_;
  }
  // @@protoc_insertion_point(field_mutable:InputFrame.JoyStick)
  return joystick_;
}
inline void InputFrame::set_allocated_joystick(::Vector2_* joystick) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete joystick_;
  }
  if (joystick) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      joystick = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, joystick, submessage_arena);
    }
    set_has_joystick();
  } else {
    clear_has_joystick();
  }
  joystick_ = joystick;
  // @@protoc_insertion_point(field_set_allocated:InputFrame.JoyStick)
}

// required .Vector2_ MouseDelta = 3;
inline bool InputFrame::has_mousedelta() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void InputFrame::set_has_mousedelta() {
  _has_bits_[0] |= 0x00002000u;
}
inline void InputFrame::clear_has_mousedelta() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void InputFrame::clear_mousedelta() {
  if (mousedelta_ != NULL) mousedelta_->Clear();
  clear_has_mousedelta();
}
inline const ::Vector2_& InputFrame::mousedelta() const {
  const ::Vector2_* p = mousedelta_;
  // @@protoc_insertion_point(field_get:InputFrame.MouseDelta)
  return p != NULL ? *p : *reinterpret_cast<const ::Vector2_*>(
      &::_Vector2__default_instance_);
}
inline ::Vector2_* InputFrame::release_mousedelta() {
  // @@protoc_insertion_point(field_release:InputFrame.MouseDelta)
  clear_has_mousedelta();
  ::Vector2_* temp = mousedelta_;
  mousedelta_ = NULL;
  return temp;
}
inline ::Vector2_* InputFrame::mutable_mousedelta() {
  set_has_mousedelta();
  if (mousedelta_ == NULL) {
    mousedelta_ = new ::Vector2_;
  }
  // @@protoc_insertion_point(field_mutable:InputFrame.MouseDelta)
  return mousedelta_;
}
inline void InputFrame::set_allocated_mousedelta(::Vector2_* mousedelta) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete mousedelta_;
  }
  if (mousedelta) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      mousedelta = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, mousedelta, submessage_arena);
    }
    set_has_mousedelta();
  } else {
    clear_has_mousedelta();
  }
  mousedelta_ = mousedelta;
  // @@protoc_insertion_point(field_set_allocated:InputFrame.MouseDelta)
}

// required bytes w = 4;
inline bool InputFrame::has_w() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InputFrame::set_has_w() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InputFrame::clear_has_w() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InputFrame::clear_w() {
  w_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_w();
}
inline const ::std::string& InputFrame::w() const {
  // @@protoc_insertion_point(field_get:InputFrame.w)
  return w_.GetNoArena();
}
inline void InputFrame::set_w(const ::std::string& value) {
  set_has_w();
  w_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:InputFrame.w)
}
#if LANG_CXX11
inline void InputFrame::set_w(::std::string&& value) {
  set_has_w();
  w_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:InputFrame.w)
}
#endif
inline void InputFrame::set_w(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_w();
  w_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:InputFrame.w)
}
inline void InputFrame::set_w(const void* value, size_t size) {
  set_has_w();
  w_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:InputFrame.w)
}
inline ::std::string* InputFrame::mutable_w() {
  set_has_w();
  // @@protoc_insertion_point(field_mutable:InputFrame.w)
  return w_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InputFrame::release_w() {
  // @@protoc_insertion_point(field_release:InputFrame.w)
  clear_has_w();
  return w_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InputFrame::set_allocated_w(::std::string* w) {
  if (w != NULL) {
    set_has_w();
  } else {
    clear_has_w();
  }
  w_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), w);
  // @@protoc_insertion_point(field_set_allocated:InputFrame.w)
}

// required bytes s = 5;
inline bool InputFrame::has_s() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InputFrame::set_has_s() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InputFrame::clear_has_s() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InputFrame::clear_s() {
  s_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_s();
}
inline const ::std::string& InputFrame::s() const {
  // @@protoc_insertion_point(field_get:InputFrame.s)
  return s_.GetNoArena();
}
inline void InputFrame::set_s(const ::std::string& value) {
  set_has_s();
  s_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:InputFrame.s)
}
#if LANG_CXX11
inline void InputFrame::set_s(::std::string&& value) {
  set_has_s();
  s_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:InputFrame.s)
}
#endif
inline void InputFrame::set_s(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_s();
  s_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:InputFrame.s)
}
inline void InputFrame::set_s(const void* value, size_t size) {
  set_has_s();
  s_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:InputFrame.s)
}
inline ::std::string* InputFrame::mutable_s() {
  set_has_s();
  // @@protoc_insertion_point(field_mutable:InputFrame.s)
  return s_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InputFrame::release_s() {
  // @@protoc_insertion_point(field_release:InputFrame.s)
  clear_has_s();
  return s_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InputFrame::set_allocated_s(::std::string* s) {
  if (s != NULL) {
    set_has_s();
  } else {
    clear_has_s();
  }
  s_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), s);
  // @@protoc_insertion_point(field_set_allocated:InputFrame.s)
}

// required bytes a = 6;
inline bool InputFrame::has_a() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InputFrame::set_has_a() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InputFrame::clear_has_a() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InputFrame::clear_a() {
  a_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_a();
}
inline const ::std::string& InputFrame::a() const {
  // @@protoc_insertion_point(field_get:InputFrame.a)
  return a_.GetNoArena();
}
inline void InputFrame::set_a(const ::std::string& value) {
  set_has_a();
  a_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:InputFrame.a)
}
#if LANG_CXX11
inline void InputFrame::set_a(::std::string&& value) {
  set_has_a();
  a_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:InputFrame.a)
}
#endif
inline void InputFrame::set_a(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_a();
  a_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:InputFrame.a)
}
inline void InputFrame::set_a(const void* value, size_t size) {
  set_has_a();
  a_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:InputFrame.a)
}
inline ::std::string* InputFrame::mutable_a() {
  set_has_a();
  // @@protoc_insertion_point(field_mutable:InputFrame.a)
  return a_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InputFrame::release_a() {
  // @@protoc_insertion_point(field_release:InputFrame.a)
  clear_has_a();
  return a_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InputFrame::set_allocated_a(::std::string* a) {
  if (a != NULL) {
    set_has_a();
  } else {
    clear_has_a();
  }
  a_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), a);
  // @@protoc_insertion_point(field_set_allocated:InputFrame.a)
}

// required bytes d = 7;
inline bool InputFrame::has_d() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InputFrame::set_has_d() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InputFrame::clear_has_d() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InputFrame::clear_d() {
  d_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_d();
}
inline const ::std::string& InputFrame::d() const {
  // @@protoc_insertion_point(field_get:InputFrame.d)
  return d_.GetNoArena();
}
inline void InputFrame::set_d(const ::std::string& value) {
  set_has_d();
  d_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:InputFrame.d)
}
#if LANG_CXX11
inline void InputFrame::set_d(::std::string&& value) {
  set_has_d();
  d_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:InputFrame.d)
}
#endif
inline void InputFrame::set_d(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_d();
  d_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:InputFrame.d)
}
inline void InputFrame::set_d(const void* value, size_t size) {
  set_has_d();
  d_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:InputFrame.d)
}
inline ::std::string* InputFrame::mutable_d() {
  set_has_d();
  // @@protoc_insertion_point(field_mutable:InputFrame.d)
  return d_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InputFrame::release_d() {
  // @@protoc_insertion_point(field_release:InputFrame.d)
  clear_has_d();
  return d_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InputFrame::set_allocated_d(::std::string* d) {
  if (d != NULL) {
    set_has_d();
  } else {
    clear_has_d();
  }
  d_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), d);
  // @@protoc_insertion_point(field_set_allocated:InputFrame.d)
}

// required bytes jump = 8;
inline bool InputFrame::has_jump() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InputFrame::set_has_jump() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InputFrame::clear_has_jump() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InputFrame::clear_jump() {
  jump_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_jump();
}
inline const ::std::string& InputFrame::jump() const {
  // @@protoc_insertion_point(field_get:InputFrame.jump)
  return jump_.GetNoArena();
}
inline void InputFrame::set_jump(const ::std::string& value) {
  set_has_jump();
  jump_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:InputFrame.jump)
}
#if LANG_CXX11
inline void InputFrame::set_jump(::std::string&& value) {
  set_has_jump();
  jump_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:InputFrame.jump)
}
#endif
inline void InputFrame::set_jump(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_jump();
  jump_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:InputFrame.jump)
}
inline void InputFrame::set_jump(const void* value, size_t size) {
  set_has_jump();
  jump_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:InputFrame.jump)
}
inline ::std::string* InputFrame::mutable_jump() {
  set_has_jump();
  // @@protoc_insertion_point(field_mutable:InputFrame.jump)
  return jump_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InputFrame::release_jump() {
  // @@protoc_insertion_point(field_release:InputFrame.jump)
  clear_has_jump();
  return jump_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InputFrame::set_allocated_jump(::std::string* jump) {
  if (jump != NULL) {
    set_has_jump();
  } else {
    clear_has_jump();
  }
  jump_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), jump);
  // @@protoc_insertion_point(field_set_allocated:InputFrame.jump)
}

// required bytes break = 9;
inline bool InputFrame::has_break_() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void InputFrame::set_has_break_() {
  _has_bits_[0] |= 0x00000020u;
}
inline void InputFrame::clear_has_break_() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void InputFrame::clear_break_() {
  break__.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_break_();
}
inline const ::std::string& InputFrame::break_() const {
  // @@protoc_insertion_point(field_get:InputFrame.break)
  return break__.GetNoArena();
}
inline void InputFrame::set_break_(const ::std::string& value) {
  set_has_break_();
  break__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:InputFrame.break)
}
#if LANG_CXX11
inline void InputFrame::set_break_(::std::string&& value) {
  set_has_break_();
  break__.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:InputFrame.break)
}
#endif
inline void InputFrame::set_break_(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_break_();
  break__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:InputFrame.break)
}
inline void InputFrame::set_break_(const void* value, size_t size) {
  set_has_break_();
  break__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:InputFrame.break)
}
inline ::std::string* InputFrame::mutable_break_() {
  set_has_break_();
  // @@protoc_insertion_point(field_mutable:InputFrame.break)
  return break__.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InputFrame::release_break_() {
  // @@protoc_insertion_point(field_release:InputFrame.break)
  clear_has_break_();
  return break__.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InputFrame::set_allocated_break_(::std::string* break_) {
  if (break_ != NULL) {
    set_has_break_();
  } else {
    clear_has_break_();
  }
  break__.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), break_);
  // @@protoc_insertion_point(field_set_allocated:InputFrame.break)
}

// required bytes attack = 10;
inline bool InputFrame::has_attack() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void InputFrame::set_has_attack() {
  _has_bits_[0] |= 0x00000040u;
}
inline void InputFrame::clear_has_attack() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void InputFrame::clear_attack() {
  attack_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_attack();
}
inline const ::std::string& InputFrame::attack() const {
  // @@protoc_insertion_point(field_get:InputFrame.attack)
  return attack_.GetNoArena();
}
inline void InputFrame::set_attack(const ::std::string& value) {
  set_has_attack();
  attack_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:InputFrame.attack)
}
#if LANG_CXX11
inline void InputFrame::set_attack(::std::string&& value) {
  set_has_attack();
  attack_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:InputFrame.attack)
}
#endif
inline void InputFrame::set_attack(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_attack();
  attack_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:InputFrame.attack)
}
inline void InputFrame::set_attack(const void* value, size_t size) {
  set_has_attack();
  attack_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:InputFrame.attack)
}
inline ::std::string* InputFrame::mutable_attack() {
  set_has_attack();
  // @@protoc_insertion_point(field_mutable:InputFrame.attack)
  return attack_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InputFrame::release_attack() {
  // @@protoc_insertion_point(field_release:InputFrame.attack)
  clear_has_attack();
  return attack_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InputFrame::set_allocated_attack(::std::string* attack) {
  if (attack != NULL) {
    set_has_attack();
  } else {
    clear_has_attack();
  }
  attack_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), attack);
  // @@protoc_insertion_point(field_set_allocated:InputFrame.attack)
}

// required bytes e = 11;
inline bool InputFrame::has_e() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void InputFrame::set_has_e() {
  _has_bits_[0] |= 0x00000080u;
}
inline void InputFrame::clear_has_e() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void InputFrame::clear_e() {
  e_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_e();
}
inline const ::std::string& InputFrame::e() const {
  // @@protoc_insertion_point(field_get:InputFrame.e)
  return e_.GetNoArena();
}
inline void InputFrame::set_e(const ::std::string& value) {
  set_has_e();
  e_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:InputFrame.e)
}
#if LANG_CXX11
inline void InputFrame::set_e(::std::string&& value) {
  set_has_e();
  e_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:InputFrame.e)
}
#endif
inline void InputFrame::set_e(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_e();
  e_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:InputFrame.e)
}
inline void InputFrame::set_e(const void* value, size_t size) {
  set_has_e();
  e_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:InputFrame.e)
}
inline ::std::string* InputFrame::mutable_e() {
  set_has_e();
  // @@protoc_insertion_point(field_mutable:InputFrame.e)
  return e_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InputFrame::release_e() {
  // @@protoc_insertion_point(field_release:InputFrame.e)
  clear_has_e();
  return e_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InputFrame::set_allocated_e(::std::string* e) {
  if (e != NULL) {
    set_has_e();
  } else {
    clear_has_e();
  }
  e_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), e);
  // @@protoc_insertion_point(field_set_allocated:InputFrame.e)
}

// required bytes r = 12;
inline bool InputFrame::has_r() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void InputFrame::set_has_r() {
  _has_bits_[0] |= 0x00000100u;
}
inline void InputFrame::clear_has_r() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void InputFrame::clear_r() {
  r_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_r();
}
inline const ::std::string& InputFrame::r() const {
  // @@protoc_insertion_point(field_get:InputFrame.r)
  return r_.GetNoArena();
}
inline void InputFrame::set_r(const ::std::string& value) {
  set_has_r();
  r_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:InputFrame.r)
}
#if LANG_CXX11
inline void InputFrame::set_r(::std::string&& value) {
  set_has_r();
  r_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:InputFrame.r)
}
#endif
inline void InputFrame::set_r(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_r();
  r_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:InputFrame.r)
}
inline void InputFrame::set_r(const void* value, size_t size) {
  set_has_r();
  r_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:InputFrame.r)
}
inline ::std::string* InputFrame::mutable_r() {
  set_has_r();
  // @@protoc_insertion_point(field_mutable:InputFrame.r)
  return r_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InputFrame::release_r() {
  // @@protoc_insertion_point(field_release:InputFrame.r)
  clear_has_r();
  return r_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InputFrame::set_allocated_r(::std::string* r) {
  if (r != NULL) {
    set_has_r();
  } else {
    clear_has_r();
  }
  r_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), r);
  // @@protoc_insertion_point(field_set_allocated:InputFrame.r)
}

// required bytes y = 13;
inline bool InputFrame::has_y() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void InputFrame::set_has_y() {
  _has_bits_[0] |= 0x00000200u;
}
inline void InputFrame::clear_has_y() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void InputFrame::clear_y() {
  y_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_y();
}
inline const ::std::string& InputFrame::y() const {
  // @@protoc_insertion_point(field_get:InputFrame.y)
  return y_.GetNoArena();
}
inline void InputFrame::set_y(const ::std::string& value) {
  set_has_y();
  y_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:InputFrame.y)
}
#if LANG_CXX11
inline void InputFrame::set_y(::std::string&& value) {
  set_has_y();
  y_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:InputFrame.y)
}
#endif
inline void InputFrame::set_y(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_y();
  y_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:InputFrame.y)
}
inline void InputFrame::set_y(const void* value, size_t size) {
  set_has_y();
  y_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:InputFrame.y)
}
inline ::std::string* InputFrame::mutable_y() {
  set_has_y();
  // @@protoc_insertion_point(field_mutable:InputFrame.y)
  return y_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InputFrame::release_y() {
  // @@protoc_insertion_point(field_release:InputFrame.y)
  clear_has_y();
  return y_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InputFrame::set_allocated_y(::std::string* y) {
  if (y != NULL) {
    set_has_y();
  } else {
    clear_has_y();
  }
  y_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), y);
  // @@protoc_insertion_point(field_set_allocated:InputFrame.y)
}

// required bytes space = 14;
inline bool InputFrame::has_space() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void InputFrame::set_has_space() {
  _has_bits_[0] |= 0x00000400u;
}
inline void InputFrame::clear_has_space() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void InputFrame::clear_space() {
  space_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_space();
}
inline const ::std::string& InputFrame::space() const {
  // @@protoc_insertion_point(field_get:InputFrame.space)
  return space_.GetNoArena();
}
inline void InputFrame::set_space(const ::std::string& value) {
  set_has_space();
  space_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:InputFrame.space)
}
#if LANG_CXX11
inline void InputFrame::set_space(::std::string&& value) {
  set_has_space();
  space_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:InputFrame.space)
}
#endif
inline void InputFrame::set_space(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_space();
  space_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:InputFrame.space)
}
inline void InputFrame::set_space(const void* value, size_t size) {
  set_has_space();
  space_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:InputFrame.space)
}
inline ::std::string* InputFrame::mutable_space() {
  set_has_space();
  // @@protoc_insertion_point(field_mutable:InputFrame.space)
  return space_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InputFrame::release_space() {
  // @@protoc_insertion_point(field_release:InputFrame.space)
  clear_has_space();
  return space_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InputFrame::set_allocated_space(::std::string* space) {
  if (space != NULL) {
    set_has_space();
  } else {
    clear_has_space();
  }
  space_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), space);
  // @@protoc_insertion_point(field_set_allocated:InputFrame.space)
}

// required bytes c = 15;
inline bool InputFrame::has_c() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void InputFrame::set_has_c() {
  _has_bits_[0] |= 0x00000800u;
}
inline void InputFrame::clear_has_c() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void InputFrame::clear_c() {
  c_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_c();
}
inline const ::std::string& InputFrame::c() const {
  // @@protoc_insertion_point(field_get:InputFrame.c)
  return c_.GetNoArena();
}
inline void InputFrame::set_c(const ::std::string& value) {
  set_has_c();
  c_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:InputFrame.c)
}
#if LANG_CXX11
inline void InputFrame::set_c(::std::string&& value) {
  set_has_c();
  c_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:InputFrame.c)
}
#endif
inline void InputFrame::set_c(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_c();
  c_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:InputFrame.c)
}
inline void InputFrame::set_c(const void* value, size_t size) {
  set_has_c();
  c_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:InputFrame.c)
}
inline ::std::string* InputFrame::mutable_c() {
  set_has_c();
  // @@protoc_insertion_point(field_mutable:InputFrame.c)
  return c_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InputFrame::release_c() {
  // @@protoc_insertion_point(field_release:InputFrame.c)
  clear_has_c();
  return c_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InputFrame::set_allocated_c(::std::string* c) {
  if (c != NULL) {
    set_has_c();
  } else {
    clear_has_c();
  }
  c_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), c);
  // @@protoc_insertion_point(field_set_allocated:InputFrame.c)
}

// -------------------------------------------------------------------

// ChatMsg

// required uint32 playerId = 1;
inline bool ChatMsg::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChatMsg::set_has_playerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChatMsg::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChatMsg::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 ChatMsg::playerid() const {
  // @@protoc_insertion_point(field_get:ChatMsg.playerId)
  return playerid_;
}
inline void ChatMsg::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
  // @@protoc_insertion_point(field_set:ChatMsg.playerId)
}

// required uint32 channelType = 2;
inline bool ChatMsg::has_channeltype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChatMsg::set_has_channeltype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChatMsg::clear_has_channeltype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChatMsg::clear_channeltype() {
  channeltype_ = 0u;
  clear_has_channeltype();
}
inline ::google::protobuf::uint32 ChatMsg::channeltype() const {
  // @@protoc_insertion_point(field_get:ChatMsg.channelType)
  return channeltype_;
}
inline void ChatMsg::set_channeltype(::google::protobuf::uint32 value) {
  set_has_channeltype();
  channeltype_ = value;
  // @@protoc_insertion_point(field_set:ChatMsg.channelType)
}

// required string chatMessage = 3;
inline bool ChatMsg::has_chatmessage() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChatMsg::set_has_chatmessage() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChatMsg::clear_has_chatmessage() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChatMsg::clear_chatmessage() {
  chatmessage_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_chatmessage();
}
inline const ::std::string& ChatMsg::chatmessage() const {
  // @@protoc_insertion_point(field_get:ChatMsg.chatMessage)
  return chatmessage_.GetNoArena();
}
inline void ChatMsg::set_chatmessage(const ::std::string& value) {
  set_has_chatmessage();
  chatmessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ChatMsg.chatMessage)
}
#if LANG_CXX11
inline void ChatMsg::set_chatmessage(::std::string&& value) {
  set_has_chatmessage();
  chatmessage_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ChatMsg.chatMessage)
}
#endif
inline void ChatMsg::set_chatmessage(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_chatmessage();
  chatmessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ChatMsg.chatMessage)
}
inline void ChatMsg::set_chatmessage(const char* value, size_t size) {
  set_has_chatmessage();
  chatmessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ChatMsg.chatMessage)
}
inline ::std::string* ChatMsg::mutable_chatmessage() {
  set_has_chatmessage();
  // @@protoc_insertion_point(field_mutable:ChatMsg.chatMessage)
  return chatmessage_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChatMsg::release_chatmessage() {
  // @@protoc_insertion_point(field_release:ChatMsg.chatMessage)
  clear_has_chatmessage();
  return chatmessage_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChatMsg::set_allocated_chatmessage(::std::string* chatmessage) {
  if (chatmessage != NULL) {
    set_has_chatmessage();
  } else {
    clear_has_chatmessage();
  }
  chatmessage_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), chatmessage);
  // @@protoc_insertion_point(field_set_allocated:ChatMsg.chatMessage)
}

// -------------------------------------------------------------------

// AudioChatMsg

// required uint32 playerId = 1;
inline bool AudioChatMsg::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AudioChatMsg::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AudioChatMsg::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AudioChatMsg::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 AudioChatMsg::playerid() const {
  // @@protoc_insertion_point(field_get:AudioChatMsg.playerId)
  return playerid_;
}
inline void AudioChatMsg::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
  // @@protoc_insertion_point(field_set:AudioChatMsg.playerId)
}

// required uint32 type = 2;
inline bool AudioChatMsg::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AudioChatMsg::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AudioChatMsg::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AudioChatMsg::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 AudioChatMsg::type() const {
  // @@protoc_insertion_point(field_get:AudioChatMsg.type)
  return type_;
}
inline void AudioChatMsg::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:AudioChatMsg.type)
}

// repeated float audio_data = 3;
inline int AudioChatMsg::audio_data_size() const {
  return audio_data_.size();
}
inline void AudioChatMsg::clear_audio_data() {
  audio_data_.Clear();
}
inline float AudioChatMsg::audio_data(int index) const {
  // @@protoc_insertion_point(field_get:AudioChatMsg.audio_data)
  return audio_data_.Get(index);
}
inline void AudioChatMsg::set_audio_data(int index, float value) {
  audio_data_.Set(index, value);
  // @@protoc_insertion_point(field_set:AudioChatMsg.audio_data)
}
inline void AudioChatMsg::add_audio_data(float value) {
  audio_data_.Add(value);
  // @@protoc_insertion_point(field_add:AudioChatMsg.audio_data)
}
inline const ::google::protobuf::RepeatedField< float >&
AudioChatMsg::audio_data() const {
  // @@protoc_insertion_point(field_list:AudioChatMsg.audio_data)
  return audio_data_;
}
inline ::google::protobuf::RepeatedField< float >*
AudioChatMsg::mutable_audio_data() {
  // @@protoc_insertion_point(field_mutable_list:AudioChatMsg.audio_data)
  return &audio_data_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::MeteorMsg_MsgType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MeteorMsg_MsgType>() {
  return ::MeteorMsg_MsgType_descriptor();
}
template <> struct is_proto_enum< ::RoomInfo_RoomRule> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RoomInfo_RoomRule>() {
  return ::RoomInfo_RoomRule_descriptor();
}
template <> struct is_proto_enum< ::RoomInfo_RoomPattern> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RoomInfo_RoomPattern>() {
  return ::RoomInfo_RoomPattern_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protocol_2eproto__INCLUDED
